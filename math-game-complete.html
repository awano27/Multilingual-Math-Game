<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Math Dungeon - Complete Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles/game-enhancements.css" />
    <script src="data/grade-content.js"></script>
    <style>
        @keyframes heroFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        @keyframes monsterFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-8px) scale(1.05); }
        }
        @keyframes bossFloat {
            0%, 100% { transform: translateY(0px) scale(1) rotate(0deg); }
            25% { transform: translateY(-5px) scale(1.05) rotate(-5deg); }
            50% { transform: translateY(-10px) scale(1.1) rotate(0deg); }
            75% { transform: translateY(-5px) scale(1.05) rotate(5deg); }
        }
        @keyframes goalRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .animate-hero { animation: heroFloat 2s ease-in-out infinite; }
        .animate-monster { animation: monsterFloat 3s ease-in-out infinite; }
        .animate-boss { animation: bossFloat 1.5s ease-in-out infinite; }
        .animate-goal { animation: goalRotate 3s linear infinite; }

        /* Prevent text selection and zooming on mobile */
        body {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        /* Heart icon styles */
        .heart {
            display: inline-block;
            width: 30px;
            height: 30px;
        }
        .heart.filled {
            color: #ef4444;
        }
        .heart.empty {
            color: #d1d5db;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useCallback, useMemo, useRef } = React;

const STORAGE_KEYS = {
    language: 'mathDungeon.language',
    learningLanguage: 'mathDungeon.learningLanguage',
    stats: 'mathDungeon.progress.v2'
};

const BLUEPRINT = window.MATH_ADVENTURE_BLUEPRINT || {
    gradeCurriculum: {
        2: {
            displayName: 'Grade 2',
            focusSkills: ['addition_carry', 'subtraction_borrow', 'clock_reading', 'money_counting', 'even_odd'],
            battleTypes: ['addition_carry', 'subtraction_borrow', 'clock_reading', 'money_counting', 'even_odd'],
            featuredWorlds: ['forest', 'city'],
            quests: [
                {
                    id: 'g2-firefly-rescue',
                    title: 'Firefly Rescue in Urawa',
                    summary: 'Collect light orbs with teamwork addition drills to guide fireflies back to the river.',
                    steps: [
                        'Clear five addition-with-carry problems in a single dungeon run.',
                        'Share at least one hint with a partner in a co-op maze.',
                        'Defeat the Thunder Gatekeeper to open the marsh gate.'
                    ],
                    rewards: { points: 180, badge: 'forest_scout', unlocks: ['companion:mizu_slime', 'shop:cape_forest'] },
                    region: 'urawa',
                    themeWorld: 'forest'
                },
                {
                    id: 'g2-market-math',
                    title: 'Omiya Market Math Rally',
                    summary: 'Help local vendors count change and balance stalls before sunset.',
                    steps: [
                        'Win three rounds of the coin counting mini game.',
                        'Solve two clock puzzles to schedule the market bell.',
                        'Capture the runaway Beetle guardian to finish the shift.'
                    ],
                    rewards: { points: 160, badge: 'coin_artist', unlocks: ['shop:merchant_hat'] },
                    region: 'omiya',
                    themeWorld: 'city'
                }
            ],
            cooperativeScenarios: [
                {
                    id: 'g2-hint-bridge',
                    title: 'Firefly Bridge Build',
                    description: 'Trade hints with a friend to build a bridge of correct sums.',
                    coreSkill: 'addition_carry',
                    estimatedTurns: 6,
                    recommendedPlayers: 2,
                    supportActions: ['hint', 'cheer']
                },
                {
                    id: 'g2-river-patrol',
                    title: 'River Patrol',
                    description: 'Alternate subtraction answers to keep the dam stable.',
                    coreSkill: 'subtraction_borrow',
                    estimatedTurns: 5,
                    recommendedPlayers: 2,
                    supportActions: ['double_check']
                }
            ],
            versusScenarios: [
                {
                    id: 'g2-speed-lanterns',
                    title: 'Lantern Lighting Dash',
                    description: 'Race to light 10 lanterns by solving additions faster than your rival.',
                    coreSkill: 'addition_carry',
                    timeLimit: 60,
                    victoryCondition: 'score'
                },
                {
                    id: 'g2-parity-sprint',
                    title: 'Even-Odd Sprint',
                    description: 'Tag numbers as even or odd before the opposing team.',
                    coreSkill: 'even_odd',
                    timeLimit: 45,
                    victoryCondition: 'streak'
                }
            ]
        },
        3: {
            displayName: 'Grade 3',
            focusSkills: ['multiplication_array', 'division_basic', 'word_problem', 'unit_conversion', 'data_reading'],
            battleTypes: ['multiplication_array', 'division_basic', 'word_problem', 'unit_conversion', 'data_reading'],
            featuredWorlds: ['space', 'museum'],
            quests: [
                {
                    id: 'g3-gear-laboratory',
                    title: 'Gear Laboratory Mystery',
                    summary: 'Investigate the clockwork lab in Omiya and restore the missing gears.',
                    steps: [
                        'Complete a multiplication combo streak of six.',
                        'Solve a unit conversion puzzle to calibrate the gear machine.',
                        'Defeat Mathemperor in a boss battle without dropping below two hearts.'
                    ],
                    rewards: { points: 260, badge: 'unit_wizard', unlocks: ['companion:gear_fox', 'shop:astro_cape'] },
                    region: 'omiya',
                    themeWorld: 'museum'
                },
                {
                    id: 'g3-cosmic-express',
                    title: 'Cosmic Express Rescue',
                    summary: 'Fix the timetable of the space express before it leaves Saitama orbit.',
                    steps: [
                        'Win two division-basic versus matches in a row.',
                        'Clear a story beat with 100% accuracy.',
                        'Guide the Dragonfly scout through an AR checkpoint in Minuma.'
                    ],
                    rewards: { points: 300, badge: 'versus_champion', unlocks: ['shop:stellar_staff'] },
                    region: 'iwatsuki',
                    themeWorld: 'space'
                }
            ],
            cooperativeScenarios: [
                {
                    id: 'g3-data-rescue',
                    title: 'Sky Observatory Data Rescue',
                    description: 'Share clues to read sky charts and repair the telescope.',
                    coreSkill: 'data_reading',
                    estimatedTurns: 7,
                    recommendedPlayers: 3,
                    supportActions: ['hint', 'swap']
                },
                {
                    id: 'g3-word-strike',
                    title: 'Story Problem Strike Team',
                    description: 'Break down word problems by assigning roles for clue finding.',
                    coreSkill: 'word_problem',
                    estimatedTurns: 6,
                    recommendedPlayers: 2,
                    supportActions: ['highlight', 'cheer']
                }
            ],
            versusScenarios: [
                {
                    id: 'g3-orb-sprint',
                    title: 'Orb Sprint Finals',
                    description: 'Answer multiplication arrays to propel your orb across the arena.',
                    coreSkill: 'multiplication_array',
                    timeLimit: 50,
                    victoryCondition: 'distance'
                },
                {
                    id: 'g3-conversion-clash',
                    title: 'Conversion Clash',
                    description: 'Convert tricky measurements quicker than the rival crew.',
                    coreSkill: 'unit_conversion',
                    timeLimit: 55,
                    victoryCondition: 'score'
                }
            ]
        }
    },
    themeWorlds: [
        { id: 'forest', title: 'Greenwood Firefly Forest', icon: 'ğŸŒ²', description: 'A gentle forest near the Arakawa river filled with insect missions.', gradeRange: [2], region: 'urawa', seasonalEvents: ['spring_sakura', 'summer_firefly'] },
        { id: 'city', title: 'Omiya Market Street', icon: 'ğŸ¬', description: 'Bustling stalls for money and time problems.', gradeRange: [2, 3], region: 'omiya', seasonalEvents: ['autumn_market'] },
        { id: 'museum', title: 'Railway Museum Annex', icon: 'ğŸš‚', description: 'Machines, schedules, and data interpretation challenges.', gradeRange: [3], region: 'omiya', seasonalEvents: ['winter_illumination'] },
        { id: 'space', title: 'Saitama Star Station', icon: 'ğŸŒŒ', description: 'Float through zero gravity multiplication nebulae.', gradeRange: [3], region: 'iwatsuki', seasonalEvents: ['summer_firefly', 'winter_illumination'] }
    ],
    badgeCatalog: [
        { id: 'carry_master', name: 'Carry Master', description: 'Keep a streak of accurate carry additions.', requirement: { type: 'streak', skill: 'addition_carry', count: 5 }, reward: { points: 120, shopUnlock: 'cape_forest' } },
        { id: 'coin_artist', name: 'Coin Artist', description: 'Master the coin counting mini game.', requirement: { type: 'miniGame', miniGame: 'coin_count', wins: 5 }, reward: { points: 100, shopUnlock: 'merchant_hat' } },
        { id: 'clock_guardian', name: 'Clock Guardian', description: 'Protect the town bell with accurate clocks.', requirement: { type: 'streak', skill: 'clock_reading', count: 4 }, reward: { points: 110, shopUnlock: 'aura_firefly' } },
        { id: 'times_table_hero', name: 'Times Table Hero', description: 'Hold a multiplication streak against a boss.', requirement: { type: 'streak', skill: 'multiplication_array', count: 6 }, reward: { points: 150, shopUnlock: 'astro_cape' } },
        { id: 'unit_wizard', name: 'Unit Wizard', description: 'Convert measurements flawlessly.', requirement: { type: 'miniGame', miniGame: 'unit_conversion_lab', wins: 4 }, reward: { points: 140, shopUnlock: 'stellar_staff' } },
        { id: 'story_scholar', name: 'Story Scholar', description: 'Complete the core adventure story.', requirement: { type: 'storyClear', episodes: 5 }, reward: { points: 200, shopUnlock: 'chronicle_tome' } },
        { id: 'forest_scout', name: 'Forest Scout', description: 'Finish the Firefly Rescue quest.', requirement: { type: 'quest', questId: 'g2-firefly-rescue' }, reward: { points: 160, companion: 'mizu_slime' } },
        { id: 'versus_champion', name: 'Versus Champion', description: 'Win multiple head-to-head matches.', requirement: { type: 'versus', wins: 6 }, reward: { points: 220, shopUnlock: 'victory_crown' } },
        { id: 'coop_hero', name: 'Co-op Hero', description: 'Lead successful co-op missions.', requirement: { type: 'coop', successes: 6 }, reward: { points: 180, shopUnlock: 'team_band' } },
        { id: 'ar_explorer', name: 'AR Explorer', description: 'Clear seasonal AR fieldwork.', requirement: { type: 'arMission', count: 3 }, reward: { points: 150, shopUnlock: 'field_satchel' } }
    ],
    shopInventory: [
        { id: 'cape_forest', type: 'outfit', slot: 'cape', name: 'Forest Glow Cape', icon: 'ğŸ¦‹', price: 200, grade: 2, description: 'Shimmers when combos reach three.', requirement: { badge: 'carry_master' } },
        { id: 'merchant_hat', type: 'outfit', slot: 'head', name: 'Market Merchant Hat', icon: 'ğŸ©', price: 150, grade: 2, description: 'Earns +5 coins bonus from mini games in the city.', requirement: { badge: 'coin_artist' } },
        { id: 'astro_cape', type: 'outfit', slot: 'cape', name: 'Astro Navigator Cape', icon: 'ğŸª', price: 260, grade: 3, description: 'Adds a star trail in space mazes.', requirement: { badge: 'times_table_hero' } },
        { id: 'stellar_staff', type: 'weapon', slot: 'weapon', name: 'Stellar Staff', icon: 'âœ¨', price: 280, grade: 3, description: 'Doubles boss bonus when solving unit conversions.', requirement: { badge: 'unit_wizard' } },
        { id: 'aura_firefly', type: 'aura', slot: 'aura', name: 'Firefly Aura', icon: 'ğŸ”†', price: 180, grade: 2, description: 'Glows brighter with each correct answer streak.', requirement: { badge: 'forest_scout' } },
        { id: 'team_band', type: 'outfit', slot: 'accessory', name: 'Teamwork Wristband', icon: 'ğŸ¤', price: 190, grade: 2, description: 'Adds bonus hints in co-op missions.', requirement: { badge: 'coop_hero' } },
        { id: 'victory_crown', type: 'outfit', slot: 'head', name: 'Victory Crown', icon: 'ğŸ‘‘', price: 320, grade: 3, description: 'Grants a versus entrance animation.', requirement: { badge: 'versus_champion' } },
        { id: 'field_satchel', type: 'accessory', slot: 'back', name: 'Fieldwork Satchel', icon: 'ğŸ’', price: 170, grade: 2, description: 'Carries AR mission tools.', requirement: { badge: 'ar_explorer' } }
    ],
    aiTutorProfiles: {
        adaptiveCoach: {
            id: 'adaptiveCoach',
            name: 'Aico',
            description: 'Balances encouragement and challenge based on accuracy.',
            cheers: {
                correct: ['Great focus! Keep that streak going!', 'Nice work! Your combo is lighting up the dungeon!'],
                incorrect: ['Almost there. Try a hint and look at the ones place.', 'Take a breath, check the question slowly.']
            },
            tips: {
                addition_carry: 'Stack the numbers so the ones place lines up first.',
                unit_conversion: 'Think about whether the answer should be bigger or smaller.'
            }
        },
        storyGuide: {
            id: 'storyGuide',
            name: 'Tomo the Bard',
            description: 'Narrates story beats and gives lore-based hints.',
            cheers: {
                correct: ['The villagers will sing of that solution!', 'Another chapter completed!'],
                incorrect: ['Heroes learn from every puzzle. Try sketching the story.']
            },
            tips: { word_problem: 'Underline who, what, and how many before solving.' }
        },
        speedTrainer: {
            id: 'speedTrainer',
            name: 'Coach Rika',
            description: 'Pushes quick-fire play for versus and track events.',
            cheers: {
                correct: ['Speed star! Keep the pace up!', 'That answer was lightning fast!'],
                incorrect: ['Reset stance, read again, fire when ready!']
            },
            tips: { even_odd: 'Check the last digit before you decide.' }
        }
    },
    miniGameConfigs: {
        clock_match: { id: 'clock_match', title: 'Clock Match Challenge', description: 'Match analogue clocks to digital times before the bell rings.', grade: 2, icon: 'ğŸ•’', mode: 'choice', skill: 'clock_reading', timeLimit: 45 },
        coin_count: { id: 'coin_count', title: 'Market Coin Count', description: 'Pick the right coins to pay customers quickly.', grade: 2, icon: 'ğŸ’°', mode: 'choice', skill: 'money_counting', timeLimit: 40 },
        even_odd_sort: { id: 'even_odd_sort', title: 'Firefly Parity Sort', description: 'Drag numbers into even or odd lanterns.', grade: 2, icon: 'ğŸ”¢', mode: 'drag', skill: 'even_odd', timeLimit: 35 },
        array_painter: { id: 'array_painter', title: 'Array Painter', description: 'Paint dot arrays to visualize multiplication.', grade: 3, icon: 'ğŸ¨', mode: 'grid', skill: 'multiplication_array', timeLimit: 50 },
        unit_conversion_lab: { id: 'unit_conversion_lab', title: 'Conversion Lab', description: 'Fix the measurement machine by converting units.', grade: 3, icon: 'âš—ï¸', mode: 'input', skill: 'unit_conversion', timeLimit: 55 },
        story_solver: { id: 'story_solver', title: 'Story Solver', description: 'Piece together word problems in the library archives.', grade: 3, icon: 'ğŸ“–', mode: 'choice', skill: 'word_problem', timeLimit: 60 },
        speed_sums: { id: 'speed_sums', title: 'Speed Sums Circuit', description: 'Short burst arithmetic for versus training.', grade: 2, icon: 'âš¡', mode: 'input', skill: 'addition_carry', timeLimit: 30 }
    },
    storyBeats: [
        { id: 'prologue', grade: 2, order: 1, title: 'Prologue: The Stolen Math Stone', summary: 'A mysterious shadow steals the Math Stone from Saitama Castle. The heroes set out from Urawa to recover it.' },
        { id: 'firefly-bridge', grade: 2, order: 2, title: 'Firefly Bridge', summary: 'Fireflies guide the way across the marsh. Solve gentle sums to keep the bridge glowing.' },
        { id: 'market-night', grade: 2, order: 3, title: 'Market Night Alarm', summary: 'Balance change for the vendors before the night bell tolls.' },
        { id: 'thunder-gate', grade: 2, order: 4, title: 'Thunder Gate Showdown', summary: 'Face Raiden King in a flashing duel of addition and subtraction.' },
        { id: 'starlit-departure', grade: 2, order: 5, title: 'Starlit Departure', summary: 'With the gate open, the party boards the express to the star station.' },
        { id: 'arrival-space', grade: 3, order: 1, title: 'Arrival at Star Station', summary: 'The heroes float into the star station and meet the gear engineer.' },
        { id: 'gear-lab', grade: 3, order: 2, title: 'Gear Laboratory Mystery', summary: 'Fix clockwork engines by arranging multiplication arrays.' },
        { id: 'orb-festival', grade: 3, order: 3, title: 'Orb Festival Finals', summary: 'Compete in the cosmic arena to earn the star crest.' },
        { id: 'cosmic-finale', grade: 3, order: 4, title: 'Cosmic Finale', summary: 'Defeat Mathemperor and restore the Math Stone to Saitama.' }
    ],
    companionCatalog: [
        { id: 'mizu_slime', name: 'Mizu Slime', icon: 'ğŸ’§', description: 'Adds a gentle hint about place value after a mistake.', ability: 'place_value_hint', unlockCondition: { badge: 'forest_scout' } },
        { id: 'gear_fox', name: 'Gear Fox', icon: 'ğŸ¦Š', description: 'Boosts conversion mini game rewards by 10%.', ability: 'conversion_boost', unlockCondition: { badge: 'unit_wizard' } },
        { id: 'rail_rabbit', name: 'Rail Rabbit', icon: 'ğŸ‡', description: 'Starts versus matches with a speed boost.', ability: 'versus_speed', unlockCondition: { badge: 'versus_champion' } }
    ],
    arMissionCatalog: [
        { id: 'spring_sakura', title: 'Sakura Petal Survey', season: 'spring', area: 'urawa', skill: 'even_odd', description: 'Count petals at the shrine and tag even numbers for blessings.', reward: { points: 80, badge: null } },
        { id: 'summer_firefly', title: 'Firefly Light Trail', season: 'summer', area: 'omiya', skill: 'addition_carry', description: 'Trace a glowing trail along the river and answer addition flashes.', reward: { points: 90, badge: 'forest_scout' } },
        { id: 'autumn_market', title: 'Harvest Market Riddle', season: 'autumn', area: 'omiya', skill: 'money_counting', description: 'Match stall prices with coin sets during the harvest fair.', reward: { points: 95, badge: 'coin_artist' } },
        { id: 'winter_illumination', title: 'Winter Illumination Quest', season: 'winter', area: 'iwatsuki', skill: 'multiplication_array', description: 'Light up arrays of lanterns across the ice garden.', reward: { points: 120, badge: 'story_scholar' } }
    ],
    rewardTracks: [
        { id: 'weekly', title: 'Weekly Adventure Track', description: 'Earn points each week to unlock cosmetics and boosts.', milestones: [
            { points: 200, reward: { type: 'item', id: 'team_band' } },
            { points: 400, reward: { type: 'companion', id: 'rail_rabbit' } },
            { points: 650, reward: { type: 'aura', id: 'aura_firefly' } }
        ] },
        { id: 'seasonal', title: 'Seasonal Explorer Track', description: 'Complete AR missions across the seasons.', milestones: [
            { count: 1, reward: { type: 'badge', id: 'ar_explorer' } },
            { count: 3, reward: { type: 'item', id: 'field_satchel' } }
        ] }
    ],
    seasonalShowcases: [
        { id: 'spring', title: 'Spring Blossom Festival', summary: 'Collect petals, listen to new music tracks, and unlock sakura frames.' },
        { id: 'summer', title: 'Summer River Quest', summary: 'Dive into water-themed puzzles and cooperative rescue missions.' },
        { id: 'autumn', title: 'Autumn Harvest Carnival', summary: 'Balance budgets for friendly vendors and earn market costumes.' },
        { id: 'winter', title: 'Winter Starry Night', summary: 'Explore illuminated mazes with snow particle effects.' }
    ]
};

const {
    gradeCurriculum,
    themeWorlds,
    badgeCatalog,
    shopInventory,
    aiTutorProfiles,
    miniGameConfigs,
    storyBeats,
    companionCatalog,
    arMissionCatalog = [],
    rewardTracks = [],
    seasonalShowcases = []
} = BLUEPRINT;
class I18nManager {
    constructor(resources, defaultLang = 'ja') {
        this.resources = resources;
        this.defaultLang = resources[defaultLang] ? defaultLang : Object.keys(resources)[0] || 'ja';
        this.storageKey = STORAGE_KEYS.language;
    }

    restoreLanguage() {
        if (typeof window === 'undefined' || !window.localStorage) {
            return this.defaultLang;
        }
        try {
            const stored = window.localStorage.getItem(this.storageKey);
            if (stored && this.resources[stored]) {
                return stored;
            }
        } catch (error) {
            console.warn('i18n restore failed', error);
        }
        return this.defaultLang;
    }

    persistLanguage(lang) {
        if (typeof window === 'undefined' || !window.localStorage) {
            return;
        }
        try {
            window.localStorage.setItem(this.storageKey, lang);
        } catch (error) {
            console.warn('i18n persist failed', error);
        }
    }

    getLanguage(lang) {
        return this.resources[lang] || this.resources[this.defaultLang];
    }

    listLanguages() {
        return Object.keys(this.resources);
    }

    translate(lang, keyPath, fallback) {
        const segments = keyPath.split('.');
        let current = this.getLanguage(lang);
        for (const segment of segments) {
            if (current && Object.prototype.hasOwnProperty.call(current, segment)) {
                current = current[segment];
            } else {
                current = undefined;
                break;
            }
        }
        if (current !== undefined) {
            return current;
        }
        let base = this.getLanguage(this.defaultLang);
        for (const segment of segments) {
            if (base && Object.prototype.hasOwnProperty.call(base, segment)) {
                base = base[segment];
            } else {
                base = undefined;
                break;
            }
        }
        return base !== undefined ? base : (fallback !== undefined ? fallback : keyPath);
    }
}

const DIFFICULTY_ORDER = ['easy', 'normal', 'hard'];

class QuestionManager {
    constructor(questionSets = []) {
        this.questionSets = questionSets;
        this.cache = new Map();
    }

    _key(grade, subject, lang) {
        return `${grade}-${subject}-${lang}`;
    }

    loadQuestions({ grade, subject, lang }) {
        const cacheKey = this._key(grade, subject, lang);
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }

        const questions = this.questionSets
            .filter(item => item.grade === grade && item.subject === subject && item.translations && item.translations[lang])
            .map(item => {
                const localized = item.translations[lang];
                return {
                    id: `${item.subject}-${lang}-${item.grade}-${item.suffix || '0000'}`,
                    grade: item.grade,
                    subject: item.subject,
                    type: item.type,
                    difficulty: item.difficulty,
                    lang,
                    prompt: localized.prompt,
                    choices: Array.isArray(localized.choices) ? [...localized.choices] : [],
                    answer: localized.answer,
                    explanation: localized.explanation,
                    hints: Array.isArray(localized.hints) ? [...localized.hints] : [],
                    tts: localized.tts ? { ...localized.tts } : null,
                    suffix: item.suffix || '0000'
                };
            });

        this.cache.set(cacheKey, questions);
        return questions;
    }

    getRandomQuestion({ grade, subject, lang, difficulty, questionTypes, excludeIds = [] }) {
        let pool = this.loadQuestions({ grade, subject, lang }).filter(question => !excludeIds.includes(question.id));
        if (Array.isArray(questionTypes) && questionTypes.length > 0) {
            pool = pool.filter(question => questionTypes.includes(question.type));
        }
        if (pool.length === 0) {
            return null;
        }

        const order = difficulty
            ? [difficulty, ...DIFFICULTY_ORDER.filter(level => level !== difficulty)]
            : DIFFICULTY_ORDER;

        for (const level of order) {
            const candidates = pool.filter(question => question.difficulty === level);
            if (candidates.length > 0) {
                return candidates[Math.floor(Math.random() * candidates.length)];
            }
        }

        return pool[Math.floor(Math.random() * pool.length)];
    }

    getQuestionForLanguage({ grade, subject, suffix, lang }) {
        const entry = this.questionSets.find(item => item.grade === grade && item.subject === subject && item.suffix === suffix);
        if (!entry || !entry.translations || !entry.translations[lang]) {
            return null;
        }
        const localized = entry.translations[lang];
        return {
            id: `${subject}-${lang}-${grade}-${suffix}`,
            grade,
            subject,
            type: entry.type,
            difficulty: entry.difficulty,
            lang,
            prompt: localized.prompt,
            choices: Array.isArray(localized.choices) ? [...localized.choices] : [],
            answer: localized.answer,
            explanation: localized.explanation,
            hints: Array.isArray(localized.hints) ? [...localized.hints] : [],
            tts: localized.tts ? { ...localized.tts } : null,
            suffix: suffix || '0000'
        };
    }

}

const KOKUGO_QUESTION_BANK = ï»¿[
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0001",
    "type": "reading",
    "difficulty": "easy",
    "translations": {
      "ja": {
        "prompt": "ã€Œã‚ã‚ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["é›¨", "é£´", "é›²", "é¢¨"],
        "answer": "é›¨",
        "explanation": "å¤©æ°—ã®ã€Œã‚ã‚ã€ã¯æ¼¢å­—ã§ã€Œé›¨ã€ã¨æ›¸ãã¾ã™ã€‚",
        "hints": ["å¤©æ°—ã«é–¢ä¿‚ãŒã‚ã‚Šã¾ã™ã€‚", "ç©ºã‹ã‚‰ãµã‚‹ã‚‚ã®ã§ã™ã€‚"],
        "tts": {"text": "ã€Œã‚ã‚ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the kanji for 'ame' meaning rain.",
        "choices": ["é›¨", "é£´", "é›²", "é¢¨"],
        "answer": "é›¨",
        "explanation": "When 'ame' means rain we use the kanji ã€Œé›¨ã€ã€‚",
        "hints": ["Think about weather words.", "It falls from the sky."],
        "tts": {"text": "Choose the kanji for ame meaning rain.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez le kanji pour Â« ame Â» (pluie).",
        "choices": ["é›¨", "é£´", "é›²", "é¢¨"],
        "answer": "é›¨",
        "explanation": "Le mot japonais Â« ame Â» (pluie) s'Ã©crit avec le kanji ã€Œé›¨ã€ã€‚",
        "hints": ["Pensez Ã  la mÃ©tÃ©o.", "Cela tombe du ciel."],
        "tts": {"text": "Choisissez le kanji pour ame signifiant pluie.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºä»£è¡¨ã€Œé›¨ã€æ„æ€çš„ã€Œameã€çš„æ¼¢å­—ã€‚",
        "choices": ["é›¨", "é£´", "é›²", "é¢¨"],
        "answer": "é›¨",
        "explanation": "ç•¶ã€Œameã€è¡¨ç¤ºä¸‹é›¨æ™‚ï¼Œè¦å¯«æˆæ¼¢å­—ã€Œé›¨ã€ã€‚",
        "hints": ["æƒ³ä¸€æƒ³å¤©æ°£çš„è©èªã€‚", "å®ƒæœƒå¾å¤©ç©ºè½ä¸‹ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºä»£è¡¨é›¨æ„æ€çš„ameçš„æ¼¢å­—ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0002",
    "type": "kanji",
    "difficulty": "easy",
    "translations": {
      "ja": {
        "prompt": "ã€Œæµ·ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã†ã¿", "ã‚„ã¾", "ã‹ã‚", "ãã‚‰"],
        "answer": "ã†ã¿",
        "explanation": "ã€Œæµ·ã€ã¯ã€Œã†ã¿ã€ã¨èª­ã¿ã¾ã™ã€‚",
        "hints": ["æ°´ãŒãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚", "ç ‚æµœãŒã‚ã‚Šã¾ã™ã€‚"],
        "tts": {"text": "ã€Œæµ·ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the reading for the kanji ã€Œæµ·ã€ã€‚",
        "choices": ["umi", "yama", "kawa", "sora"],
        "answer": "umi",
        "explanation": "The kanji ã€Œæµ·ã€ is read 'umi', meaning sea.",
        "hints": ["It is full of water.", "There is a beach."],
        "tts": {"text": "Choose the reading for the kanji umi.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez la lecture du kanji ã€Œæµ·ã€ã€‚",
        "choices": ["umi", "yama", "kawa", "sora"],
        "answer": "umi",
        "explanation": "Le kanji ã€Œæµ·ã€ se lit Â« umi Â», c'est la mer.",
        "hints": ["Il y a beaucoup d'eau.", "On y trouve une plage."],
        "tts": {"text": "Choisissez la lecture du kanji umi.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºæ¼¢å­—ã€Œæµ·ã€çš„è®€éŸ³ã€‚",
        "choices": ["ã†ã¿", "ã‚„ã¾", "ã‹ã‚", "ãã‚‰"],
        "answer": "ã†ã¿",
        "explanation": "æ¼¢å­—ã€Œæµ·ã€è®€ä½œã€Œã†ã¿ã€ï¼Œæ„æ€æ˜¯å¤§æµ·ã€‚",
        "hints": ["æœ‰å¾ˆå¤šæ°´ã€‚", "æœ‰æ²™ç˜ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºæ¼¢å­—æµ·çš„è®€éŸ³ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0003",
    "type": "vocab",
    "difficulty": "easy",
    "translations": {
      "ja": {
        "prompt": "ã€Œå…ƒæ°—ã€ã¨è¿‘ã„æ„å‘³ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã„ãã„ã", "ã¤ã‹ã‚Œ", "ã­ã‚€ãŸã„", "ã•ã‚€ã„"],
        "answer": "ã„ãã„ã",
        "explanation": "ã€Œå…ƒæ°—ã€ã«è¿‘ã„ã“ã¨ã°ã¯ã€Œã„ãã„ãã€ã§ã™ã€‚",
        "hints": ["æ˜ã‚‹ãå‹•ãã¾ã‚ã‚‹ã‚ˆã†ã™ã€‚", "åå¯¾ã¯ã¤ã‹ã‚Œã¦ã„ã‚‹ã“ã¨ã€‚"],
        "tts": {"text": "ã€Œå…ƒæ°—ã€ã¨è¿‘ã„æ„å‘³ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the word closest in meaning to 'genki' (lively).",
        "choices": ["lively", "tired", "sleepy", "cold"],
        "answer": "lively",
        "explanation": "'Genki' is closest to 'lively'.",
        "hints": ["Think of someone full of energy.", "The opposite is tired."],
        "tts": {"text": "Choose the word closest in meaning to genki.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez le mot qui signifie presque la mÃªme chose que Â« genki Â» (plein d'Ã©nergie).",
        "choices": ["plein d'Ã©nergie", "fatiguÃ©", "somnolent", "froid"],
        "answer": "plein d'Ã©nergie",
        "explanation": "Â« Genki Â» signifie Â« plein d'Ã©nergie Â».",
        "hints": ["Imaginez quelqu'un plein d'entrain.", "Le contraire est fatiguÃ©."],
        "tts": {"text": "Choisissez le mot proche de genki.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºæœ€æ¥è¿‘ã€Œå…ƒæ°—ã€æ„æ€çš„è©èªã€‚",
        "choices": ["æœ‰ç²¾ç¥", "ç–²å€¦", "æƒ³ç¡", "å¯’å†·"],
        "answer": "æœ‰ç²¾ç¥",
        "explanation": "ã€Œå…ƒæ°—ã€æœ€æ¥è¿‘ã€Œæœ‰ç²¾ç¥ã€ã€‚",
        "hints": ["æƒ³åƒä¸€å€‹å……æ»¿æ´»åŠ›çš„äººã€‚", "åç¾©è©æ˜¯ç–²å€¦ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºæœ€æ¥è¿‘å…ƒæ°—æ„æ€çš„è©èªã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0004",
    "type": "comprehension",
    "difficulty": "normal",
    "translations": {
      "ja": {
        "prompt": "ã¯ã‚‹ã¨ãã‚“ã¯æœæ—©ãèµ·ãã¦åº­ã®èŠ±ã«æ°´ã‚’ã‚„ã‚Šã¾ã—ãŸã€‚èŠ±ã¯ã†ã‚Œã—ãã†ã«ã‹ãŠã‚’ã‚ã’ã¾ã—ãŸã€‚ã“ã®æ–‡ã®ä¸»ãªå†…å®¹ã¨ã—ã¦æ­£ã—ã„ã‚‚ã®ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["èŠ±ã«æ°´ã‚’ã‚ã’ãŸ", "èŠ±ã‚’åˆ‡ã£ãŸ", "èŠ±ã‚’å£²ã£ãŸ", "èŠ±ã‚’é£Ÿã¹ãŸ"],
        "answer": "èŠ±ã«æ°´ã‚’ã‚ã’ãŸ",
        "explanation": "æ–‡ã¯èŠ±ã«æ°´ã‚’ã‚ã’ãŸã“ã¨ã‚’ä¼ãˆã¦ã„ã¾ã™ã€‚",
        "hints": ["ã¯ã‚‹ã¨ãã‚“ã¯ä½•ã‚’ã—ã¾ã—ãŸã‹ã€‚", "èŠ±ã¯ã©ã†ãªã‚Šã¾ã—ãŸã‹ã€‚"],
        "tts": {"text": "ã¯ã‚‹ã¨ãã‚“ã¯æœæ—©ãèµ·ãã¦åº­ã®èŠ±ã«æ°´ã‚’ã‚„ã‚Šã¾ã—ãŸã€‚â€¦â€¦æ­£ã—ã„å†…å®¹ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Haruto woke up early and watered the flowers in the garden. The flowers lifted their heads happily. Choose the main idea of this passage.",
        "choices": ["He watered the flowers", "He cut the flowers", "He sold the flowers", "He ate the flowers"],
        "answer": "He watered the flowers",
        "explanation": "The passage describes Haruto watering the flowers.",
        "hints": ["What did Haruto do?", "How did the flowers react?"],
        "tts": {"text": "Haruto woke up early and watered the flowers in the garden. Choose the main idea.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Haruto s'est rÃ©veillÃ© tÃ´t et a arrosÃ© les fleurs du jardin. Les fleurs ont levÃ© la tÃªte avec joie. Choisissez l'idÃ©e principale du texte.",
        "choices": ["Il a arrosÃ© les fleurs", "Il a coupÃ© les fleurs", "Il a vendu les fleurs", "Il a mangÃ© les fleurs"],
        "answer": "Il a arrosÃ© les fleurs",
        "explanation": "Le texte explique que Haruto a arrosÃ© les fleurs.",
        "hints": ["Que fait Haruto ?", "Que se passe-t-il avec les fleurs ?"],
        "tts": {"text": "Haruto s'est rÃ©veillÃ© tÃ´t et a arrosÃ© les fleurs. Choisissez l'idÃ©e principale.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "æ™´äººä¸€å¤§æ—©èµ·ä¾†ï¼Œç‚ºé™¢å­è£¡çš„èŠ±æ¾†æ°´ã€‚èŠ±å…’é«˜èˆˆåœ°æŠ¬èµ·é ­ã€‚è«‹é¸å‡ºé€™æ®µæ–‡å­—çš„ä¸»è¦å…§å®¹ã€‚",
        "choices": ["çµ¦èŠ±æ¾†æ°´", "æŠŠèŠ±å‰ªæ‰", "æŠŠèŠ±è³£æ‰", "æŠŠèŠ±åƒæ‰"],
        "answer": "çµ¦èŠ±æ¾†æ°´",
        "explanation": "æ–‡ç« èªªæ˜æ™´äººç‚ºèŠ±æ¾†æ°´ã€‚",
        "hints": ["æ™´äººåšäº†ä»€éº¼ï¼Ÿ", "èŠ±æœ‰ä»€éº¼è®ŠåŒ–ï¼Ÿ"],
        "tts": {"text": "æ™´äººä¸€æ—©èµ·ä¾†ç‚ºèŠ±æ¾†æ°´ã€‚è«‹é¸ä¸»è¦å…§å®¹ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0005",
    "type": "grammar",
    "difficulty": "normal",
    "translations": {
      "ja": {
        "prompt": "ã€Œã‚ãŸã— ___ ãŒã£ã“ã†ã«ã„ãã¾ã™ã€‚ã€ã«å…¥ã‚‹åŠ©è©ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã¯", "ã‚’", "ã§", "ã¨"],
        "answer": "ã¯",
        "explanation": "ä¸»èªã«ã¯ã€Œã¯ã€ã‚’ä½¿ã„ã¾ã™ã€‚",
        "hints": ["ä¸»èªã‚’ç¤ºã™åŠ©è©ã§ã™ã€‚", "ã€Œç§ã¯ã€ãŒåŸºæœ¬ã®å½¢ã§ã™ã€‚"],
        "tts": {"text": "ã€Œã‚ãŸã— ___ ãŒã£ã“ã†ã«ã„ãã¾ã™ã€‚ã€ã«å…¥ã‚‹åŠ©è©ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the correct particle: 'Watashi ___ gakkou ni ikimasu.'",
        "choices": ["wa", "wo", "de", "to"],
        "answer": "wa",
        "explanation": "The topic marker 'wa' is used for the subject.",
        "hints": ["It marks the topic of the sentence.", "Think of the phrase 'Watashi wa'."],
        "tts": {"text": "Choose the correct particle for Watashi blank gakkou ni ikimasu.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez la particule correcte : Â« Watashi ___ gakkou ni ikimasu. Â»",
        "choices": ["wa", "wo", "de", "to"],
        "answer": "wa",
        "explanation": "La particule Â« wa Â» marque le sujet.",
        "hints": ["Elle marque le thÃ¨me de la phrase.", "Pensez Ã  Â« Watashi wa Â»."],
        "tts": {"text": "Choisissez la particule pour Watashi blank gakkou ni ikimasu.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºæ­£ç¢ºçš„åŠ©è©ï¼šã€Œã‚ãŸã— ___ ãŒã£ã“ã†ã«ã„ãã¾ã™ã€‚ã€",
        "choices": ["ã¯", "ã‚’", "ã§", "ã¨"],
        "answer": "ã¯",
        "explanation": "ä¸»é¡ŒåŠ©è©è¦ç”¨ã€Œã¯ã€ã€‚",
        "hints": ["è¡¨ç¤ºå¥å­çš„ä¸»é¡Œã€‚", "æƒ³ä¸€æƒ³ã€Œã‚ãŸã—ã¯ã€ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºæ­£ç¢ºçš„åŠ©è© ã‚ãŸã— blank ãŒã£ã“ã†ã«ã„ãã¾ã™ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0006",
    "type": "reading",
    "difficulty": "normal",
    "translations": {
      "ja": {
        "prompt": "ã€ŒèŠ±ç«ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã¯ãªã³", "ã²ã¯ãª", "ã¯ãªãŠ", "ã¯ã²"],
        "answer": "ã¯ãªã³",
        "explanation": "ã€ŒèŠ±ç«ã€ã¯ã€Œã¯ãªã³ã€ã¨èª­ã¿ã¾ã™ã€‚",
        "hints": ["å¤ã®ãŠç¥­ã‚Šã§è¦‹ã¾ã™ã€‚", "å¤œç©ºã«ã²ã‹ã‚Šã¾ã™ã€‚"],
        "tts": {"text": "ã€ŒèŠ±ç«ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the reading for ã€ŒèŠ±ç«ã€ã€‚",
        "choices": ["hanabi", "hihana", "hanao", "hahi"],
        "answer": "hanabi",
        "explanation": "ã€ŒèŠ±ç«ã€ is read 'hanabi', meaning fireworks.",
        "hints": ["Seen at summer festivals.", "It lights up the night sky."],
        "tts": {"text": "Choose the reading for hanabi.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez la lecture de ã€ŒèŠ±ç«ã€ã€‚",
        "choices": ["hanabi", "hihana", "hanao", "hahi"],
        "answer": "hanabi",
        "explanation": "ã€ŒèŠ±ç«ã€ se lit Â« hanabi Â», ce sont les feux d'artifice.",
        "hints": ["On les voit aux festivals d'Ã©tÃ©.", "Elles illuminent le ciel nocturne."],
        "tts": {"text": "Choisissez la lecture de hanabi.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºã€ŒèŠ±ç«ã€çš„è®€éŸ³ã€‚",
        "choices": ["ã¯ãªã³", "ã²ã¯ãª", "ã¯ãªãŠ", "ã¯ã²"],
        "answer": "ã¯ãªã³",
        "explanation": "ã€ŒèŠ±ç«ã€è®€ä½œã€Œã¯ãªã³ã€ï¼Œæ„æ€æ˜¯ç…™ç«ã€‚",
        "hints": ["å¤å¤©ç¥­å…¸æœƒçœ‹åˆ°ã€‚", "æœƒåœ¨å¤œç©ºä¸­é–ƒäº®ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºèŠ±ç«çš„è®€éŸ³ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0007",
    "type": "kanji",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã€Œã¾ã¡ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ç”º", "é“", "æ£®", "æ ¡"],
        "answer": "ç”º",
        "explanation": "äººãŒãŸãã•ã‚“ãã‚‰ã™ã€Œã¾ã¡ã€ã¯ã€Œç”ºã€ã¨æ›¸ãã¾ã™ã€‚",
        "hints": ["å®¶ã‚„åº—ãŒä¸¦ã³ã¾ã™ã€‚", "é§…ãŒã‚ã‚‹ã¨ã“ã‚ã‚‚ã‚ã‚Šã¾ã™ã€‚"],
        "tts": {"text": "ã€Œã¾ã¡ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Write the kanji for 'machi' (town).",
        "choices": ["ç”º", "é“", "æ£®", "æ ¡"],
        "answer": "ç”º",
        "explanation": "The kanji for a town, 'machi', is ã€Œç”ºã€ã€‚",
        "hints": ["Many houses and shops.", "There might be a station."],
        "tts": {"text": "Write the kanji for machi meaning town.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Ã‰crivez le kanji de Â« machi Â» (ville).",
        "choices": ["ç”º", "é“", "æ£®", "æ ¡"],
        "answer": "ç”º",
        "explanation": "Pour Â« machi Â» qui signifie ville, on Ã©crit ã€Œç”ºã€ã€‚",
        "hints": ["Beaucoup de maisons et de magasins.", "On peut y trouver une gare."],
        "tts": {"text": "Ã‰crivez le kanji de machi signifiant ville.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹æŠŠã€Œã¾ã¡ã€å¯«æˆæ¼¢å­—ã€‚",
        "choices": ["ç”º", "é“", "æ£®", "æ ¡"],
        "answer": "ç”º",
        "explanation": "è¡¨ç¤ºåŸé®çš„ã€Œã¾ã¡ã€è¦å¯«æˆã€Œç”ºã€ã€‚",
        "hints": ["æœ‰å¾ˆå¤šæˆ¿å­å’Œå•†åº—ã€‚", "æœ‰æ™‚æœƒæœ‰è»Šç«™ã€‚"],
        "tts": {"text": "è«‹æŠŠã¾ã¡å¯«æˆæ¼¢å­—ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0008",
    "type": "vocab",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã€Œå¼±ã„ã€ã®åå¯¾ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["å¼·ã„", "ãŠãã„", "ãã‚‰ã„", "ã«ã¶ã„"],
        "answer": "å¼·ã„",
        "explanation": "ã€Œå¼±ã„ã€ã®åå¯¾èªã¯ã€Œå¼·ã„ã€ã§ã™ã€‚",
        "hints": ["åŠ›ãŒã‚ã‚‹ã‚ˆã†ã™ã€‚", "ã‚¹ãƒãƒ¼ãƒ„ãŒå¾—æ„ãªäººã‚’æ€ã„æµ®ã‹ã¹ã¾ã—ã‚‡ã†ã€‚"],
        "tts": {"text": "ã€Œå¼±ã„ã€ã®åå¯¾ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the antonym of 'weak'.",
        "choices": ["strong", "slow", "dark", "dull"],
        "answer": "strong",
        "explanation": "The opposite of weak is strong.",
        "hints": ["Think of someone with power.", "Imagine an athlete."],
        "tts": {"text": "Choose the antonym of weak.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez le contraire de Â« faible Â».",
        "choices": ["fort", "lent", "sombre", "terne"],
        "answer": "fort",
        "explanation": "Le contraire de Â« faible Â» est Â« fort Â».",
        "hints": ["Imaginez quelqu'un puissant.", "Pensez Ã  un sportif."],
        "tts": {"text": "Choisissez le contraire de faible.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºã€Œå¼±ã„ã€çš„åç¾©è©ã€‚",
        "choices": ["å¼·ã„", "é…ã„", "æš—ã„", "éˆã„"],
        "answer": "å¼·ã„",
        "explanation": "ã€Œå¼±ã„ã€çš„åç¾©è©æ˜¯ã€Œå¼·ã„ã€ã€‚",
        "hints": ["æƒ³ä¸€å€‹å¾ˆæœ‰åŠ›é‡çš„äººã€‚", "å¯ä»¥è¯æƒ³åˆ°é‹å‹•é¸æ‰‹ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºå¼±ã„çš„åç¾©è©ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0009",
    "type": "comprehension",
    "difficulty": "easy",
    "translations": {
      "ja": {
        "prompt": "ã‚†ã†ãã¡ã‚ƒã‚“ã¯å›³æ›¸é¤¨ã§æœ¬ã‚’å€Ÿã‚Šã¾ã—ãŸã€‚å®¶ã«å¸°ã‚‹ã¨ã™ãã«èª­ã‚“ã§ã€æ„Ÿæƒ³ã‚’æ—¥è¨˜ã«æ›¸ãã¾ã—ãŸã€‚ã‚†ã†ãã¡ã‚ƒã‚“ã®ã‚ˆã†ã™ã¨ã—ã¦æ­£ã—ã„ã‚‚ã®ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["æœ¬ãŒå¥½ã", "é‹å‹•ãŒå¥½ã", "ã­ã‚€ãŸã„", "ãŠãªã‹ãŒã™ã„ãŸ"],
        "answer": "æœ¬ãŒå¥½ã",
        "explanation": "ã™ãã«èª­ã¿ã€æ„Ÿæƒ³ã‚’æ›¸ã„ãŸã®ã§æœ¬ãŒå¥½ãã ã¨åˆ†ã‹ã‚Šã¾ã™ã€‚",
        "hints": ["å›³æ›¸é¤¨ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚", "æ„Ÿæƒ³ã‚’æ›¸ãã¾ã—ãŸã€‚"],
        "tts": {"text": "ã‚†ã†ãã¡ã‚ƒã‚“ã¯å›³æ›¸é¤¨ã§æœ¬ã‚’å€Ÿã‚Šã¾ã—ãŸâ€¦â€¦ã‚†ã†ãã¡ã‚ƒã‚“ã®ã‚ˆã†ã™ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Yuuki borrowed a book from the library, read it right away, and wrote her thoughts in a diary. Choose what this shows about her.",
        "choices": ["She likes books", "She likes sports", "She is sleepy", "She is hungry"],
        "answer": "She likes books",
        "explanation": "Borrowing, reading quickly, and writing notes show she likes books.",
        "hints": ["She went to the library.", "She wrote impressions."],
        "tts": {"text": "Yuuki borrowed a book, read it immediately, and wrote in her diary. Choose what it shows.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Yuuki a empruntÃ© un livre Ã  la bibliothÃ¨que, l'a lu tout de suite puis a Ã©crit ses impressions dans un journal. Choisissez ce que cela montre sur elle.",
        "choices": ["Elle aime les livres", "Elle aime le sport", "Elle est somnolente", "Elle a faim"],
        "answer": "Elle aime les livres",
        "explanation": "Lire immÃ©diatement et Ã©crire ses impressions montre qu'elle aime lire.",
        "hints": ["Elle utilise la bibliothÃ¨que.", "Elle Ã©crit ses impressions."],
        "tts": {"text": "Yuuki a empruntÃ© un livre et a Ã©crit ses impressions. Choisissez ce que cela montre.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "å„ªå¸Œå¾åœ–æ›¸é¤¨å€Ÿäº†ä¸€æœ¬æ›¸ï¼Œå›å®¶å¾Œé¦¬ä¸Šé–±è®€ï¼Œä¸¦åœ¨æ—¥è¨˜å¯«ä¸‹å¿ƒå¾—ã€‚è«‹é¸å‡ºé€™è¡¨ç¤ºå¥¹çš„å“ªç¨®æ¨£å­ã€‚",
        "choices": ["å–œæ­¡æ›¸", "å–œæ­¡é‹å‹•", "å¾ˆæƒ³ç¡", "è‚šå­é¤“"],
        "answer": "å–œæ­¡æ›¸",
        "explanation": "åˆ©ç”¨åœ–æ›¸é¤¨ä¸¦å¿«é€Ÿé–±è®€é‚„å¯«å¿ƒå¾—ï¼Œè¡¨ç¤ºå¥¹å–œæ­¡æ›¸ã€‚",
        "hints": ["å¥¹å»åœ–æ›¸é¤¨å€Ÿæ›¸ã€‚", "å¥¹å¯«ä¸‹æ„Ÿæƒ³ã€‚"],
        "tts": {"text": "å„ªå¸Œå€Ÿæ›¸ä¸¦é¦¬ä¸Šé–±è®€å¯«æ—¥è¨˜ã€‚è«‹é¸å‡ºé€™ä»£è¡¨ä»€éº¼ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 2,
    "subject": "kokugo",
    "suffix": "0010",
    "type": "grammar",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã“ã¨ã°ã‚’ãªã‚‰ã¹ã¦æ­£ã—ã„æ–‡ã«ã—ã¾ã—ã‚‡ã†: ã—ã¾ã—ãŸ / ã¹ã‚“ãã‚‡ã† / ãã‚‡ã† / ã‚ãŸã—ã¯",
        "choices": ["ã‚ãŸã—ã¯ ãã‚‡ã† ã¹ã‚“ãã‚‡ã† ã—ã¾ã—ãŸ", "ã¹ã‚“ãã‚‡ã† ã—ã¾ã—ãŸ ã‚ãŸã—ã¯ ãã‚‡ã†", "ãã‚‡ã† ã‚ãŸã—ã¯ ã—ã¾ã—ãŸ ã¹ã‚“ãã‚‡ã†", "ã—ã¾ã—ãŸ ã¹ã‚“ãã‚‡ã† ã‚ãŸã—ã¯ ãã‚‡ã†"],
        "answer": "ã‚ãŸã—ã¯ ãã‚‡ã† ã¹ã‚“ãã‚‡ã† ã—ã¾ã—ãŸ",
        "explanation": "ä¸»èªã®ã€Œã‚ãŸã—ã¯ã€ãŒæœ€åˆã«æ¥ã‚‹ã®ãŒè‡ªç„¶ã§ã™ã€‚",
        "hints": ["ã¾ãšä¸»èªã‚’è€ƒãˆã¾ã—ã‚‡ã†ã€‚", "ã€Œã¹ã‚“ãã‚‡ã†ã—ã¾ã—ãŸã€ã¯æ–‡ã®æœ€å¾Œã§ã™ã€‚"],
        "tts": {"text": "ã“ã¨ã°ã‚’ãªã‚‰ã¹ã¦æ­£ã—ã„æ–‡ã«ã—ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Reorder the words to make a correct sentence: studied / today / I / did",
        "choices": ["I studied today", "Studied I today", "Today I did studied", "Did studied today I"],
        "answer": "I studied today",
        "explanation": "English sentences begin with the subject 'I' followed by the verb.",
        "hints": ["Start with the subject.", "Place the time word after the verb."],
        "tts": {"text": "Reorder the words to make a correct sentence.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Remettez les mots dans l'ordre : aujourd'hui / j'ai / Ã©tudiÃ©",
        "choices": ["J'ai Ã©tudiÃ© aujourd'hui", "Ã‰tudiÃ© j'ai aujourd'hui", "Aujourd'hui j'ai Ã©tudiÃ©", "Ai Ã©tudiÃ© j'ai aujourd'hui"],
        "answer": "J'ai Ã©tudiÃ© aujourd'hui",
        "explanation": "La phrase correcte commence par le sujet puis le verbe.",
        "hints": ["Commencez par Â« j'ai Â».", "L'adverbe de temps vient Ã  la fin."],
        "tts": {"text": "Remettez les mots dans l'ordre pour former une phrase correcte.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹æŠŠè©èªæ’æˆæ­£ç¢ºå¥å­ï¼šä»Šå¤© / æˆ‘ / è®€æ›¸äº†",
        "choices": ["æˆ‘ ä»Šå¤© è®€æ›¸äº†", "è®€æ›¸äº† æˆ‘ ä»Šå¤©", "ä»Šå¤© æˆ‘ åšäº† è®€æ›¸", "åšäº† è®€æ›¸ ä»Šå¤© æˆ‘"],
        "answer": "æˆ‘ ä»Šå¤© è®€æ›¸äº†",
        "explanation": "ä¸­æ–‡å¥å­é€šå¸¸ä»¥ä¸»èªé–‹å§‹ï¼Œæ™‚é–“æ”¾åœ¨ä¸»èªä¹‹å¾Œã€‚",
        "hints": ["å…ˆæ”¾ä¸Šä¸»èªã€‚", "æ™‚é–“è©åœ¨ä¸»èªä¹‹å¾Œã€‚"],
        "tts": {"text": "è«‹æŠŠè©èªæ’æˆæ­£ç¢ºçš„å¥å­ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0001",
    "type": "reading",
    "difficulty": "easy",
    "translations": {
      "ja": {
        "prompt": "ã€Œæ—…ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ãŸã³", "ãŸã³ã‚‹", "ã‚Šã‚‡", "ãŸã³ã‚„"],
        "answer": "ãŸã³",
        "explanation": "ã€Œæ—…ã€ã¯ã€ŒãŸã³ã€ã¨èª­ã¿ã€æ—…è¡Œã®ã“ã¨ã§ã™ã€‚",
        "hints": ["å‡ºã‹ã‘ã‚‹ã“ã¨ã§ã™ã€‚", "æ—…è¡Œã¨ã‚‚è¨€ã„ã¾ã™ã€‚"],
        "tts": {"text": "ã€Œæ—…ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the reading for ã€Œæ—…ã€ã€‚",
        "choices": ["tabi", "tabiru", "ryo", "tobiya"],
        "answer": "tabi",
        "explanation": "ã€Œæ—…ã€ is read 'tabi', meaning trip or journey.",
        "hints": ["It means going on a trip.", "Another word is travel."],
        "tts": {"text": "Choose the reading for tabi.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez la lecture de ã€Œæ—…ã€ã€‚",
        "choices": ["tabi", "tabiru", "ryo", "tobiya"],
        "answer": "tabi",
        "explanation": "ã€Œæ—…ã€ se lit Â« tabi Â» et signifie voyage.",
        "hints": ["Cela signifie partir en voyage.", "On peut dire aussi voyage."],
        "tts": {"text": "Choisissez la lecture de tabi.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºã€Œæ—…ã€çš„è®€éŸ³ã€‚",
        "choices": ["ãŸã³", "ãŸã³ã‚‹", "ã‚Šã‚‡", "ãŸã³ã‚„"],
        "answer": "ãŸã³",
        "explanation": "ã€Œæ—…ã€è®€ä½œã€ŒãŸã³ã€ï¼Œæ„æ€æ˜¯æ—…è¡Œã€‚",
        "hints": ["è¡¨ç¤ºå‡ºå»æ—…è¡Œã€‚", "ä¹Ÿå¯ä»¥èªªæ—…éŠã€‚"],
        "tts": {"text": "è«‹é¸å‡ºæ—…çš„è®€éŸ³ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0002",
    "type": "kanji",
    "difficulty": "easy",
    "translations": {
      "ja": {
        "prompt": "ã€Œã‚†ã‚ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["å¤¢", "é›ª", "çµµ", "è‰"],
        "answer": "å¤¢",
        "explanation": "å¯ã¦ã„ã‚‹ã¨ãã«è¦‹ã‚‹ã€Œã‚†ã‚ã€ã¯ã€Œå¤¢ã€ã¨æ›¸ãã¾ã™ã€‚",
        "hints": ["ã­ã¦ã„ã‚‹ã¨ãã«è¦‹ã¾ã™ã€‚", "ã‹ãªãˆã‚‹ã¨å¬‰ã—ã„ã‚‚ã®ã€‚"],
        "tts": {"text": "ã€Œã‚†ã‚ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Write the kanji for 'yume' (dream).",
        "choices": ["å¤¢", "é›ª", "çµµ", "è‰"],
        "answer": "å¤¢",
        "explanation": "The word 'yume' meaning dream is written ã€Œå¤¢ã€ã€‚",
        "hints": ["You see it while sleeping.", "People want to achieve it."],
        "tts": {"text": "Write the kanji for yume meaning dream.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Ã‰crivez le kanji de Â« yume Â» (rÃªve).",
        "choices": ["å¤¢", "é›ª", "çµµ", "è‰"],
        "answer": "å¤¢",
        "explanation": "Le mot Â« yume Â» (rÃªve) s'Ã©crit ã€Œå¤¢ã€ã€‚",
        "hints": ["On le voit en dormant.", "On souhaite le rÃ©aliser."],
        "tts": {"text": "Ã‰crivez le kanji de yume signifiant rÃªve.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹æŠŠã€Œã‚†ã‚ã€å¯«æˆæ¼¢å­—ã€‚",
        "choices": ["å¤¢", "é›ª", "çµµ", "è‰"],
        "answer": "å¤¢",
        "explanation": "è¡¨ç¤ºå¤¢æƒ³çš„ã€Œã‚†ã‚ã€è¦å¯«æˆã€Œå¤¢ã€ã€‚",
        "hints": ["ç¡è¦ºæ™‚æœƒçœ‹åˆ°ã€‚", "é”æˆå¾Œæœƒé–‹å¿ƒã€‚"],
        "tts": {"text": "è«‹æŠŠã‚†ã‚å¯«æˆæ¼¢å­—ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0003",
    "type": "vocab",
    "difficulty": "normal",
    "translations": {
      "ja": {
        "prompt": "ã€Œå·¥å¤«ã€ã¨è¿‘ã„æ„å‘³ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã²ã‚‰ã‚ã", "ãªã¾ã‘", "ã‚€ã ", "ã—ã£ã±ã„"],
        "answer": "ã²ã‚‰ã‚ã",
        "explanation": "ã€Œå·¥å¤«ã€ã¯ã‚ˆã„è€ƒãˆã‚’å‡ºã™ã“ã¨ãªã®ã§ã€Œã²ã‚‰ã‚ãã€ãŒè¿‘ã„æ„å‘³ã§ã™ã€‚",
        "hints": ["é ­ã‚’ä½¿ã£ã¦è€ƒãˆã‚‹ã“ã¨ã€‚", "ã‚ˆã„ã‚¢ã‚¤ãƒ‡ã‚¢ã€‚"],
        "tts": {"text": "ã€Œå·¥å¤«ã€ã¨è¿‘ã„æ„å‘³ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the word closest in meaning to 'kufu' (ingenuity).",
        "choices": ["inspiration", "laziness", "waste", "mistake"],
        "answer": "inspiration",
        "explanation": "'Kufu' means coming up with a good idea, similar to inspiration.",
        "hints": ["Using your brain to solve something.", "Finding a clever idea."],
        "tts": {"text": "Choose the word closest to kufu meaning ingenuity.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez le mot proche de Â« kufu Â» (ingÃ©niositÃ©).",
        "choices": ["inspiration", "paresse", "gaspillage", "erreur"],
        "answer": "inspiration",
        "explanation": "Â« Kufu Â» signifie trouver une bonne idÃ©e, proche d'inspiration.",
        "hints": ["Utiliser sa tÃªte pour rÃ©soudre un problÃ¨me.", "Trouver une idÃ©e astucieuse."],
        "tts": {"text": "Choisissez le mot proche de kufu, ingÃ©niositÃ©.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºæœ€æ¥è¿‘ã€Œå·¥å¤«ã€æ„æ€çš„è©èªã€‚",
        "choices": ["éˆæ„Ÿ", "å·æ‡¶", "æµªè²»", "å¤±æ•—"],
        "answer": "éˆæ„Ÿ",
        "explanation": "ã€Œå·¥å¤«ã€æ˜¯æƒ³å‡ºå¥½é»å­çš„æ„æ€ï¼Œæœ€æ¥è¿‘ã€Œéˆæ„Ÿã€ã€‚",
        "hints": ["å‹•è…¦æƒ³è¾¦æ³•ã€‚", "æ‰¾åˆ°å·§å¦™çš„é»å­ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºæœ€æ¥è¿‘å·¥å¤«æ„æ€çš„è©èªã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0004",
    "type": "comprehension",
    "difficulty": "normal",
    "translations": {
      "ja": {
        "prompt": "ã‚ã‚„ã‹ã•ã‚“ã¯ç”ºã®æ­´å²ã‚’èª¿ã¹ã‚‹ãŸã‚ã€å›³æ›¸é¤¨ã§å¤ã„åœ°å›³ã‚’æ¢ã—ã¾ã—ãŸã€‚è¦‹ã¤ã‘ãŸåœ°å›³ã‚’ä½¿ã£ã¦ç™ºè¡¨ã®æº–å‚™ã‚’ã—ã¦ã„ã¾ã™ã€‚ã“ã®æ–‡ã‹ã‚‰åˆ†ã‹ã‚‹ã‚ã‚„ã‹ã•ã‚“ã®ã‚ˆã†ã™ã¨ã—ã¦æ­£ã—ã„ã‚‚ã®ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["èª¿ã¹å­¦ç¿’ã«ç†±å¿ƒ", "æœ¬ã‚’èª­ã‚“ã§çœ ããªã£ãŸ", "åœ°å›³ã‚’ãªãã—ãŸ", "ç™ºè¡¨ã‚’ã‚„ã‚ãŸ"],
        "answer": "èª¿ã¹å­¦ç¿’ã«ç†±å¿ƒ",
        "explanation": "åœ°å›³ã‚’æ¢ã—ç™ºè¡¨ã®æº–å‚™ã‚’ã—ã¦ã„ã‚‹ã®ã§ã€èª¿ã¹å­¦ç¿’ã«ç†±å¿ƒã§ã™ã€‚",
        "hints": ["å›³æ›¸é¤¨ã§ä½•ã‚’ã—ã¾ã—ãŸã‹ã€‚", "ç™ºè¡¨ã®æº–å‚™ã‚’ã—ã¦ã„ã¾ã™ã€‚"],
        "tts": {"text": "ã‚ã‚„ã‹ã•ã‚“ã¯ç”ºã®æ­´å²ã‚’èª¿ã¹ã‚‹ãŸã‚ã«å›³æ›¸é¤¨ã§å¤ã„åœ°å›³ã‚’æ¢ã—ã¾ã—ãŸâ€¦â€¦æ­£ã—ã„ã‚‚ã®ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Ayaka searched the library for an old map to study the town's history and is preparing a presentation with it. What does this tell you about Ayaka?",
        "choices": ["She studies enthusiastically", "She fell asleep reading", "She lost the map", "She gave up the presentation"],
        "answer": "She studies enthusiastically",
        "explanation": "Searching for maps and preparing a talk shows she is eager to research.",
        "hints": ["What did she do at the library?", "Is she preparing something?"],
        "tts": {"text": "Ayaka searched for an old map and is preparing a presentation. Choose the best description.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Ayaka a cherchÃ© une vieille carte Ã  la bibliothÃ¨que pour Ã©tudier l'histoire de la ville et prÃ©pare une prÃ©sentation avec. Que cela montre-t-il ?",
        "choices": ["Elle est studieuse", "Elle s'est endormie en lisant", "Elle a perdu la carte", "Elle a abandonnÃ© la prÃ©sentation"],
        "answer": "Elle est studieuse",
        "explanation": "Chercher une carte et prÃ©parer un exposÃ© montre son sÃ©rieux.",
        "hints": ["Que fait-elle Ã  la bibliothÃ¨que ?", "PrÃ©pare-t-elle quelque chose ?"],
        "tts": {"text": "Ayaka prÃ©pare un exposÃ© avec une vieille carte. Choisissez ce que cela montre d'elle.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "ç¶¾é¦™ç‚ºäº†ç ”ç©¶åŸé®æ­·å²ï¼Œåœ¨åœ–æ›¸é¤¨å°‹æ‰¾èˆŠåœ°åœ–ï¼Œä¸¦ç”¨é€™å¼µåœ°åœ–æº–å‚™ç™¼è¡¨ã€‚é€™è¡¨ç¤ºç¶¾é¦™æ˜¯æ€æ¨£çš„äººï¼Ÿ",
        "choices": ["èªçœŸç ”ç©¶", "è®€æ›¸è®€åˆ°æƒ³ç¡", "å¼„ä¸Ÿåœ°åœ–", "æ”¾æ£„ç™¼è¡¨"],
        "answer": "èªçœŸç ”ç©¶",
        "explanation": "å¥¹ç©æ¥µæ‰¾è³‡æ–™ä¸¦æº–å‚™ç™¼è¡¨ï¼Œè¡¨ç¤ºå¥¹å¾ˆèªçœŸç ”ç©¶ã€‚",
        "hints": ["å¥¹åœ¨åœ–æ›¸é¤¨åšäº†ä»€éº¼ï¼Ÿ", "å¥¹æ˜¯å¦åœ¨æº–å‚™ç™¼è¡¨ï¼Ÿ"],
        "tts": {"text": "ç¶¾é¦™ç‚ºç ”ç©¶åŸé®æ­·å²æº–å‚™ç™¼è¡¨ã€‚è«‹é¸å‡ºæ­£ç¢ºæè¿°ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0005",
    "type": "grammar",
    "difficulty": "normal",
    "translations": {
      "ja": {
        "prompt": "ã€Œé›¨ãŒãµã£ã¦ã„ã¾ã™ ___ ä»Šæ—¥ã¯å¤–ã§éŠã³ã¾ã›ã‚“ã€‚ã€ã«å…¥ã‚‹è¨€è‘‰ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã®ã§", "ã‘ã‚Œã©", "ãã—ã¦", "ãã‚Œã§ã‚‚"],
        "answer": "ã®ã§",
        "explanation": "ç†ç”±ã‚’è¡¨ã™ã«ã¯ã€Œã®ã§ã€ã‚’ä½¿ã„ã¾ã™ã€‚",
        "hints": ["ç†ç”±ã‚’ç¤ºã™æ¥ç¶šèªã§ã™ã€‚", "å‰ã®æ–‡ãŒç†ç”±ã§ã™ã€‚"],
        "tts": {"text": "ã€Œé›¨ãŒãµã£ã¦ã„ã¾ã™ ___ ä»Šæ—¥ã¯å¤–ã§éŠã³ã¾ã›ã‚“ã€‚ã€ã«å…¥ã‚‹è¨€è‘‰ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the word that fits: 'It is raining ___ we will not play outside today.'",
        "choices": ["because", "but", "and then", "even so"],
        "answer": "because",
        "explanation": "We need a connector that gives a reason, like 'because'.",
        "hints": ["The second sentence is the result.", "Look for a reason connector."],
        "tts": {"text": "Choose the word for It is raining blank we will not play outside today.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez le mot qui convient : Â« Il pleut ___ aujourd'hui nous ne jouerons pas dehors. Â»",
        "choices": ["parce que", "mais", "et puis", "mÃªme ainsi"],
        "answer": "parce que",
        "explanation": "On cherche un mot qui exprime la raison : Â« parce que Â».",
        "hints": ["La deuxiÃ¨me phrase est la consÃ©quence.", "Cherchez un lien de cause."],
        "tts": {"text": "Choisissez le mot qui exprime la cause pour la phrase Il pleut...", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºé©åˆçš„è©ï¼šã€Œå› ç‚ºä¸‹é›¨äº† ___ ä»Šå¤©ä¸åœ¨å¤–é¢ç©ã€‚ã€",
        "choices": ["æ‰€ä»¥", "ä½†æ˜¯", "ç„¶å¾Œ", "å³ä½¿å¦‚æ­¤"],
        "answer": "æ‰€ä»¥",
        "explanation": "è¦è¡¨é”åŸå› å’Œçµæœï¼Œéœ€è¦ç”¨ã€Œæ‰€ä»¥ã€ã€‚",
        "hints": ["å¾ŒåŠå¥æ˜¯çµæœã€‚", "æ‰¾è¡¨ç¤ºåŸå› é€£æ¥è©ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºé©åˆå› ç‚ºä¸‹é›¨äº† blank ä»Šå¤©ä¸åœ¨å¤–é¢ç©çš„è©ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0006",
    "type": "reading",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã€Œç·‘é“ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã‚Šã‚‡ãã©ã†", "ã¿ã©ã‚Šã¿ã¡", "ã‚ãã©ã†", "ã¨ãã©ã†"],
        "answer": "ã‚Šã‚‡ãã©ã†",
        "explanation": "ã€Œç·‘é“ã€ã¯ã€Œã‚Šã‚‡ãã©ã†ã€ã¨èª­ã¿ã€æœ¨ã€…ãŒãªã‚‰ã¶é“ã®ã“ã¨ã§ã™ã€‚",
        "hints": ["ç·‘ã¯ã¿ã©ã‚Šã¨èª­ã¿ã¾ã™ã€‚", "é“ã¯ã€Œã©ã†ã€ã€‚"],
        "tts": {"text": "ã€Œç·‘é“ã€ã®ã‚ˆã¿ã‹ãŸã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the reading for ã€Œç·‘é“ã€ã€‚",
        "choices": ["ryokudou", "midorimichi", "rokudou", "tokudou"],
        "answer": "ryokudou",
        "explanation": "ã€Œç·‘é“ã€ is read 'ryokudou', meaning a green walkway lined with trees.",
        "hints": ["Green is 'ryoku' here.", "The second kanji reads 'dou'."],
        "tts": {"text": "Choose the reading for ryokudou.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez la lecture de ã€Œç·‘é“ã€ã€‚",
        "choices": ["ryokudou", "midorimichi", "rokudou", "tokudou"],
        "answer": "ryokudou",
        "explanation": "ã€Œç·‘é“ã€ se lit Â« ryokudou Â», une promenade bordÃ©e d'arbres.",
        "hints": ["Le kanji de vert se lit Â« ryoku Â».", "Le second kanji se lit Â« dou Â»."],
        "tts": {"text": "Choisissez la lecture de ryokudou.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºã€Œç·‘é“ã€çš„è®€éŸ³ã€‚",
        "choices": ["ã‚Šã‚‡ãã©ã†", "ã¿ã©ã‚Šã¿ã¡", "ã‚ãã©ã†", "ã¨ãã©ã†"],
        "answer": "ã‚Šã‚‡ãã©ã†",
        "explanation": "ã€Œç·‘é“ã€è®€ä½œã€Œã‚Šã‚‡ãã©ã†ã€ï¼Œæ„æ€æ˜¯ç¶ è”­æ­¥é“ã€‚",
        "hints": ["ã€Œç·‘ã€åœ¨é€™è£¡è®€ä½œã‚Šã‚‡ãã€‚", "ã€Œé“ã€è®€ä½œã©ã†ã€‚"],
        "tts": {"text": "è«‹é¸å‡ºç·‘é“çš„è®€éŸ³ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0007",
    "type": "kanji",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã€Œã¾ã‚‚ã‚‹ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["å®ˆã‚‹", "é›†ã‚‹", "å›ºã‚‹", "å¤‰ã‚‹"],
        "answer": "å®ˆã‚‹",
        "explanation": "ç´„æŸã‚’å®ˆã‚‹ãªã©ã®ã€Œã¾ã‚‚ã‚‹ã€ã¯ã€Œå®ˆã‚‹ã€ã¨æ›¸ãã¾ã™ã€‚",
        "hints": ["ç´„æŸã™ã‚‹ã¨ãã«ä½¿ã„ã¾ã™ã€‚", "ãŠã¾ã‚‚ã‚Šã®ã€Œã¾ã‚‚ã€ã€‚"],
        "tts": {"text": "ã€Œã¾ã‚‚ã‚‹ã€ã‚’æ¼¢å­—ã«ã—ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Write the kanji for 'mamoru' (to protect).",
        "choices": ["å®ˆã‚‹", "é›†ã‚‹", "å›ºã‚‹", "å¤‰ã‚‹"],
        "answer": "å®ˆã‚‹",
        "explanation": "The verb 'mamoru' meaning to protect is written ã€Œå®ˆã‚‹ã€ã€‚",
        "hints": ["Use it with promises.", "Think of a protective charm."],
        "tts": {"text": "Write the kanji for mamoru meaning to protect.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Ã‰crivez le kanji de Â« mamoru Â» (protÃ©ger).",
        "choices": ["å®ˆã‚‹", "é›†ã‚‹", "å›ºã‚‹", "å¤‰ã‚‹"],
        "answer": "å®ˆã‚‹",
        "explanation": "Le verbe Â« mamoru Â» (protÃ©ger) s'Ã©crit ã€Œå®ˆã‚‹ã€ã€‚",
        "hints": ["On l'emploie pour tenir une promesse.", "Pensez Ã  une amulette protectrice."],
        "tts": {"text": "Ã‰crivez le kanji de mamoru, protÃ©ger.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹æŠŠã€Œã¾ã‚‚ã‚‹ã€å¯«æˆæ¼¢å­—ã€‚",
        "choices": ["å®ˆã‚‹", "é›†ã‚‹", "å›ºã‚‹", "å¤‰ã‚‹"],
        "answer": "å®ˆã‚‹",
        "explanation": "è¡¨ç¤ºä¿è­·çš„ã€Œã¾ã‚‚ã‚‹ã€è¦å¯«ä½œã€Œå®ˆã‚‹ã€ã€‚",
        "hints": ["å¸¸ç”¨åœ¨éµå®ˆç´„å®šæ™‚ã€‚", "è¯æƒ³åˆ°è­·èº«ç¬¦ã€‚"],
        "tts": {"text": "è«‹æŠŠã¾ã‚‚ã‚‹å¯«æˆæ¼¢å­—ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0008",
    "type": "comprehension",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "å°‘å¹´ã¯è‡ªåˆ†ã§èª¿ã¹ãŸã“ã¨ã‚’ã‚¯ãƒ©ã‚¹ã§ç™ºè¡¨ã—ã¾ã—ãŸã€‚ã¿ã‚“ãªãŒé™ã‹ã«è€³ã‚’å‚¾ã‘ã¦ãã‚ŒãŸã®ã§ã€å°‘å¹´ã¯èƒ¸ãŒã‚ãŸãŸã‹ããªã‚Šã¾ã—ãŸã€‚ã“ã®æ–‡ã‹ã‚‰åˆ†ã‹ã‚‹å°‘å¹´ã®æ°—æŒã¡ã¨ã—ã¦æ­£ã—ã„ã‚‚ã®ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ã†ã‚Œã—ã„", "ã‹ãªã—ã„", "ãŠã“ã£ã¦ã„ã‚‹", "ã“ã‚ãŒã£ã¦ã„ã‚‹"],
        "answer": "ã†ã‚Œã—ã„",
        "explanation": "èã„ã¦ã‚‚ã‚‰ãˆã¦èƒ¸ãŒã‚ãŸãŸã‹ããªã£ãŸã®ã§ã€ã†ã‚Œã—ã„æ°—æŒã¡ã§ã™ã€‚",
        "hints": ["èƒ¸ãŒã‚ãŸãŸã‹ããªã‚‹ã®ã¯ã©ã‚“ãªæ°—æŒã¡ï¼Ÿ", "ç™ºè¡¨ã¯ã†ã¾ãã„ãã¾ã—ãŸã‹ï¼Ÿ"],
        "tts": {"text": "å°‘å¹´ã¯è‡ªåˆ†ã§èª¿ã¹ãŸã“ã¨ã‚’ã‚¯ãƒ©ã‚¹ã§ç™ºè¡¨ã—ã¾ã—ãŸâ€¦â€¦æ°—æŒã¡ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "A boy presented his research to the class. Everyone listened quietly, so his chest felt warm. What emotion does he feel?",
        "choices": ["happy", "sad", "angry", "afraid"],
        "answer": "happy",
        "explanation": "Feeling warm inside after a good presentation shows happiness.",
        "hints": ["A warm chest means a positive feeling.", "The presentation went well."],
        "tts": {"text": "A boy presented and everyone listened. Choose how he feels.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Un garÃ§on a prÃ©sentÃ© ses recherches en classe. Tout le monde l'a Ã©coutÃ© attentivement, et il a senti son cÅ“ur devenir chaud. Quelle Ã©motion ressent-il ?",
        "choices": ["heureux", "triste", "en colÃ¨re", "effrayÃ©"],
        "answer": "heureux",
        "explanation": "Un cÅ“ur chaud aprÃ¨s une prÃ©sentation rÃ©ussie indique la joie.",
        "hints": ["Un cÅ“ur chaud est un sentiment positif.", "L'exposÃ© s'est bien passÃ©."],
        "tts": {"text": "Un garÃ§on a prÃ©sentÃ© son travail et tout le monde a Ã©coutÃ©. Choisissez son Ã©motion.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "å°‘å¹´å‘å…¨ç­ç™¼è¡¨è‡ªå·±ç ”ç©¶çš„å…§å®¹ã€‚å¤§å®¶å®‰éœåœ°å‚¾è½ï¼Œä»–è¦ºå¾—å¿ƒè£¡æš–æš–çš„ã€‚è«‹é¸å‡ºä»–çš„æ„Ÿå—ã€‚",
        "choices": ["é–‹å¿ƒ", "é›£é", "ç”Ÿæ°£", "å®³æ€•"],
        "answer": "é–‹å¿ƒ",
        "explanation": "ç™¼è¡¨æˆåŠŸåˆè¢«å‚¾è½ï¼Œå¿ƒè£¡è¦ºå¾—æº«æš–ï¼Œå°±æ˜¯é–‹å¿ƒã€‚",
        "hints": ["å¿ƒè£¡æš–æš–é€šå¸¸ä»£è¡¨ä»€éº¼æƒ…ç·’ï¼Ÿ", "ç™¼è¡¨æ˜¯å¦é †åˆ©ï¼Ÿ"],
        "tts": {"text": "å°‘å¹´ç™¼è¡¨å¾Œå¿ƒè£¡æš–æš–çš„ã€‚è«‹é¸å‡ºä»–çš„æ„Ÿå—ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0009",
    "type": "vocab",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã€Œè±Šã‹ã€ã®åå¯¾ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚",
        "choices": ["ä¹ã—ã„", "æ¥½ã—ã„", "åºƒã„", "æ·±ã„"],
        "answer": "ä¹ã—ã„",
        "explanation": "ã€Œè±Šã‹ã€ã®åå¯¾èªã¯ã€Œä¹ã—ã„ã€ã§ã™ã€‚",
        "hints": ["ç‰©ã‚„å¿ƒãŒå°‘ãªã„ã‚ˆã†ã™ã€‚", "ã‚†ãŸã‹ã®é€†ã‚’è€ƒãˆã¾ã—ã‚‡ã†ã€‚"],
        "tts": {"text": "ã€Œè±Šã‹ã€ã®åå¯¾ã®ã“ã¨ã°ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Choose the antonym of 'abundant'.",
        "choices": ["scarce", "fun", "wide", "deep"],
        "answer": "scarce",
        "explanation": "The opposite of abundant is scarce.",
        "hints": ["Think about having very little.", "The reverse of plenty."],
        "tts": {"text": "Choose the antonym of abundant.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Choisissez le contraire de Â« abondant Â».",
        "choices": ["rare", "amusant", "large", "profond"],
        "answer": "rare",
        "explanation": "Le contraire d'abondant est rare.",
        "hints": ["Imaginez qu'il y en a trÃ¨s peu.", "C'est l'inverse du plein."],
        "tts": {"text": "Choisissez le contraire d'abondant.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹é¸å‡ºã€Œè±Šã‹ã€çš„åç¾©è©ã€‚",
        "choices": ["ä¹ã—ã„", "æ¥½ã—ã„", "åºƒã„", "æ·±ã„"],
        "answer": "ä¹ã—ã„",
        "explanation": "ã€Œè±Šã‹ã€çš„åç¾©è©æ˜¯ã€Œä¹ã—ã„ã€ã€‚",
        "hints": ["è¡¨ç¤ºæ±è¥¿å¾ˆå°‘ã€‚", "æƒ³ä¸€æƒ³èˆ‡å¯Œè¶³ç›¸åã€‚"],
        "tts": {"text": "è«‹é¸å‡ºè±Šã‹çš„åç¾©è©ã€‚", "lang": "zh-CN"}
      }
    }
  },
  {
    "grade": 3,
    "subject": "kokugo",
    "suffix": "0010",
    "type": "grammar",
    "difficulty": "hard",
    "translations": {
      "ja": {
        "prompt": "ã“ã¨ã°ã‚’ãªã‚‰ã¹ã¦æ­£ã—ã„æ–‡ã«ã—ã¾ã—ã‚‡ã†: èª¿ã¹ã¾ã—ãŸ / è‡ªç„¶ã«ã¤ã„ã¦ / ã‚ãŸã—ãŸã¡ã¯ / æ–°èã§",
        "choices": ["ã‚ãŸã—ãŸã¡ã¯ æ–°èã§ è‡ªç„¶ã«ã¤ã„ã¦ èª¿ã¹ã¾ã—ãŸ", "è‡ªç„¶ã«ã¤ã„ã¦ ã‚ãŸã—ãŸã¡ã¯ æ–°èã§ èª¿ã¹ã¾ã—ãŸ", "æ–°èã§ èª¿ã¹ã¾ã—ãŸ ã‚ãŸã—ãŸã¡ã¯ è‡ªç„¶ã«ã¤ã„ã¦", "èª¿ã¹ã¾ã—ãŸ ã‚ãŸã—ãŸã¡ã¯ æ–°èã§ è‡ªç„¶ã«ã¤ã„ã¦"],
        "answer": "ã‚ãŸã—ãŸã¡ã¯ æ–°èã§ è‡ªç„¶ã«ã¤ã„ã¦ èª¿ã¹ã¾ã—ãŸ",
        "explanation": "ä¸»èªã€Œã‚ãŸã—ãŸã¡ã¯ã€ã‹ã‚‰å§‹ã‚ã€å ´æ‰€ã®ã€Œæ–°èã§ã€ã€å†…å®¹ã®ã€Œè‡ªç„¶ã«ã¤ã„ã¦ã€ã€æœ€å¾Œã«å‹•è©ãŒç¶šãã¾ã™ã€‚",
        "hints": ["ä¸»èªã‚’æœ€åˆã«ç½®ãã¾ã—ã‚‡ã†ã€‚", "å‹•è©ã¯æ–‡ã®æœ€å¾Œã§ã™ã€‚"],
        "tts": {"text": "ã“ã¨ã°ã‚’ãªã‚‰ã¹ã¦æ­£ã—ã„æ–‡ã«ã—ã¾ã—ã‚‡ã†ã€‚", "lang": "ja-JP"}
      },
      "en": {
        "prompt": "Reorder the words: researched / about nature / we / in the newspaper",
        "choices": ["We researched about nature in the newspaper", "About nature we researched in the newspaper", "In the newspaper researched we about nature", "Researched we in the newspaper about nature"],
        "answer": "We researched about nature in the newspaper",
        "explanation": "Begin with the subject 'We', then the verb, then details.",
        "hints": ["Start with the subject.", "Keep the verb close to the subject."],
        "tts": {"text": "Reorder the words to make a correct sentence about researching nature.", "lang": "en-US"}
      },
      "fr": {
        "prompt": "Remettez les mots dans l'ordre : nous / avons recherchÃ© / sur la nature / dans le journal",
        "choices": ["Nous avons recherchÃ© sur la nature dans le journal", "Sur la nature nous avons recherchÃ© dans le journal", "Dans le journal nous avons recherchÃ© sur la nature", "Avons recherchÃ© nous sur la nature dans le journal"],
        "answer": "Nous avons recherchÃ© sur la nature dans le journal",
        "explanation": "La phrase correcte commence par Â« nous avons recherchÃ© Â».",
        "hints": ["Commencez par le sujet.", "Le verbe suit immÃ©diatement."],
        "tts": {"text": "Remettez les mots pour former une phrase correcte sur la recherche dans le journal.", "lang": "fr-FR"}
      },
      "zh": {
        "prompt": "è«‹æ’æˆæ­£ç¢ºå¥å­ï¼šæˆ‘å€‘ / åœ¨å ±ç´™ä¸Š / èª¿æŸ¥äº† / é—œæ–¼è‡ªç„¶",
        "choices": ["æˆ‘å€‘ åœ¨å ±ç´™ä¸Š èª¿æŸ¥äº† é—œæ–¼è‡ªç„¶", "é—œæ–¼è‡ªç„¶ æˆ‘å€‘ åœ¨å ±ç´™ä¸Š èª¿æŸ¥äº†", "åœ¨å ±ç´™ä¸Š èª¿æŸ¥äº† æˆ‘å€‘ é—œæ–¼è‡ªç„¶", "èª¿æŸ¥äº† æˆ‘å€‘ åœ¨å ±ç´™ä¸Š é—œæ–¼è‡ªç„¶"],
        "answer": "æˆ‘å€‘ åœ¨å ±ç´™ä¸Š èª¿æŸ¥äº† é—œæ–¼è‡ªç„¶",
        "explanation": "ä¸­æ–‡å¥å­ä»¥ä¸»èªé–‹é ­ï¼Œæ¥è‘—æ˜¯åœ°é»å’Œå‹•ä½œã€‚",
        "hints": ["å…ˆæŠŠä¸»èªæ”¾å‰é¢ã€‚", "å‹•ä½œæ”¾åœ¨æ™‚é–“æˆ–åœ°é»ä¹‹å¾Œã€‚"],
        "tts": {"text": "è«‹æŠŠè©èªæ’æˆæ­£ç¢ºæè¿°ç ”ç©¶è‡ªç„¶çš„å¥å­ã€‚", "lang": "zh-CN"}
      }
    }
  }

];

const questionManager = new QuestionManager(KOKUGO_QUESTION_BANK);

const SUPPORTED_LANGUAGES = ['ja', 'en', 'fr', 'zh'];

const KOKUGO_TYPES = ['reading', 'kanji', 'vocab', 'comprehension', 'grammar'];

const createEmptyLanguageStats = () => {
    const baseline = {};
    SUPPORTED_LANGUAGES.forEach(lang => {
        baseline[lang] = {
            answered: 0,
            correct: 0,
            comprehensionAnswered: 0,
            comprehensionCorrect: 0,
            streak: 0
        };
    });
    return baseline;
};

const LANGUAGE_LABELS = { ja: 'æ—¥æœ¬èª', en: 'English', fr: 'FranÃ§ais', zh: 'ä¸­æ–‡' };

const createDefaultPlayerStats = () => ({
    totalMonstersDefeated: 0,
    totalQuestionsAnswered: 0,
    correctAnswers: 0,
    unlockedMonsters: [],
    badges: [],
    points: 0,
    experience: 0,
    level: 1,
    nextLevelExp: 120,
    languageStats: {
        kokugo: createEmptyLanguageStats(),
        math: createEmptyLanguageStats()
    },
    achievements: {
        langNovice: false,
        readingChamp: false,
        bugCatcher: false,
        carryMaster: false,
        coinArtist: false,
        clockGuardian: false,
        timesTableHero: false,
        unitWizard: false,
        storyScholar: false,
        coopHero: false,
        versusChampion: false,
        arExplorer: false
    },
    capturedInsects: [],
    storyBeatsUnlocked: [],
    shopUnlocks: [],
    weeklyProgress: [],
    cooperativeRecords: [],
    versusRecords: [],
    miniGameRecords: {},
    skillMastery: {},
    modeHistory: [],
    inventory: {},
    heroLoadout: {
        outfit: 'starter_robe',
        head: 'starter_band',
        weapon: 'chalk_wand',
        companion: null,
        aura: 'none_aura',
        accessory: 'none_accessory'
    },
    questProgress: {},
    tutorProfile: 'adaptiveCoach',
    arMissionsCompleted: [],
    companionRoster: [],
    seasonalProgress: { spring: 0, summer: 0, autumn: 0, winter: 0 }
});

const normalizePlayerStats = (raw) => {
    const defaults = createDefaultPlayerStats();
    if (!raw || typeof raw !== 'object') {
        return defaults;
    }

    const normalizeLang = (source) => {
        const base = createEmptyLanguageStats();
        Object.keys(base).forEach(lang => {
            const info = source && source[lang] ? source[lang] : {};
            base[lang] = {
                answered: Number(info.answered) || 0,
                correct: Number(info.correct) || 0,
                comprehensionAnswered: Number(info.comprehensionAnswered) || 0,
                comprehensionCorrect: Number(info.comprehensionCorrect) || 0,
                streak: Number(info.streak) || 0
            };
        });
        return base;
    };

    const safeNumber = (value, fallback) => (typeof value === 'number' && Number.isFinite(value) ? value : fallback);

    const normalized = {
        ...defaults,
        ...raw,
        totalMonstersDefeated: safeNumber(raw.totalMonstersDefeated, defaults.totalMonstersDefeated),
        totalQuestionsAnswered: safeNumber(raw.totalQuestionsAnswered, defaults.totalQuestionsAnswered),
        correctAnswers: safeNumber(raw.correctAnswers, defaults.correctAnswers),
        points: safeNumber(raw.points, defaults.points),
        experience: safeNumber(raw.experience, defaults.experience),
        level: safeNumber(raw.level, defaults.level) || defaults.level,
        nextLevelExp: safeNumber(raw.nextLevelExp, defaults.nextLevelExp) || defaults.nextLevelExp,
        unlockedMonsters: Array.isArray(raw.unlockedMonsters) ? Array.from(new Set(raw.unlockedMonsters)) : defaults.unlockedMonsters.slice(),
        badges: Array.isArray(raw.badges) ? Array.from(new Set(raw.badges)) : defaults.badges.slice(),
        capturedInsects: Array.isArray(raw.capturedInsects) ? raw.capturedInsects.slice() : defaults.capturedInsects.slice(),
        storyBeatsUnlocked: Array.isArray(raw.storyBeatsUnlocked) ? Array.from(new Set(raw.storyBeatsUnlocked)) : defaults.storyBeatsUnlocked.slice(),
        shopUnlocks: Array.isArray(raw.shopUnlocks) ? Array.from(new Set(raw.shopUnlocks)) : defaults.shopUnlocks.slice(),
        weeklyProgress: Array.isArray(raw.weeklyProgress) ? raw.weeklyProgress.slice(-12) : defaults.weeklyProgress.slice(),
        cooperativeRecords: Array.isArray(raw.cooperativeRecords) ? raw.cooperativeRecords.slice(-40) : defaults.cooperativeRecords.slice(),
        versusRecords: Array.isArray(raw.versusRecords) ? raw.versusRecords.slice(-40) : defaults.versusRecords.slice(),
        miniGameRecords: { ...defaults.miniGameRecords, ...(raw.miniGameRecords || {}) },
        skillMastery: { ...defaults.skillMastery, ...(raw.skillMastery || {}) },
        modeHistory: Array.isArray(raw.modeHistory) ? raw.modeHistory.slice(-150) : defaults.modeHistory.slice(),
        inventory: { ...defaults.inventory, ...(raw.inventory || {}) },
        heroLoadout: { ...defaults.heroLoadout, ...(raw.heroLoadout || {}) },
        questProgress: { ...defaults.questProgress, ...(raw.questProgress || {}) },
        arMissionsCompleted: Array.isArray(raw.arMissionsCompleted) ? Array.from(new Set(raw.arMissionsCompleted)) : defaults.arMissionsCompleted.slice(),
        companionRoster: Array.isArray(raw.companionRoster) ? Array.from(new Set(raw.companionRoster)) : defaults.companionRoster.slice(),
        seasonalProgress: { ...defaults.seasonalProgress, ...(raw.seasonalProgress || {}) },
        languageStats: {
            kokugo: normalizeLang(raw.languageStats && raw.languageStats.kokugo),
            math: normalizeLang(raw.languageStats && raw.languageStats.math)
        },
        achievements: {
            ...defaults.achievements,
            ...(raw.achievements || {})
        }
    };

    if (!normalized.tutorProfile) {
        normalized.tutorProfile = defaults.tutorProfile;
    }

    return normalized;
};
const MathMazeGame = () => {
    // Language settings
    // Translations (all languages)
    const shopItemIndex = useMemo(() => new Map((shopInventory || []).filter(item => item && item.id).map(item => [item.id, item])), [shopInventory]);
    const companionIndex = useMemo(() => new Map((companionCatalog || []).filter(comp => comp && comp.id).map(comp => [comp.id, comp])), [companionCatalog]);

    const translations = useMemo(() => ({
        ja: {
            gameTitle: 'ã•ã‚“ã™ã†ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³',
            startGame: 'ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼',
            stats: 'ã›ã„ã›ã',
            dictionary: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãšã‹ã‚“',
            selectGrade: 'ãŒãã­ã‚“ã‚’ ãˆã‚‰ã¼ã†ï¼',
            grade2Mode: '2å¹´ç”Ÿãƒ¢ãƒ¼ãƒ‰',
            grade3Mode: '3å¹´ç”Ÿãƒ¢ãƒ¼ãƒ‰',
            studyContent: 'ã¹ã‚“ãã‚‡ã†ã™ã‚‹å†…å®¹ï¼š',
            modeSelectTitle: 'ãƒ¢ãƒ¼ãƒ‰ã‚’ãˆã‚‰ã¼ã†',
            focusSkillsTitle: 'ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã‚‹ã‚¹ã‚­ãƒ«',
            worldsTitle: 'å†’é™ºã§ãã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰',
            modeDungeon: 'ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³å†’é™º',
            modeDungeonDescription: 'è¿·è·¯ã‚’æ¢æ¤œã—ã¦ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨è¨ˆç®—ãƒãƒˆãƒ«ï¼',
            modeMiniGames: 'ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚²ãƒ¼ãƒ ',
            modeMiniGamesDescription: 'å¾—æ„ã‚¹ã‚­ãƒ«ã‚’ãƒŸãƒ‹ã‚²ãƒ¼ãƒ ã§é›ãˆã‚ˆã†ã€‚',
            modeStory: 'ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ',
            modeStoryDescription: 'ç‰©èªã‚’èª­ã¿é€²ã‚ã¦å›³é‘‘ã‚’å……å®Ÿã•ã›ã‚ˆã†ã€‚',
            modeCoop: 'å”åŠ›ãƒŸãƒƒã‚·ãƒ§ãƒ³',
            modeCoopDescription: 'å‹ã ã¡ã¨ãƒ’ãƒ³ãƒˆã‚’å‡ºã—åˆã£ã¦ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã€‚',
            modeVersus: 'ãŸã„ã›ã‚“ãƒ¢ãƒ¼ãƒ‰',
            modeVersusDescription: 'åŒã˜å•é¡Œã§ã‚¹ãƒ”ãƒ¼ãƒ‰ã¨æ­£ç¢ºã•ã‚’ç«¶ãŠã†ã€‚',
            modeParent: 'ä¿è­·è€…ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰',
            modeParentDescription: 'å­¦ç¿’çŠ¶æ³ã‚„ãƒãƒƒã‚¸ã‚’ç¢ºèªã§ãã¾ã™ã€‚',
              modeQuests: 'Quest Board',
              modeQuestsDescription: 'Follow story missions and seasonal challenges.',
              questTrack: 'Track',
              questComplete: 'Quest complete!',
              questCompleteAction: 'Mark complete',
              questCompleted: 'Completed',
              completed: 'Completed',
              questAlreadyCleared: 'Quest already completed.',
              questTracked: 'Quest pinned!',
              inProgress: 'In progress',
              rewardMilestone: 'Milestone',
              rewardLabel: 'Reward',
              modeHistory: 'Recent activity',
              modeCustomize: 'Avatar Studio',
              modeCustomizeDescription: 'Change outfits, companions, and auras.',
              modeShop: 'Item Shop',
              modeShopDescription: 'Spend points on cosmetics and boosts.',
              modeAR: 'AR Fieldwork',
              modeARDescription: 'Take real-world math missions around town.',
              modeARArea: 'Area',
              modeARSkill: 'Skill',
              modeARStart: 'Start mission',
              replay: 'Replay',
              slotOutfit: 'Outfit',
              slotHead: 'Headwear',
              slotWeapon: 'Tool',
              slotAura: 'Aura',
              slotAccessory: 'Accessory',
              slotCompanion: 'Companion',
              baseOutfit: 'Adventurer Robe',
              baseOutfitDescription: 'Balanced for any adventure.',
              baseHead: 'Explorer Band',
              baseHeadDescription: 'Keeps focus steady.',
              baseWeapon: 'Chalk Wand',
              baseWeaponDescription: 'Sketch strategies mid-battle.',
              baseAura: 'No Aura',
              baseAuraDescription: 'Pure focus with no glow.',
              baseAccessory: 'Travel Light',
              baseAccessoryDescription: 'Nothing extra, just courage.',
              companionNone: 'No companion',
              companionNoneDescription: 'Adventure solo.',
              avatarPreview: 'Current look',
              equip: 'Equip',
              equipped: 'Equipped',
              notPurchased: 'Buy in shop',
              purchase: 'Purchase',
              purchaseComplete: 'Purchase complete!',
              alreadyOwned: 'Already owned.',
              notEnoughPoints: 'Not enough points.',
              noRequirement: 'No requirement',
              requiresBadge: 'Requires badge',
              locked: 'Locked',
            storyBegin: 'ç‰©èªã‚’ã²ã‚‰ã',
            viewStory: 'ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚’è¦‹ã‚‹',
            answer: 'ã“ãŸãˆ',
            miniGameTitle: 'ã‚¹ã‚­ãƒ«ç‰¹è¨“ã‚²ãƒ¼ãƒ ',
            miniGameStart: 'ã‚¹ã‚¿ãƒ¼ãƒˆ',
            miniGameSkill: 'å¯¾å¿œã‚¹ã‚­ãƒ«',
            progress: 'é€²è¡Œ',
            completeStory: 'ã‚¯ãƒªã‚¢ã¨ã—ã¦è¨˜éŒ²',
            storyLocked: 'æ–°ã—ã„ç« ãŒè§£æ”¾ã•ã‚Œã¾ã—ãŸï¼',
            launchCoop: 'ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆ',
            launchVersus: 'ãŸã„ã›ã‚“é–‹å§‹',
            parentDashboard: 'ä¿è­·è€…ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰',
            miniGameStat: 'ãƒŸãƒ‹ã‚²ãƒ¼ãƒ ã®è¨˜éŒ²',
            weeklyProgress: 'é€±é–“ã®ãŒã‚“ã°ã‚Š',
            backToModes: 'ãƒ¢ãƒ¼ãƒ‰é¸æŠã«ã‚‚ã©ã‚‹',

            addition: 'ãŸã—ç®—',
            subtraction: 'ã²ãç®—',
            comparison: 'æ•°ã®å¤§å°ãã‚‰ã¹',
            additionCarryHint: 'ãã‚Šä¸ŠãŒã‚Šã‚’æ„è­˜ã—ã¦ä¸€æ¡ãšã¤è¨ˆç®—ã—ã‚ˆã†ã€‚',
            subtractionBorrowHint: 'ä¸Šã®ä½ã‹ã‚‰å€Ÿã‚Šã¦ã€é †ç•ªã«è¨ˆç®—ã—ã‚ˆã†ã€‚',
            coinGamePrompt: '{expression}',
            coinHint: 'ç¡¬è²¨ã®å€¤æ®µã‚’è¶³ã—ã¦ã­ã€‚',
            currencySymbol: 'Â¥',
            clockMatchPrompt: 'æ™‚è¨ˆåˆã‚ã›',
            clockHint: 'çŸ­ã„é‡ã§æ™‚é–“ã€é•·ã„é‡ã§åˆ†ã‚’èª­ã‚€ã‚ˆã€‚',
            evenLabel: 'å¶æ•°',
            oddLabel: 'å¥‡æ•°',
            parityBoth: 'ã©ã¡ã‚‰ã‚‚',
            parityNeither: 'ã©ã¡ã‚‰ã§ã‚‚ãªã„',
            evenOddHint: '1ã®ä½ãŒ0,2,4,6,8ãªã‚‰å¶æ•°ã ã‚ˆã€‚',
            arrayHint: 'è¡Œã¨åˆ—ã§ã‹ã‘ç®—ã‚’è€ƒãˆã‚ˆã†ã€‚',
            divisionHint: 'ã‹ã‘ç®—ã®é€†ã‚’è€ƒãˆã¦ã­ã€‚',
            wordProblemHint: 'æ–‡ç« ã‹ã‚‰å¼ã‚’ä½œã‚ã†ã€‚',
            unitConversionPrompt: 'å˜ä½ã‚’å¤‰æ›ã—ã‚ˆã†',
            unitConversionHint: 'æ±ºã¾ã£ãŸå€ç‡ã‚’ã‹ã‘ã‚‹ã‹å‰²ã‚ã†ã€‚',
            dataReadingPrompt: 'ä¸€ç•ªå¤šã„ã®ã¯ã©ã‚Œï¼Ÿ',
            dataReadingHint: 'æ•°å­—ã‚„æ£’ã‚°ãƒ©ãƒ•ã‚’æ¯”ã¹ã‚ˆã†ã€‚',
            multiplication: 'ã‹ã‘ç®—ï¼ˆä¹ä¹ï¼‰',
            division: 'ã‚ã‚Šç®—ï¼ˆã‚ã¾ã‚Šãªã—ï¼‰',
            back: 'ã‚‚ã©ã‚‹',
            submit: 'ã‘ã£ã¦ã„',
            level: 'ãƒ¬ãƒ™ãƒ«',
            defeated: 'ãŸãŠã—ãŸ',
            timeLeft: 'ã®ã“ã‚Šæ™‚é–“',
            seconds: 'ç§’',
            correct: 'ã›ã„ã‹ã„ï¼ã™ã”ã„ã­ï¼',
            incorrect: 'ã–ã‚“ã­ã‚“ï¼ã‚‚ã†ã„ã¡ã©ï¼',
            timeUp: 'ã˜ã‹ã‚“ãã‚Œï¼ã‚‚ã†ã„ã¡ã©ï¼',
            wall: 'ã‹ã¹ã ã‚ˆï¼ã¹ã¤ã®é“ã‚’ã•ãŒãã†ï¼',
            gateBlocked: 'ãƒœã‚¹ã‚’ãŸãŠã•ãªã„ã¨ ã¨ãŠã‚Œãªã„ï¼',
            gateOpened: 'ã‚²ãƒ¼ãƒˆãŒã²ã‚‰ã„ãŸï¼',
            bossDefeated: 'ãƒœã‚¹ã‚’ãŸãŠã—ãŸï¼ã‚²ãƒ¼ãƒˆãŒã²ã‚‰ãã‚ˆï¼',
            monsterDefeated: 'ã‚’ãŸãŠã—ãŸï¼',
            levelClear: 'ãƒ¬ãƒ™ãƒ«',
            clearMessage: 'ã‚¯ãƒªã‚¢ï¼',
            nextLevel: 'ã¤ãã®ãƒ¬ãƒ™ãƒ«ã¸ï¼',
            menu: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸',
            becomeHero: 'ã•ã‚“ã™ã†å‹‡è€…ã«ãªã£ã¦',
            conquerDungeon: 'ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚’åˆ¶è¦‡ã—ã‚ˆã†ï¼',
            dungeonExploring: 'ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³æ¢ç´¢ä¸­',
            bossBattle: 'ãƒœã‚¹ãƒãƒˆãƒ«ï¼',
            appeared: 'ãŒã‚ã‚‰ã‚ã‚ŒãŸï¼',
            bossWarning: 'ã“ã®ãƒœã‚¹ã‚’ãŸãŠã•ãªã„ã¨ ã‚´ãƒ¼ãƒ«ã§ããªã„ï¼',
            defeatedBoss: 'ãƒœã‚¹ã‚’ãŸãŠã—ãŸï¼ã‚´ãƒ¼ãƒ«ã¸å‘ã‹ãŠã†ï¼',
            needDefeatBoss: 'ãƒœã‚¹ã‚’ãŸãŠã•ãªã„ã¨ã‚´ãƒ¼ãƒ«ã§ããªã„ï¼',
            you: 'ã˜ã¶ã‚“',
            monster: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼',
            boss: 'ãƒœã‚¹',
            gate: 'ã‚²ãƒ¼ãƒˆ',
            goal: 'ã‚´ãƒ¼ãƒ«',
            totalDefeated: 'ãœã‚“ã¶ã§ãŸãŠã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼',
            totalQuestions: 'ã¨ã„ãŸã‚‚ã‚“ã ã„',
            correctAnswers: 'ã›ã„ã‹ã„ã—ãŸã‚‚ã‚“ã ã„',
            accuracy: 'ã›ã„ã‹ã„ç‡',
            congratulations: 'ãŠã‚ã§ã¨ã†ï¼',
            yourStats: 'ãã¿ã®ã›ã„ã›ã',
            found: 'ã¿ã¤ã‘ãŸ',
            notFound: 'ã¾ã ã¿ã¤ã‘ã¦ã„ãªã„ã‚ˆ',
            hp: 'ãŸã„ã‚Šã‚‡ã',
            whichBigger: 'ã©ã¡ã‚‰ãŒå¤§ãã„ï¼Ÿ',
            body: 'ä½“',
            question: 'å•',
            badges: 'ãƒãƒƒã‚¸',
            firstClear: 'ã¯ã˜ã‚ã¦ã®ã‚¯ãƒªã‚¢',
            perfectClear: 'ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆ',
            multiplicationMaster: 'ä¹ä¹ãƒã‚¹ã‚¿ãƒ¼',
            typesOfMonsters: 'ã—ã‚…ã‚‹ã„ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼',
            hint: 'ãƒ’ãƒ³ãƒˆ: ã˜ã¶ã‚“ã®å­¦å¹´ã«ã‚ã£ãŸãƒ¢ãƒ¼ãƒ‰ã‚’ãˆã‚‰ã¼ã†ï¼',
            viewHint: 'ãƒ’ãƒ³ãƒˆã‚’ã¿ã‚‹',
            hideHint: 'ãƒ’ãƒ³ãƒˆã‚’éš ã™',
            insectMission: 'è™«å–ã‚ŠãƒŸãƒƒã‚·ãƒ§ãƒ³',
            selectArea: 'ã‚¨ãƒªã‚¢ã‚’é¸ã¼ã†',
            urawa: 'æµ¦å’Œ',
            omiya: 'å¤§å®®',
            iwatsuki: 'å²©æ§»',
            cicada: 'ã‚»ãƒŸ',
            cicadaFact: 'å¤§å®®å…¬åœ’ã§ã¯ã‚»ãƒŸãŒãŸãã•ã‚“é³´ã„ã¦ã„ã‚‹ã‚ˆã€‚',
            beetle: 'ã‚«ãƒ–ãƒˆãƒ ã‚·',
            beetleFact: 'æµ¦å’Œã§ã¯ã‚«ãƒ–ãƒˆãƒ ã‚·ãŒäººæ°—ã ã‚ˆã€‚',
            dragonfly: 'ãƒˆãƒ³ãƒœ',
            dragonflyFact: 'è¦‹æ²¼ç”°ã‚“ã¼ã§ã¯ãƒˆãƒ³ãƒœãŒé£›ã³å›ã£ã¦ã„ã‚‹ã‚ˆã€‚',
            attemptCapture: 'æ•ç²ã«æŒ‘æˆ¦',
            captureInsect: 'è™«ã‚’æ•ã¾ãˆã‚ˆã†',
            captureSuccess: 'æ•ç²æˆåŠŸï¼',
            captureFail: 'é€ƒã’ã‚‰ã‚ŒãŸï¼',
            subjectSelect: 'å­¦ç¿’ã—ãŸã„ãƒ¢ãƒ¼ãƒ‰ã‚’é¸ã¼ã†',
            subjectMath: 'ç®—æ•°ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³',
            subjectMathDescription: 'è¿·è·¯ã‚’é€²ã¿ãªãŒã‚‰è¨ˆç®—ãƒãƒˆãƒ«ã«æŒ‘æˆ¦ã€‚',
            subjectKokugo: 'å›½èªã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ¼',
            subjectKokugoDescription: 'èª­ã¿å–ã‚Šãƒ»æ¼¢å­—ãƒ»èªå½™ãƒ»æ–‡æ³•ã‚’æ¥½ã—ã¿ãªãŒã‚‰å­¦ã¶ãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚',
            startKokugo: 'å›½èªã‚¯ã‚¤ã‚ºã‚’å§‹ã‚ã‚‹',
            kokugoIntro: 'å­¦å¹´ã¨é›£æ˜“åº¦ã‚’é¸ã‚“ã§å›½èªã®å†’é™ºã‚’ã¯ã˜ã‚ã‚ˆã†ã€‚',
            studyLanguageLabel: 'æŒ‘æˆ¦ã™ã‚‹è¨€èª',
            nativeLanguageLabel: 'ã‚µãƒãƒ¼ãƒˆè¨€èª',
            swapLanguages: 'è¨€èªã‚’å…¥ã‚Œæ›¿ãˆã‚‹',
            difficultyEasy: 'ã‚„ã•ã—ã„',
            difficultyNormal: 'ãµã¤ã†',
            difficultyHard: 'ã‚€ãšã‹ã—ã„',
            questionTypeReading: 'èª­ã¿',
            questionTypeKanji: 'æ¼¢å­—',
            questionTypeVocab: 'èªå½™',
            questionTypeComprehension: 'èª­è§£',
            questionTypeGrammar: 'æ–‡æ³•',
            questionProgress: '{current}/{total}å•ç›®',
            hintsRemaining: 'ãƒ’ãƒ³ãƒˆ {remaining}/{total}',
            ttsPlay: 'èª­ã¿ä¸Šã’',
            ttsStop: 'åœæ­¢',
            supportPrompt: 'ãƒ’ãƒ³ãƒˆ ({lang})',
            kokugoSummaryTitle: 'å›½èªãƒãƒ£ãƒ¬ãƒ³ã‚¸ã®çµæœ',
            kokugoSummaryAccuracy: 'æ­£ç­”ç‡',
            kokugoSummaryCorrect: 'æ­£è§£æ•°',
            kokugoSummaryAgain: 'ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦',
            kokugoSummaryMenu: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹',
            kokugoSummaryDetails: 'ä»Šå›ã®è¦‹ç›´ã—',
            nextQuestion: 'æ¬¡ã®å•é¡Œã¸',
            kokugoViewResults: 'çµæœã‚’è¦‹ã‚‹',
            kokugoNoQuestions: 'é¸æŠã—ãŸæ¡ä»¶ã®å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚',
            languageStatsTitle: 'è¨€èªã”ã¨ã®å­¦ç¿’è¨˜éŒ²',
            languageStatsDescription: 'ç§‘ç›®ã¨è¨€èªã”ã¨ã®æ­£ç­”çŠ¶æ³',
            languageColumn: 'è¨€èª',
            subjectColumn: 'ç§‘ç›®',
            answeredColumn: 'è§£ç­”æ•°',
            correctColumn: 'æ­£è§£æ•°',
            accuracyColumn: 'æ­£ç­”ç‡',
            comprehensionAccuracy: 'èª­è§£ã®æ­£ç­”ç‡',
            badgeLangNovice: 'Lang Novice',
            badgeReadingChamp: 'Reading Champ',
            badgeBugCatcher: 'Bug Catcher',
        },
        en: {
            gameTitle: 'Math Dungeon',
            startGame: 'Start Game!',
            stats: 'Statistics',
            dictionary: 'Monster Guide',
            selectGrade: 'Choose Your Grade!',
            grade2Mode: 'Grade 2 Mode',
            grade3Mode: 'Grade 3 Mode',
            studyContent: 'What to Study:',
            modeSelectTitle: 'Choose your next adventure',
            focusSkillsTitle: 'Focus skills',
            worldsTitle: 'Theme worlds',
            modeDungeon: 'Dungeon Adventure',
            modeDungeonDescription: 'Explore procedurally generated mazes and defeat monsters.',
            modeMiniGames: 'Skill Mini Games',
            modeMiniGamesDescription: 'Play targeted puzzles to build mastery.',
            modeStory: 'Story Quest',
            modeStoryDescription: 'Unlock narrative chapters and lore.',
            modeCoop: 'Co-op Mission',
            modeCoopDescription: 'Team up with a buddy to clear tough challenges.',
            modeVersus: 'Versus Arena',
            modeVersusDescription: 'Race on the same problems and compare scores.',
            modeParent: 'Parent Dashboard',
            modeParentDescription: 'Review progress, badges, and set rewards.',
              modeQuests: 'Quest Board',
              modeQuestsDescription: 'Follow story missions and seasonal challenges.',
              questTrack: 'Track',
              questComplete: 'Quest complete!',
              questCompleteAction: 'Mark complete',
              questCompleted: 'Completed',
              completed: 'Completed',
              questAlreadyCleared: 'Quest already completed.',
              questTracked: 'Quest pinned!',
              inProgress: 'In progress',
              rewardMilestone: 'Milestone',
              rewardLabel: 'Reward',
              modeHistory: 'Recent activity',
              modeCustomize: 'Avatar Studio',
              modeCustomizeDescription: 'Change outfits, companions, and auras.',
              modeShop: 'Item Shop',
              modeShopDescription: 'Spend points on cosmetics and boosts.',
              modeAR: 'AR Fieldwork',
              modeARDescription: 'Take real-world math missions around town.',
              modeARArea: 'Area',
              modeARSkill: 'Skill',
              modeARStart: 'Start mission',
              replay: 'Replay',
              slotOutfit: 'Outfit',
              slotHead: 'Headwear',
              slotWeapon: 'Tool',
              slotAura: 'Aura',
              slotAccessory: 'Accessory',
              slotCompanion: 'Companion',
              baseOutfit: 'Adventurer Robe',
              baseOutfitDescription: 'Balanced for any adventure.',
              baseHead: 'Explorer Band',
              baseHeadDescription: 'Keeps focus steady.',
              baseWeapon: 'Chalk Wand',
              baseWeaponDescription: 'Sketch strategies mid-battle.',
              baseAura: 'No Aura',
              baseAuraDescription: 'Pure focus with no glow.',
              baseAccessory: 'Travel Light',
              baseAccessoryDescription: 'Nothing extra, just courage.',
              companionNone: 'No companion',
              companionNoneDescription: 'Adventure solo.',
              avatarPreview: 'Current look',
              equip: 'Equip',
              equipped: 'Equipped',
              notPurchased: 'Buy in shop',
              purchase: 'Purchase',
              purchaseComplete: 'Purchase complete!',
              alreadyOwned: 'Already owned.',
              notEnoughPoints: 'Not enough points.',
              noRequirement: 'No requirement',
              requiresBadge: 'Requires badge',
              locked: 'Locked',
            storyBegin: 'Unlock chapter',
            viewStory: 'View chapter',
            answer: 'Answer',
            miniGameTitle: 'Mini games',
            miniGameStart: 'Start',
            miniGameSkill: 'Skill focus',
            progress: 'Progress',
            completeStory: 'Mark chapter complete',
            storyLocked: 'New chapter unlocked!',
            launchCoop: 'Start mission',
            launchVersus: 'Start match',
            parentDashboard: 'Parent Dashboard',
            miniGameStat: 'Mini game records',
            weeklyProgress: 'Weekly progress',
            backToModes: 'Back to mode select',

            addition: 'Addition',
            subtraction: 'Subtraction',
            comparison: 'Number Comparison',
            additionCarryHint: 'Regroup the ones place to form a new ten.',
            subtractionBorrowHint: 'Borrow from the next place value when needed.',
            coinGamePrompt: '{expression}',
            coinHint: 'Add each coin value.',
            currencySymbol: '$',
            clockMatchPrompt: 'Match the clock',
            clockHint: 'Read hour first, then minutes.',
            evenLabel: 'Even',
            oddLabel: 'Odd',
            parityBoth: 'Both',
            parityNeither: 'Neither',
            evenOddHint: 'Look at the ones digit.',
            arrayHint: 'Think rows times columns.',
            divisionHint: 'Division is the inverse of multiplication.',
            wordProblemHint: 'Turn the story into an equation.',
            unitConversionPrompt: 'Convert the unit',
            unitConversionHint: 'Multiply or divide by the conversion factor.',
            dataReadingPrompt: 'Which bar is the tallest?',
            dataReadingHint: 'Compare each value carefully.',
            multiplication: 'Multiplication',
            division: 'Division',
            back: 'Back',
            submit: 'Submit',
            level: 'Level',
            defeated: 'Defeated',
            timeLeft: 'Time Left',
            seconds: 'sec',
            correct: 'Correct! Great job!',
            incorrect: 'Try again!',
            timeUp: "Time's up! Try again!",
            wall: "It's a wall! Find another way!",
            gateBlocked: 'Defeat the boss to pass!',
            gateOpened: 'Gate opened!',
            bossDefeated: 'Boss defeated! Gate will open!',
            monsterDefeated: ' defeated!',
            levelClear: 'Level',
            clearMessage: 'Clear!',
            nextLevel: 'Next Level!',
            menu: 'Menu',
            becomeHero: 'Become a Math Hero',
            conquerDungeon: 'Conquer the Dungeon!',
            dungeonExploring: 'Exploring Dungeon',
            bossBattle: 'Boss Battle!',
            appeared: ' appeared!',
            bossWarning: 'Defeat this boss to reach the goal!',
            defeatedBoss: 'Boss defeated! Head to the goal!',
            needDefeatBoss: 'Defeat the boss to reach the goal!',
            you: 'You',
            monster: 'Monster',
            boss: 'Boss',
            gate: 'Gate',
            goal: 'Goal',
            totalDefeated: 'Total Monsters Defeated',
            totalQuestions: 'Questions Answered',
            correctAnswers: 'Correct Answers',
            accuracy: 'Accuracy',
            congratulations: 'Congratulations!',
            yourStats: 'Your Statistics',
            found: 'Found',
            notFound: 'Not discovered yet',
            hp: 'HP',
            whichBigger: 'Which is bigger?',
            body: ' monsters',
            question: ' questions',
            badges: 'Badges',
            firstClear: 'First Clear',
            perfectClear: 'Perfect',
            multiplicationMaster: 'Times Table Master',
            typesOfMonsters: 'types of monsters',
            hint: 'Hint: Choose the mode for your grade level!',
            viewHint: 'Show Hint',
            hideHint: 'Hide Hint',
            insectMission: 'Insect Mission',
            selectArea: 'Select Area',
            urawa: 'Urawa',
            omiya: 'Omiya',
            iwatsuki: 'Iwatsuki',
            cicada: 'Cicada',
            cicadaFact: 'Many cicadas sing in Omiya Park.',
            beetle: 'Beetle',
            beetleFact: 'Beetles are popular in Urawa.',
            dragonfly: 'Dragonfly',
            dragonflyFact: 'Dragonflies fly around Minuma Tambo.',
            attemptCapture: 'Attempt Capture',
            captureInsect: 'Catch the insect',
            captureSuccess: 'Captured!',
            captureFail: 'It escaped!',
            subjectSelect: 'Choose your learning path',
            subjectMath: 'Math Dungeon',
            subjectMathDescription: 'Solve puzzles and conquer monsters with math.',
            subjectKokugo: 'Kokugo Quest',
            subjectKokugoDescription: 'Practice Japanese reading, kanji, vocabulary, and comprehension.',
            startKokugo: 'Start Kokugo Practice',
            kokugoIntro: 'Pick a grade and difficulty to begin the language challenge.',
            studyLanguageLabel: 'Challenge language',
            nativeLanguageLabel: 'Support language',
            swapLanguages: 'Swap languages',
            difficultyEasy: 'Easy',
            difficultyNormal: 'Normal',
            difficultyHard: 'Hard',
            questionTypeReading: 'Reading',
            questionTypeKanji: 'Kanji',
            questionTypeVocab: 'Vocabulary',
            questionTypeComprehension: 'Comprehension',
            questionTypeGrammar: 'Grammar',
            questionProgress: 'Question {current} of {total}',
            hintsRemaining: 'Hints {remaining}/{total}',
            ttsPlay: 'Read aloud',
            ttsStop: 'Stop reading',
            supportPrompt: 'Hint ({lang})',
            kokugoSummaryTitle: 'Kokugo Challenge Results',
            kokugoSummaryAccuracy: 'Accuracy',
            kokugoSummaryCorrect: 'Correct Answers',
            kokugoSummaryAgain: 'Try again',
            kokugoSummaryMenu: 'Back to menu',
            kokugoSummaryDetails: 'Review your answers',
            nextQuestion: 'Next Question',
            kokugoViewResults: 'View Results',
            kokugoNoQuestions: 'No questions available for the selected options.',
            languageStatsTitle: 'Language Progress',
            languageStatsDescription: 'Accuracy by subject and language',
            languageColumn: 'Language',
            subjectColumn: 'Subject',
            answeredColumn: 'Answered',
            correctColumn: 'Correct',
            accuracyColumn: 'Accuracy',
            comprehensionAccuracy: 'Comprehension accuracy',
            badgeLangNovice: 'Lang Novice',
            badgeReadingChamp: 'Reading Champ',
            badgeBugCatcher: 'Bug Catcher',
        },
        fr: {
            gameTitle: 'Donjon des Maths',
            startGame: 'Commencer!',
            stats: 'Statistiques',
            dictionary: 'Guide des Monstres',
            selectGrade: 'Choisissez votre niveau!',
            grade2Mode: 'Mode 2e annÃ©e',
            grade3Mode: 'Mode 3e annÃ©e',
            studyContent: 'Ã€ Ã©tudier:',
            addition: 'Addition',
            subtraction: 'Soustraction',
            comparison: 'Comparaison',
            additionCarryHint: 'Addition avec retenue : pense Ã  former une dizaine.',
            subtractionBorrowHint: 'Emprunte dans la colonne suivante si besoin.',
            coinGamePrompt: '{expression}',
            coinHint: 'Additionne la valeur de chaque piÃ¨ce.',
            currencySymbol: 'â‚¬',
            clockMatchPrompt: 'Remets l\'horloge',
            clockHint: 'Lis l\'heure puis les minutes.',
            evenLabel: 'Pair',
            oddLabel: 'Impair',
            parityBoth: 'Les deux',
            parityNeither: 'Aucun',
            evenOddHint: 'Observe le chiffre des unitÃ©s.',
            arrayHint: 'Utilise lignes et colonnes.',
            divisionHint: 'La division est l\'inverse de la multiplication.',
            wordProblemHint: 'Transforme l\'histoire en Ã©quation.',
            unitConversionPrompt: 'Convertis l\'unitÃ©',
            unitConversionHint: 'Multiplie ou divise par le facteur.',
            dataReadingPrompt: 'Quelle valeur est la plus grande ?',
            dataReadingHint: 'Compare chaque barre attentivement.',
            multiplication: 'Multiplication',
            division: 'Division',
            back: 'Retour',
            submit: 'Valider',
            level: 'Niveau',
            defeated: 'Vaincus',
            timeLeft: 'Temps restant',
            seconds: 'sec',
            correct: 'Correct! Bravo!',
            incorrect: 'Essaie encore!',
            timeUp: 'Temps Ã©coulÃ©!',
            wall: "C'est un mur!",
            gateBlocked: 'Vaincs le boss pour passer!',
            gateOpened: 'Porte ouverte!',
            bossDefeated: 'Boss vaincu!',
            monsterDefeated: ' vaincu!',
            levelClear: 'Niveau',
            clearMessage: 'RÃ©ussi!',
            nextLevel: 'Niveau suivant!',
            menu: 'Menu',
            becomeHero: 'Deviens un hÃ©ros des maths',
            conquerDungeon: 'Conquiers le donjon!',
            dungeonExploring: 'Exploration du donjon',
            bossBattle: 'Combat de boss!',
            appeared: ' est apparu!',
            bossWarning: 'Vaincs ce boss pour atteindre le but!',
            defeatedBoss: 'Boss vaincu! Dirige-toi vers le but!',
            needDefeatBoss: 'Vaincs le boss pour atteindre le but!',
            you: 'Toi',
            monster: 'Monstre',
            boss: 'Boss',
            gate: 'Porte',
            goal: 'But',
            totalDefeated: 'Total de monstres vaincus',
            totalQuestions: 'Questions rÃ©pondues',
            correctAnswers: 'Bonnes rÃ©ponses',
            accuracy: 'PrÃ©cision',
            congratulations: 'FÃ©licitations!',
            yourStats: 'Tes Statistiques',
            found: 'TrouvÃ©',
            notFound: 'Pas encore dÃ©couvert',
            hp: 'PV',
            whichBigger: 'Lequel est plus grand?',
            body: ' monstres',
            question: ' questions',
            badges: 'Badges',
            firstClear: 'PremiÃ¨re victoire',
            perfectClear: 'Parfait',
            multiplicationMaster: 'MaÃ®tre des tables',
            typesOfMonsters: 'types de monstres',
            hint: 'Astuce: Choisis le mode pour ton niveau!',
            viewHint: "Voir l'indice",
            hideHint: "Cacher l'indice",
            insectMission: 'Mission Insecte',
            selectArea: 'Choisir une zone',
            urawa: 'Urawa',
            omiya: 'Omiya',
            iwatsuki: 'Iwatsuki',
            cicada: 'Cigale',
            cicadaFact: 'Beaucoup de cigales chantent au parc Omiya.',
            beetle: 'ScarabÃ©e',
            beetleFact: 'Les scarabÃ©es sont populaires Ã  Urawa.',
            dragonfly: 'Libellule',
            dragonflyFact: 'Les libellules volent autour de Minuma Tambo.',
            attemptCapture: 'Tenter la capture',
            captureInsect: "Attrape l'insecte",
            captureSuccess: 'CapturÃ©!',
            captureFail: 'S\'est Ã©chappÃ©!',
            subjectSelect: 'Choisis ta matiÃ¨re',
            subjectMath: 'Donjon des maths',
            subjectMathDescription: 'RÃ©sous des Ã©nigmes et bats les monstres avec les calculs.',
            subjectKokugo: 'QuÃªte de kokugo',
            subjectKokugoDescription: 'Travaille la lecture, les kanjis, le vocabulaire et la comprÃ©hension.',
            startKokugo: 'Commencer le kokugo',
            kokugoIntro: 'Choisis une classe et une difficultÃ© pour dÃ©marrer le dÃ©fi de langue.',
            studyLanguageLabel: 'Langue de dÃ©fi',
            nativeLanguageLabel: 'Langue de soutien',
            swapLanguages: 'Inverser les langues',
            difficultyEasy: 'Facile',
            difficultyNormal: 'Normal',
            difficultyHard: 'Difficile',
            questionTypeReading: 'Lecture',
            questionTypeKanji: 'Kanji',
            questionTypeVocab: 'Vocabulaire',
            questionTypeComprehension: 'ComprÃ©hension',
            questionTypeGrammar: 'Grammaire',
            questionProgress: 'Question {current}/{total}',
            hintsRemaining: 'Indices {remaining}/{total}',
            ttsPlay: 'Lecture audio',
            ttsStop: 'ArrÃªter l\'audio',
            supportPrompt: 'Indice ({lang})',
            kokugoSummaryTitle: 'RÃ©sultats du dÃ©fi de kokugo',
            kokugoSummaryAccuracy: 'PrÃ©cision',
            kokugoSummaryCorrect: 'Bonnes rÃ©ponses',
            kokugoSummaryAgain: 'Recommencer',
            kokugoSummaryMenu: 'Retour au menu',
            kokugoSummaryDetails: 'RÃ©vision des rÃ©ponses',
            nextQuestion: 'Question suivante',
            kokugoViewResults: 'Voir les rÃ©sultats',
            kokugoNoQuestions: 'Aucune question disponible pour ces options.',
            languageStatsTitle: 'Progression par langue',
            languageStatsDescription: 'Taux de rÃ©ussite par matiÃ¨re et langue',
            languageColumn: 'Langue',
            subjectColumn: 'MatiÃ¨re',
            answeredColumn: 'RÃ©pondu',
            correctColumn: 'Correct',
            accuracyColumn: 'PrÃ©cision',
            comprehensionAccuracy: 'PrÃ©cision comprÃ©hension',
            badgeLangNovice: 'Lang Novice',
            badgeReadingChamp: 'Reading Champ',
            badgeBugCatcher: 'Bug Catcher',
        },
        zh: {
            gameTitle: 'æ•°å­¦åœ°ç‰¢',
            startGame: 'å¼€å§‹æ¸¸æˆï¼',
            stats: 'ç»Ÿè®¡',
            dictionary: 'æ€ªç‰©å›¾é‰´',
            selectGrade: 'é€‰æ‹©å¹´çº§ï¼',
            grade2Mode: 'äºŒå¹´çº§æ¨¡å¼',
            grade3Mode: 'ä¸‰å¹´çº§æ¨¡å¼',
            studyContent: 'å­¦ä¹ å†…å®¹ï¼š',
            addition: 'åŠ æ³•',
            subtraction: 'å‡æ³•',
            comparison: 'æ•°å­—æ¯”è¾ƒ',
            additionCarryHint: 'æ³¨æ„è¿›ä½ï¼ŒæŠŠä¸ªä½å…ˆåŠ èµ·æ¥ã€‚',
            subtractionBorrowHint: 'éœ€è¦æ—¶å‘å‰ä¸€ä½å€Ÿ1å†å‡ã€‚',
            coinGamePrompt: '{expression}',
            coinHint: 'æŠŠæ¯ä¸ªç¡¬å¸çš„é‡‘é¢ç›¸åŠ ã€‚',
            currencySymbol: 'Â¥',
            clockMatchPrompt: 'è°ƒå‡†æ—¶é’Ÿ',
            clockHint: 'å…ˆçœ‹æ—¶é’ˆï¼Œå†çœ‹åˆ†é’ˆã€‚',
            evenLabel: 'å¶æ•°',
            oddLabel: 'å¥‡æ•°',
            parityBoth: 'éƒ½å¯ä»¥',
            parityNeither: 'éƒ½ä¸æ˜¯',
            evenOddHint: 'çœ‹ä¸ªä½æ•°å­—æ˜¯å¦ä¸º0,2,4,6,8ã€‚',
            arrayHint: 'ç”¨è¡Œå’Œåˆ—æ¥æƒ³ä¹˜æ³•ã€‚',
            divisionHint: 'é™¤æ³•æ˜¯ä¹˜æ³•çš„é€†è¿ç®—ã€‚',
            wordProblemHint: 'æŠŠæ•…äº‹è½¬æˆç®—å¼ã€‚',
            unitConversionPrompt: 'æ¢ç®—å•ä½',
            unitConversionHint: 'ä¹˜æˆ–é™¤ä»¥æ¢ç®—ç³»æ•°ã€‚',
            dataReadingPrompt: 'å“ªä¸ªå€¼æœ€å¤§ï¼Ÿ',
            dataReadingHint: 'ä»”ç»†æ¯”è¾ƒæ¯ä¸ªæ•°å­—æˆ–æ¡å½¢å›¾ã€‚',
            multiplication: 'ä¹˜æ³•',
            division: 'é™¤æ³•',
            back: 'è¿”å›',
            submit: 'æäº¤',
            level: 'å…³å¡',
            defeated: 'å‡»è´¥',
            timeLeft: 'å‰©ä½™æ—¶é—´',
            seconds: 'ç§’',
            correct: 'æ­£ç¡®ï¼å¤ªæ£’äº†ï¼',
            incorrect: 'å†è¯•ä¸€æ¬¡ï¼',
            timeUp: 'æ—¶é—´åˆ°ï¼',
            wall: 'æ˜¯å¢™ï¼',
            gateBlocked: 'å‡»è´¥bossæ‰èƒ½é€šè¿‡ï¼',
            gateOpened: 'å¤§é—¨æ‰“å¼€äº†ï¼',
            bossDefeated: 'Bossè¢«å‡»è´¥ï¼',
            monsterDefeated: 'è¢«å‡»è´¥ï¼',
            levelClear: 'å…³å¡',
            clearMessage: 'é€šå…³ï¼',
            nextLevel: 'ä¸‹ä¸€å…³ï¼',
            menu: 'èœå•',
            becomeHero: 'æˆä¸ºæ•°å­¦è‹±é›„',
            conquerDungeon: 'å¾æœåœ°ç‰¢ï¼',
            dungeonExploring: 'æ¢ç´¢åœ°ç‰¢ä¸­',
            bossBattle: 'Bossæˆ˜ï¼',
            appeared: 'å‡ºç°äº†ï¼',
            bossWarning: 'å‡»è´¥è¿™ä¸ªbossæ‰èƒ½åˆ°è¾¾ç»ˆç‚¹ï¼',
            defeatedBoss: 'Bossè¢«å‡»è´¥ï¼å‰å¾€ç»ˆç‚¹ï¼',
            needDefeatBoss: 'å‡»è´¥bossæ‰èƒ½åˆ°è¾¾ç»ˆç‚¹ï¼',
            you: 'ä½ ',
            monster: 'æ€ªç‰©',
            boss: 'Boss',
            gate: 'å¤§é—¨',
            goal: 'ç»ˆç‚¹',
            totalDefeated: 'å‡»è´¥æ€ªç‰©æ€»æ•°',
            totalQuestions: 'å›ç­”é—®é¢˜æ•°',
            correctAnswers: 'æ­£ç¡®ç­”æ¡ˆæ•°',
            accuracy: 'æ­£ç¡®ç‡',
            congratulations: 'æ­å–œï¼',
            yourStats: 'ä½ çš„ç»Ÿè®¡',
            found: 'å·²å‘ç°',
            notFound: 'å°šæœªå‘ç°',
            hp: 'ç”Ÿå‘½å€¼',
            whichBigger: 'å“ªä¸ªæ›´å¤§ï¼Ÿ',
            body: 'åª',
            question: 'é¢˜',
            badges: 'å¾½ç« ',
            firstClear: 'é¦–æ¬¡é€šå…³',
            perfectClear: 'å®Œç¾',
            multiplicationMaster: 'ä¹ä¹è¡¨å¤§å¸ˆ',
            typesOfMonsters: 'ç§æ€ªç‰©',
            hint: 'æç¤ºï¼šé€‰æ‹©é€‚åˆä½ å¹´çº§çš„æ¨¡å¼ï¼',
            viewHint: 'æŸ¥çœ‹æç¤º',
            hideHint: 'éšè—æç¤º',
            insectMission: 'æ•è™«ä»»åŠ¡',
            selectArea: 'é€‰æ‹©åœ°åŒº',
            urawa: 'æµ¦å’Œ',
            omiya: 'å¤§å®«',
            iwatsuki: 'å²©æ§»',
            cicada: 'è‰',
            cicadaFact: 'åœ¨å¤§å®«å…¬å›­æœ‰å¾ˆå¤šè‰åœ¨å«ã€‚',
            beetle: 'ç”²è™«',
            beetleFact: 'ç”²è™«åœ¨æµ¦å’Œå¾ˆå—æ¬¢è¿ã€‚',
            dragonfly: 'èœ»èœ“',
            dragonflyFact: 'èœ»èœ“åœ¨è§æ²¼ç”°åœƒé£æ¥é£å»ã€‚',
            attemptCapture: 'å°è¯•æ•æ‰',
            captureInsect: 'æ¥æ•æ‰è™«å­',
            captureSuccess: 'æ•æ‰æˆåŠŸï¼',
            captureFail: 'é€ƒèµ°äº†ï¼',
            subjectSelect: 'è¯·é€‰æ‹©å­¦ä¹ æ¨¡å¼',
            subjectMath: 'æ•°å­¦è¿·å®«',
            subjectMathDescription: 'ç”¨æ•°å­¦è§£è°œå¹¶å‡»è´¥æ€ªç‰©ã€‚',
            subjectKokugo: 'å›½è¯­æŒ‘æˆ˜',
            subjectKokugoDescription: 'ç»ƒä¹ é˜…è¯»ã€æ±‰å­—ã€è¯æ±‡ä¸è¯»è§£èƒ½åŠ›ã€‚',
            startKokugo: 'å¼€å§‹å›½è¯­ç»ƒä¹ ',
            kokugoIntro: 'é€‰æ‹©å¹´çº§å’Œéš¾åº¦å¼€å§‹è¯­è¨€æŒ‘æˆ˜ã€‚',
            studyLanguageLabel: 'ç»ƒä¹ è¯­è¨€',
            nativeLanguageLabel: 'è¾…åŠ©è¯­è¨€',
            swapLanguages: 'äº¤æ¢è¯­è¨€',
            difficultyEasy: 'ç®€å•',
            difficultyNormal: 'ä¸€èˆ¬',
            difficultyHard: 'å›°éš¾',
            questionTypeReading: 'æœ—è¯»',
            questionTypeKanji: 'æ±‰å­—',
            questionTypeVocab: 'è¯æ±‡',
            questionTypeComprehension: 'è¯»è§£',
            questionTypeGrammar: 'è¯­æ³•',
            questionProgress: 'ç¬¬ {current} / {total} é¢˜',
            hintsRemaining: 'æç¤º {remaining}/{total}',
            ttsPlay: 'è¯­éŸ³æ’­æ”¾',
            ttsStop: 'åœæ­¢æ’­æ”¾',
            supportPrompt: 'æç¤º ({lang})',
            kokugoSummaryTitle: 'å›½è¯­æŒ‘æˆ˜ç»“æœ',
            kokugoSummaryAccuracy: 'æ­£ç¡®ç‡',
            kokugoSummaryCorrect: 'ç­”å¯¹é¢˜æ•°',
            kokugoSummaryAgain: 'å†æŒ‘æˆ˜ä¸€æ¬¡',
            kokugoSummaryMenu: 'è¿”å›èœå•',
            kokugoSummaryDetails: 'æŸ¥çœ‹ç­”é¢˜',
            nextQuestion: 'ä¸‹ä¸€é¢˜',
            kokugoViewResults: 'æŸ¥çœ‹ç»“æœ',
            kokugoNoQuestions: 'æ‰€é€‰æ¡ä»¶ä¸‹æ²¡æœ‰å¯ç”¨çš„é—®é¢˜ã€‚',
            languageStatsTitle: 'è¯­è¨€å­¦ä¹ ç»Ÿè®¡',
            languageStatsDescription: 'æŒ‰ç§‘ç›®ä¸è¯­è¨€çš„æ­£ç¡®æƒ…å†µ',
            languageColumn: 'è¯­è¨€',
            subjectColumn: 'ç§‘ç›®',
            answeredColumn: 'ä½œç­”æ•°',
            correctColumn: 'ç­”å¯¹æ•°',
            accuracyColumn: 'æ­£ç¡®ç‡',
            comprehensionAccuracy: 'è¯»è§£æ­£ç¡®ç‡',
            badgeLangNovice: 'Lang Novice',
            badgeReadingChamp: 'Reading Champ',
            badgeBugCatcher: 'Bug Catcher',
        }
    }), []);



    const i18n = useMemo(() => new I18nManager(translations), [translations]);

    const [language, setLanguage] = useState(() => i18n.restoreLanguage());

    const [learningLanguage, setLearningLanguage] = useState(() => {

        if (typeof window === 'undefined' || !window.localStorage) {

            return 'en';

        }

        const stored = window.localStorage.getItem(STORAGE_KEYS.learningLanguage);

        return stored && translations[stored] ? stored : 'en';

    });

    const t = i18n.getLanguage(language);

    const formatText = (template, values = {}) => {
        if (!template || typeof template !== 'string') {
            return '';
        }
        return template.replace(/\{(\w+)\}/g, (match, key) => Object.prototype.hasOwnProperty.call(values, key) ? values[key] : match);
    };

    const [selectedSubject, setSelectedSubject] = useState('math');
    const [kokugoGrade, setKokugoGrade] = useState(2);
    const [kokugoDifficulty, setKokugoDifficulty] = useState('easy');
    const [kokugoTypes, setKokugoTypes] = useState(() => new Set(KOKUGO_TYPES));
    const [kokugoSession, setKokugoSession] = useState(null);
    const [kokugoHistory, setKokugoHistory] = useState([]);
    const [maxKokugoQuestions] = useState(5);
    const [kokugoAnswer, setKokugoAnswer] = useState('');
    const [kokugoHintVisible, setKokugoHintVisible] = useState(false);
    const [kokugoFeedback, setKokugoFeedback] = useState(null);
    const [isTTSSpeaking, setIsTTSSpeaking] = useState(false);

    const speechRef = useRef(null);
    const playerStatsRef = useRef(null);

    const buildKokugoQuestion = useCallback(({ grade, difficulty, lang, supportLang, questionTypes, excludeIds = [] }) => {
        const question = questionManager.getRandomQuestion({ grade, subject: 'kokugo', lang, difficulty, questionTypes, excludeIds });
        if (!question) {
            return null;
        }
        const support = supportLang && supportLang !== lang
            ? questionManager.getQuestionForLanguage({ grade, subject: 'kokugo', suffix: question.suffix || '0000', lang: supportLang })
            : null;
        return {
            question,
            support,
            revealedHints: 0,
            attempts: 0
        };
    }, []);




    // Monster types with multilingual names

    const getMonsterTypes = useCallback(() => {

        const monsterNames = {
            ja: {
                denkiryu: { name: 'ãƒ‡ãƒ³ã‚­ãƒªãƒ¥ã‚¦', desc: 'ã§ã‚“ãã‚¿ã‚¤ãƒ—ï¼ãŸã—ç®—ã§ ã“ã†ã’ãã ï¼' },
                mizugame: { name: 'ãƒŸã‚ºã‚¬ãƒ¡', desc: 'ã¿ãšã‚¿ã‚¤ãƒ—ï¼ã²ãç®—ã® ã‚ã–ã‚’ ã¯ã¤ï¼' },
                happamon: { name: 'ãƒãƒƒãƒ‘ãƒ¢ãƒ³', desc: 'ãã•ã‚¿ã‚¤ãƒ—ï¼ã‹ãšã® ã¡ã‹ã‚‰ã‚’ ãã‚‰ã¹ã‚‹ï¼' },
                honoodon: { name: 'ãƒ›ãƒã‚ªãƒ‰ãƒ³', desc: 'ã»ã®ãŠã‚¿ã‚¤ãƒ—ï¼ã‚ã¤ã„ ãŸã—ç®—ã‚’ ã ã™ï¼' },
                starion: { name: 'ã‚¹ã‚¿ãƒªã‚ªãƒ³', desc: 'ã»ã—ã‚¿ã‚¤ãƒ—ï¼ã‹ã‘ç®—ã® ã»ã—ã‚’ ãµã‚‰ã›ã‚‹ï¼' },
                crystalos: { name: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ­ã‚¹', desc: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ«ã‚¿ã‚¤ãƒ—ï¼ã‚ã‚Šç®—ã§ ã“ã†ã’ãï¼' },
                raidenking: { name: 'ãƒ©ã‚¤ãƒ‡ãƒ³ã‚­ãƒ³ã‚°', desc: 'ã§ã‚“ã›ã¤ã® ãƒœã‚¹ï¼ãŸãŠã•ãªã„ã¨ ã•ãã« ã™ã™ã‚ãªã„ï¼' },
                mathemperor: { name: 'ãƒã‚¹ã‚¨ãƒ³ãƒšãƒ©ãƒ¼', desc: 'ã•ã‚“ã™ã†ã® ã¦ã„ãŠã†ï¼ä¹ä¹ã‚’ ãƒã‚¹ã‚¿ãƒ¼ã—ã¦ã„ã‚‹ï¼' }
            },
            en: {
                denkiryu: { name: 'Electrox', desc: 'Electric type! Attacks with addition!' },
                mizugame: { name: 'Aquaturtle', desc: 'Water type! Uses subtraction skills!' },
                happamon: { name: 'Leafmon', desc: 'Grass type! Compares number powers!' },
                honoodon: { name: 'Blazedon', desc: 'Fire type! Throws hot additions!' },
                starion: { name: 'Starion', desc: 'Star type! Rains multiplication stars!' },
                crystalos: { name: 'Crystalos', desc: 'Crystal type! Attacks with division!' },
                raidenking: { name: 'Thunder King', desc: 'Legendary boss! Must defeat to proceed!' },
                mathemperor: { name: 'Math Emperor', desc: 'Emperor of math! Master of times tables!' }
            },
            fr: {
                denkiryu: { name: 'Ã‰lectryx', desc: 'Type Ã©lectrique! Attaque avec addition!' },
                mizugame: { name: 'Aquatortue', desc: 'Type eau! Utilise la soustraction!' },
                happamon: { name: 'Feuilmon', desc: 'Type plante! Compare les nombres!' },
                honoodon: { name: 'Flammedon', desc: 'Type feu! Lance des additions brÃ»lantes!' },
                starion: { name: 'Ã‰toilon', desc: 'Type Ã©toile! Pleut des multiplications!' },
                crystalos: { name: 'Crystalos', desc: 'Type cristal! Attaque avec division!' },
                raidenking: { name: 'Roi Tonnerre', desc: 'Boss lÃ©gendaire! Ã€ vaincre pour continuer!' },
                mathemperor: { name: 'Empereur Math', desc: 'Empereur des maths! MaÃ®tre des tables!' }
            },
            zh: {
                denkiryu: { name: 'ç”µé¾™', desc: 'ç”µç³»ï¼ç”¨åŠ æ³•æ”»å‡»ï¼' },
                mizugame: { name: 'æ°´é¾Ÿ', desc: 'æ°´ç³»ï¼ä½¿ç”¨å‡æ³•æŠ€èƒ½ï¼' },
                happamon: { name: 'å¶å…½', desc: 'è‰ç³»ï¼æ¯”è¾ƒæ•°å­—åŠ›é‡ï¼' },
                honoodon: { name: 'ç«ç„°å…½', desc: 'ç«ç³»ï¼å‘å‡ºç‚½çƒ­çš„åŠ æ³•ï¼' },
                starion: { name: 'æ˜Ÿå…½', desc: 'æ˜Ÿç³»ï¼é™ä¸‹ä¹˜æ³•ä¹‹æ˜Ÿï¼' },
                crystalos: { name: 'æ°´æ™¶å…½', desc: 'æ°´æ™¶ç³»ï¼ç”¨é™¤æ³•æ”»å‡»ï¼' },
                raidenking: { name: 'é›·ç‹', desc: 'ä¼ è¯´ä¸­çš„Bossï¼å¿…é¡»å‡»è´¥æ‰èƒ½å‰è¿›ï¼' },
                mathemperor: { name: 'æ•°å­¦çš‡å¸', desc: 'æ•°å­¦çš„å¸ç‹ï¼æŒæ¡ä¹ä¹è¡¨ï¼' }
            }
        };

        return [
            // Grade 2 monsters
            {
                id: 'denkiryu',
                name: monsterNames[language].denkiryu.name,
                emoji: 'âš¡',
                problemType: 'addition',
                description: monsterNames[language].denkiryu.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            {
                id: 'mizugame',
                name: monsterNames[language].mizugame.name,
                emoji: 'ğŸ¢',
                problemType: 'subtraction',
                description: monsterNames[language].mizugame.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            {
                id: 'happamon',
                name: monsterNames[language].happamon.name,
                emoji: 'ğŸƒ',
                problemType: 'comparison',
                description: monsterNames[language].happamon.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            {
                id: 'honoodon',
                name: monsterNames[language].honoodon.name,
                emoji: 'ğŸ”¥',
                problemType: 'addition',
                description: monsterNames[language].honoodon.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            // Grade 3 monsters
            {
                id: 'starion',
                name: monsterNames[language].starion.name,
                emoji: 'â­',
                problemType: 'multiplication',
                description: monsterNames[language].starion.desc,
                isBoss: false,
                grade: 3,
                health: 3
            },
            {
                id: 'crystalos',
                name: monsterNames[language].crystalos.name,
                emoji: 'ğŸ’',
                problemType: 'division',
                description: monsterNames[language].crystalos.desc,
                isBoss: false,
                grade: 3,
                health: 3
            },
            // Boss monsters
            {
                id: 'raidenking',
                name: monsterNames[language].raidenking.name,
                emoji: 'ğŸ‘‘',
                problemType: 'addition',
                description: monsterNames[language].raidenking.desc,
                isBoss: true,
                grade: 2,
                health: 5
            },
            {
                id: 'mathemperor',
                name: monsterNames[language].mathemperor.name,
                emoji: 'ğŸ°',
                problemType: 'multiplication',
                description: monsterNames[language].mathemperor.desc,
                isBoss: true,
                grade: 3,
                health: 7
            }
        ];
    }, [language]);



    const getSpeechLocale = (code) => {
        switch (code) {
            case 'ja':
                return 'ja-JP';
            case 'fr':
                return 'fr-FR';
            case 'zh':
                return 'zh-CN';
            default:
                return 'en-US';
        }
    };

    const speak = useCallback((textValue, voiceLang) => {
        if (typeof window === 'undefined' || !window.speechSynthesis || !textValue) {
            return;
        }
        try {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(textValue);
            utterance.lang = voiceLang || getSpeechLocale(language);
            utterance.onstart = () => setIsTTSSpeaking(true);
            utterance.onend = () => {
                setIsTTSSpeaking(false);
                speechRef.current = null;
            };
            utterance.onerror = () => {
                setIsTTSSpeaking(false);
                speechRef.current = null;
            };
            speechRef.current = utterance;
            window.speechSynthesis.speak(utterance);
        } catch (error) {
            console.warn('Speech synthesis failed', error);
        }
    }, [language]);

    const stopSpeech = useCallback(() => {
        if (typeof window === 'undefined' || !window.speechSynthesis) {
            return;
        }
        window.speechSynthesis.cancel();
        speechRef.current = null;
        setIsTTSSpeaking(false);
    }, []);

    useEffect(() => () => stopSpeech(), [stopSpeech]);

    // Game state
    const [gameState, setGameState] = useState('menu');
    const [currentLevel, setCurrentLevel] = useState(1);
    const [selectedGrade, setSelectedGrade] = useState(2);
    const [playerPosition, setPlayerPosition] = useState({ x: 0, y: 0 });
    const [maze, setMaze] = useState([]);
    const [mazeSize, setMazeSize] = useState(5);
    const [monsterPositions, setMonsterPositions] = useState([]);
    const [defeatedMonsters, setDefeatedMonsters] = useState([]);
    const [currentMonster, setCurrentMonster] = useState(null);
    const [battleState, setBattleState] = useState(null);
    const [bossGates, setBossGates] = useState([]);
    const [requiredBosses, setRequiredBosses] = useState([]);
    const [timeLeft, setTimeLeft] = useState(30);
    const [message, setMessage] = useState('');
    const [showHint, setShowHint] = useState(false);
    const [activeMode, setActiveMode] = useState('dungeon');
    const [selectedWorld, setSelectedWorld] = useState(null);
    const [activeMiniGame, setActiveMiniGame] = useState(null);
    const [miniGameState, setMiniGameState] = useState(null);
    const [miniGameAnswer, setMiniGameAnswer] = useState('');
    const [miniGameFeedback, setMiniGameFeedback] = useState(null);
    const [coopSession, setCoopSession] = useState(null);
    const [coopAnswer, setCoopAnswer] = useState('');
    const [versusSession, setVersusSession] = useState(null);
    const [versusAnswer, setVersusAnswer] = useState('');
    const [storyScene, setStoryScene] = useState(null);
    const [cheerMessage, setCheerMessage] = useState(null);
    const [aiCoachLog, setAiCoachLog] = useState([]);
    const [parentDashboardTab, setParentDashboardTab] = useState('overview');
    const [activeQuest, setActiveQuest] = useState(null);
    const [customizationTab, setCustomizationTab] = useState('outfit');
    const [activeARMission, setActiveARMission] = useState(null);
    const [arAnswer, setArAnswer] = useState('');
    const [arFeedback, setArFeedback] = useState(null);
    const [selectedRewardTrack, setSelectedRewardTrack] = useState('weekly');
    const [shopFeedback, setShopFeedback] = useState(null);

    const gradeConfig = useMemo(() => {
        if (!gradeCurriculum) {
            return {};
        }
        const direct = gradeCurriculum[selectedGrade] || gradeCurriculum[String(selectedGrade)];
        if (direct) {
            return direct;
        }
        const keys = Object.keys(gradeCurriculum);
        const fallbackKey = keys.length > 0 ? keys[0] : null;
        return fallbackKey ? gradeCurriculum[fallbackKey] : {};
    }, [gradeCurriculum, selectedGrade]);

    const availableWorlds = useMemo(() => {
        if (!Array.isArray(themeWorlds)) {
            return [];
        }
        const featured = gradeConfig && Array.isArray(gradeConfig.featuredWorlds) ? gradeConfig.featuredWorlds : [];
        const combined = new Map();
        themeWorlds.forEach(world => {
            if (!world || !world.id) {
                return;
            }
            const matchesFeatured = featured.includes(world.id);
            const matchesGradeRange = Array.isArray(world.gradeRange) && world.gradeRange.includes(selectedGrade);
            if (matchesFeatured || matchesGradeRange) {
                combined.set(world.id, world);
            }
        });
        return Array.from(combined.values());
    }, [themeWorlds, gradeConfig, selectedGrade]);

    const storyBeatsForGrade = useMemo(() => {
        if (!Array.isArray(storyBeats)) {
            return [];
        }
        return storyBeats
            .filter(beat => {
                if (!beat) return false;
                if (Array.isArray(beat.grades)) {
                    return beat.grades.includes(selectedGrade);
                }
                if (Array.isArray(beat.grade)) {
                    return beat.grade.includes(selectedGrade);
                }
                if (typeof beat.grade === 'number') {
                    return beat.grade === selectedGrade;
                }
                return true;
            })
            .sort((a, b) => (a.order || 0) - (b.order || 0));
    }, [storyBeats, selectedGrade]);

    const evaluateBadgeUnlocks = useCallback((stats) => {
        if (!Array.isArray(badgeCatalog) || badgeCatalog.length === 0) {
            return [];
        }
        const unlocked = [];
        badgeCatalog.forEach(badge => {
            if (!badge || stats.badges.includes(badge.id)) {
                return;
            }
            const requirement = badge.requirement || {};
            let qualifies = false;
            switch (requirement.type) {
                case 'streak': {
                    const skillInfo = stats.skillMastery && stats.skillMastery[requirement.skill];
                    if (skillInfo && skillInfo.streak >= (requirement.count || 5) && (skillInfo.accuracy || 0) >= 0.75) {
                        qualifies = true;
                    }
                    break;
                }
                case 'miniGame': {
                    const record = stats.miniGameRecords && stats.miniGameRecords[requirement.miniGame];
                    if (record && (record.wins || 0) >= (requirement.wins || 3)) {
                        qualifies = true;
                    }
                    break;
                }
                case 'storyClear': {
                    const stories = new Set(stats.storyBeatsUnlocked || []);
                    if (stories.size >= (requirement.episodes || 1) || stories.has('finale')) {
                        qualifies = true;
                    }
                    break;
                }
                case 'quest': {
                    const questId = requirement.questId;
                    const questProgress = stats.questProgress || {};
                    if (questId && questProgress[questId] && questProgress[questId].completed) {
                        qualifies = true;
                    } else if (!questId) {
                        const completedCount = Object.values(questProgress).filter(entry => entry && entry.completed).length;
                        if (completedCount >= (requirement.count || 1)) {
                            qualifies = true;
                        }
                    }
                    break;
                }
                case 'versus': {
                    const records = Array.isArray(stats.versusRecords) ? stats.versusRecords : [];
                    const wins = records.filter(entry => entry && entry.success).length;
                    if (wins >= (requirement.wins || requirement.count || 3)) {
                        qualifies = true;
                    }
                    break;
                }
                case 'coop': {
                    const records = Array.isArray(stats.cooperativeRecords) ? stats.cooperativeRecords : [];
                    const successes = records.filter(entry => entry && entry.success).length;
                    if (successes >= (requirement.successes || requirement.count || 3)) {
                        qualifies = true;
                    }
                    break;
                }
                case 'arMission': {
                    const missions = new Set(stats.arMissionsCompleted || []);
                    if (requirement.id && missions.has(requirement.id)) {
                        qualifies = true;
                    } else if (missions.size >= (requirement.count || 1)) {
                        qualifies = true;
                    }
                    break;
                }
                default:
                    break;
            }
            if (qualifies) {
                unlocked.push(badge.id);
            }
        });
        return unlocked;
    }, [badgeCatalog]);

    const applyBadgeAchievements = useCallback((baseAchievements, newBadges) => {
        if (!newBadges || newBadges.length === 0) {
            return baseAchievements;
        }
        const updated = { ...baseAchievements };
        newBadges.forEach(badgeId => {
            switch (badgeId) {
                case 'carry_master': updated.carryMaster = true; break;
                case 'coin_artist': updated.coinArtist = true; break;
                case 'clock_guardian': updated.clockGuardian = true; break;
                case 'times_table_hero': updated.timesTableHero = true; break;
                case 'unit_wizard': updated.unitWizard = true; break;
                case 'story_scholar': updated.storyScholar = true; break;
                case 'coop_hero': updated.coopHero = true; break;
                case 'versus_champion': updated.versusChampion = true; break;
                case 'ar_explorer': updated.arExplorer = true; break;
                default: break;
            }
        });
        return updated;
    }, []);

    const finalizeProgressionStats = useCallback((previousStats, candidateStats) => {
        const merged = { ...candidateStats };
        const newBadges = evaluateBadgeUnlocks(merged);
        if (newBadges.length > 0) {
            const badgePointBonus = newBadges.reduce((sum, badgeId) => {
                const badge = badgeCatalog.find(entry => entry.id === badgeId);
                return sum + (badge && badge.reward && badge.reward.points ? badge.reward.points : 0);
            }, 0);
            merged.points = (merged.points || 0) + badgePointBonus;
            const priorBadges = Array.isArray(previousStats.badges) ? previousStats.badges : [];
            merged.badges = [...new Set([...priorBadges, ...newBadges])];
            const achievementBase = merged.achievements || previousStats.achievements;
            merged.achievements = applyBadgeAchievements(achievementBase, newBadges);
            const unlocks = newBadges.flatMap(badgeId => {
                const badge = badgeCatalog.find(entry => entry.id === badgeId);
                return badge && badge.reward && badge.reward.shopUnlock ? [badge.reward.shopUnlock] : [];
            });
            if (unlocks.length > 0) {
                const priorUnlocks = Array.isArray(previousStats.shopUnlocks) ? previousStats.shopUnlocks : [];
                merged.shopUnlocks = [...new Set([...priorUnlocks, ...unlocks])];
            }
        }
        return merged;
    }, [evaluateBadgeUnlocks, applyBadgeAchievements, badgeCatalog]);

const skillLabel = (skill) => {
    switch (skill) {
        case 'addition_carry':
            return t.addition;
        case 'subtraction_borrow':
            return t.subtraction;
        case 'money_counting':
            return t.coinHint ? t.coinHint : t.moneyCounting || t.addition;
        case 'clock_reading':
            return t.clockMatchPrompt || 'Clock';
        case 'even_odd':
            return t.evenOddHint || 'Even or Odd';
        case 'multiplication_array':
            return t.multiplication;
        case 'division_basic':
            return t.division;
        case 'unit_conversion':
            return t.unitConversionPrompt || 'Unit conversion';
        case 'word_problem':
            return t.wordProblemHint || 'Word problem';
        case 'data_reading':
            return t.dataReadingPrompt || 'Data reading';
        default:
            return skill;
    }
};

const skillForMiniGame = (config) => {
    if (!config) return 'addition_carry';
    if (config.skill) return config.skill;
    switch (config.id) {
        case 'clock_match':
            return 'clock_reading';
        case 'coin_count':
            return 'money_counting';
        case 'even_odd_sort':
            return 'even_odd';
        case 'array_painter':
            return 'multiplication_array';
        case 'unit_conversion_lab':
            return 'unit_conversion';
        case 'story_solver':
            return 'word_problem';
        default:
            return 'addition_carry';
    }
};

const createMiniGameProblem = (config, stage = 1) => {
    const skill = skillForMiniGame(config);
    return generateProblem(skill, { grade: selectedGrade, skillKey: skill, stage });
};

const updateMiniGameStats = (gameId, wasCorrect) => {
    setPlayerStats(prev => {
        const records = { ...(prev.miniGameRecords || {}) };
        const current = records[gameId] ? { ...records[gameId] } : { wins: 0, attempts: 0, streak: 0 };
        current.attempts += 1;
        if (wasCorrect) {
            current.wins += 1;
            current.streak = (current.streak || 0) + 1;
        } else {
            current.streak = 0;
        }
        records[gameId] = current;
        return { ...prev, miniGameRecords: records };
    });
};

const startMiniGameSession = (gameId) => {
    const configs = miniGameConfigs || {};
    const config = configs[gameId] || Object.values(configs).find(item => item.id === gameId);
    if (!config) return;
    const initialProblem = createMiniGameProblem(config, 1);
    setActiveMiniGame(config);
    setMiniGameState({ config, problem: initialProblem, stage: 1, successCount: 0, progress: 0 });
    setMiniGameAnswer('');
    setMiniGameFeedback(null);
    setGameState('miniGame');
};

const endMiniGameSession = () => {
    setActiveMiniGame(null);
    setMiniGameState(null);
    setMiniGameAnswer('');
    setMiniGameFeedback(null);
    setGameState('modeSelect');
};

const advanceMiniGame = (wasCorrect) => {
    setMiniGameState(prev => {
        if (!prev) return prev;
        const nextStage = wasCorrect ? Math.min(prev.stage + 1, 5) : Math.max(1, prev.stage - 1);
        const nextProblem = createMiniGameProblem(prev.config, nextStage);
        return {
            ...prev,
            problem: nextProblem,
            stage: nextStage,
            successCount: wasCorrect ? prev.successCount + 1 : prev.successCount,
            progress: prev.progress + 1
        };
    });
};

const submitMiniGameAnswer = (answer) => {
    if (!miniGameState || !miniGameState.problem) return;
    const expected = miniGameState.problem.answer;
    const wasCorrect = String(answer).trim() === String(expected).trim();
    updateMiniGameStats(miniGameState.config.id, wasCorrect);
    recordLanguageResult({
        subject: 'math',
        lang: language,
        isCorrect: wasCorrect,
        questionType: skillForMiniGame(miniGameState.config),
        skillKey: skillForMiniGame(miniGameState.config),
        responseTime: null
    });
    setMiniGameFeedback(wasCorrect ? t.correct : `${t.incorrect} (${expected})`);
    if (wasCorrect) {
        setMiniGameAnswer('');
    }
    advanceMiniGame(wasCorrect);
};

const handleMiniGameChoice = (option) => {
    submitMiniGameAnswer(option);
};

const openStoryBeat = (beat) => {
    if (!beat) return;
    const unlockedSet = new Set((playerStatsRef.current && playerStatsRef.current.storyBeatsUnlocked) || []);
    setStoryScene({ beat, unlocked: unlockedSet.has(beat.id) });
    setGameState('story');
};

const completeStoryBeat = (beat) => {
    if (!beat) return;
    setPlayerStats(prev => {
        const unlocked = new Set(prev.storyBeatsUnlocked || []);
        if (!unlocked.has(beat.id)) {
            unlocked.add(beat.id);
        }
        const rewardPoints = beat.id === 'finale' ? 400 : 150;
        const baseStats = {
            ...prev,
            storyBeatsUnlocked: Array.from(unlocked),
            points: prev.points + rewardPoints,
            modeHistory: [...(prev.modeHistory || []), { timestamp: Date.now(), event: 'story', id: beat.id }].slice(-120)
        };
        return finalizeProgressionStats(prev, baseStats);
    });
    setStoryScene(null);
    setGameState('modeSelect');
};

const trackQuest = (quest) => {
    if (!quest) return;
    setActiveQuest(quest);
    setCheerMessage({ type: 'encourage', text: t.questTracked || 'Quest pinned!', timestamp: Date.now() });
};

const completeQuest = (quest) => {
    if (!quest) return;
    let feedback = null;
    setPlayerStats(prev => {
        const progress = { ...(prev.questProgress || {}) };
        const existing = progress[quest.id];
        if (existing && existing.completed) {
            feedback = { type: 'info', text: t.questAlreadyCleared || 'Quest already completed.' };
            return prev;
        }
        progress[quest.id] = { completed: true, timestamp: Date.now() };
        const reward = quest.rewards || {};
        const badges = new Set(prev.badges || []);
        if (reward.badge) {
            badges.add(reward.badge);
        }
        const shopUnlocks = new Set(prev.shopUnlocks || []);
        const companions = new Set(prev.companionRoster || []);
        if (Array.isArray(reward.unlocks)) {
            reward.unlocks.forEach(token => {
                if (typeof token !== 'string') return;
                if (token.startsWith('shop:')) {
                    shopUnlocks.add(token.split(':')[1]);
                } else if (token.startsWith('companion:')) {
                    companions.add(token.split(':')[1]);
                }
            });
        }
        const candidate = {
            ...prev,
            questProgress: progress,
            points: prev.points + (reward.points || 0),
            badges: Array.from(badges),
            shopUnlocks: Array.from(shopUnlocks),
            companionRoster: Array.from(companions),
            modeHistory: [...(prev.modeHistory || []), { timestamp: Date.now(), event: 'quest', id: quest.id }].slice(-120)
        };
        const finalStats = finalizeProgressionStats(prev, candidate);
        feedback = { type: 'success', text: t.questComplete || 'Quest complete!' };
        return finalStats;
    });
    if (feedback) {
        setCheerMessage({ ...feedback, timestamp: Date.now() });
    }
    setActiveQuest(null);
};

const equipHeroItem = (slot, itemId) => {
    setPlayerStats(prev => {
        const currentLoadout = { ...(prev.heroLoadout || createDefaultPlayerStats().heroLoadout) };
        currentLoadout[slot] = itemId || null;
        return {
            ...prev,
            heroLoadout: currentLoadout,
            modeHistory: [...(prev.modeHistory || []), { timestamp: Date.now(), event: 'equip', slot, id: itemId }].slice(-120)
        };
    });
    setCheerMessage({ type: 'success', text: t.customizeEquipped || 'Equipped!', timestamp: Date.now() });
};

const purchaseItem = (item) => {
    if (!item) return;
    let feedback = null;
    setPlayerStats(prev => {
        const inventory = { ...(prev.inventory || {}) };
        if (inventory[item.id] && inventory[item.id].owned) {
            feedback = { type: 'info', text: t.alreadyOwned || 'Already owned.' };
            return prev;
        }
        if ((prev.points || 0) < item.price) {
            feedback = { type: 'error', text: t.notEnoughPoints || 'Not enough points.' };
            return prev;
        }
        const updatedInventory = { ...inventory, [item.id]: { owned: true, purchasedAt: Date.now() } };
        const candidate = {
            ...prev,
            inventory: updatedInventory,
            points: prev.points - item.price,
            shopUnlocks: Array.from(new Set([...(prev.shopUnlocks || []), item.id])),
            modeHistory: [...(prev.modeHistory || []), { timestamp: Date.now(), event: 'purchase', id: item.id }].slice(-120)
        };
        const finalStats = finalizeProgressionStats(prev, candidate);
        feedback = { type: 'success', text: t.purchaseComplete || 'Purchased!' };
        return finalStats;
    });
    if (feedback) {
        setShopFeedback({ ...feedback, timestamp: Date.now() });
    }
};

const startARMission = (mission) => {
    if (!mission) return;
    const skill = mission.skill || 'addition_carry';
    const problem = generateProblem(skill, { grade: selectedGrade, skillKey: skill });
    setActiveARMission({ mission, problem });
    setArAnswer('');
    setArFeedback(null);
    setGameState('arMission');
};

const submitARMissionAnswer = (answer) => {
    if (!activeARMission || !activeARMission.problem) return;
    const expected = String(activeARMission.problem.answer).trim();
    const wasCorrect = String(answer).trim() === expected;
    if (!wasCorrect) {
        setArFeedback(`${t.incorrect} (${expected})`);
        return;
    }
    const mission = activeARMission.mission;
    setPlayerStats(prev => {
        const completed = new Set(prev.arMissionsCompleted || []);
        completed.add(mission.id);
        const reward = mission.reward || {};
        const badges = new Set(prev.badges || []);
        if (reward.badge) {
            badges.add(reward.badge);
        }
        const candidate = {
            ...prev,
            arMissionsCompleted: Array.from(completed),
            points: prev.points + (reward.points || 0),
            badges: Array.from(badges),
            modeHistory: [...(prev.modeHistory || []), { timestamp: Date.now(), event: 'arMission', id: mission.id }].slice(-120)
        };
        return finalizeProgressionStats(prev, candidate);
    });
    setCheerMessage({ type: 'success', text: t.captureSuccess || 'Captured!', timestamp: Date.now() });
    setActiveARMission(null);
    setArAnswer('');
    setArFeedback(null);
    setGameState('modeSelect');
};

const cancelARMission = () => {
    setActiveARMission(null);
    setArAnswer('');
    setArFeedback(null);
    setGameState('modeSelect');
};

const isItemUnlocked = (item) => {
    if (!item) return true;
    const requirement = item.requirement || {};
    if (requirement.badge && !(playerStats.badges || []).includes(requirement.badge)) {
        return false;
    }
    const shopUnlocksSet = new Set(playerStats.shopUnlocks || []);
    if (shopUnlocksSet.has(item.id)) {
        return true;
    }
    const owned = playerStats.inventory && playerStats.inventory[item.id] && playerStats.inventory[item.id].owned;
    if (owned) {
        return true;
    }
    if (requirement.badge) {
        return false;
    }
    return true;
};

const openCoopMission = (scenario) => {
    if (!scenario) return;
    const skill = scenario.coreSkill || 'addition_carry';
    const problem = generateProblem(skill, { grade: selectedGrade, skillKey: skill });
    setCoopSession({ scenario, problem });
    setCoopAnswer('');
    setGameState('coop');
};

const submitCoopAnswer = (answer) => {
    if (!coopSession || !coopSession.problem) return;
    const skill = coopSession.scenario.coreSkill || 'addition_carry';
    const wasCorrect = String(answer).trim() === String(coopSession.problem.answer).trim();
    recordLanguageResult({
        subject: 'math',
        lang: language,
        isCorrect: wasCorrect,
        questionType: skill,
        skillKey: skill,
        responseTime: null
    });
    setPlayerStats(prev => ({
        ...prev,
        cooperativeRecords: [...(prev.cooperativeRecords || []), { timestamp: Date.now(), scenario: coopSession.scenario.id, success: wasCorrect }].slice(-40)
    }));
    setCoopAnswer('');
    setCoopSession(prev => prev ? { ...prev, problem: generateProblem(skill, { grade: selectedGrade, skillKey: skill }) } : prev);
    setCheerMessage({ type: wasCorrect ? 'success' : 'encourage', text: wasCorrect ? t.correct : t.incorrect, timestamp: Date.now() });
};

const openVersusMatch = (scenario) => {
    if (!scenario) return;
    const skill = scenario.coreSkill || 'even_odd';
    const problem = generateProblem(skill, { grade: selectedGrade, skillKey: skill });
    setVersusSession({ scenario, problem });
    setVersusAnswer('');
    setGameState('versus');
};

const submitVersusAnswer = (answer) => {
    if (!versusSession || !versusSession.problem) return;
    const skill = versusSession.scenario.coreSkill || 'even_odd';
    const wasCorrect = String(answer).trim() === String(versusSession.problem.answer).trim();
    recordLanguageResult({
        subject: 'math',
        lang: language,
        isCorrect: wasCorrect,
        questionType: skill,
        skillKey: skill,
        responseTime: null
    });
    setPlayerStats(prev => ({
        ...prev,
        versusRecords: [...(prev.versusRecords || []), { timestamp: Date.now(), scenario: versusSession.scenario.id, success: wasCorrect }].slice(-40)
    }));
    setVersusAnswer('');
    setVersusSession(prev => prev ? { ...prev, problem: generateProblem(skill, { grade: selectedGrade, skillKey: skill }) } : prev);
    setCheerMessage({ type: wasCorrect ? 'success' : 'encourage', text: wasCorrect ? t.correct : t.incorrect, timestamp: Date.now() });
};

const openParentDashboard = () => {
    setActiveMode('parent');
    setGameState('parentDashboard');
    setParentDashboardTab('overview');
};

const beginDungeonAdventure = () => {
    setActiveMode('dungeon');
    setTimeout(() => generateMaze(mazeSize), 50);
    setGameState('maze');
};

const CheerToast = () => {
    if (!cheerMessage) return null;
    const tone = cheerMessage.type === 'success' ? 'bg-emerald-500' : cheerMessage.type === 'encourage' ? 'bg-sky-500' : 'bg-purple-500';
    const icon = cheerMessage.type === 'success' ? 'ğŸŒŸ' : cheerMessage.type === 'encourage' ? 'ğŸ’¡' : 'ğŸ“£';
    return (
        <div className={`fixed top-6 right-6 z-50 text-white px-4 py-3 rounded-2xl shadow-xl ${tone}`}>
            <div className="flex items-center gap-2">
                <span>{icon}</span>
                <span>{cheerMessage.text}</span>
            </div>
        </div>
    );
};


    useEffect(() => {
        if (!cheerMessage) return;
        const timer = setTimeout(() => setCheerMessage(null), 3500);
        return () => clearTimeout(timer);
    }, [cheerMessage]);

    useEffect(() => {
        if (!shopFeedback) return;
        const timer = setTimeout(() => setShopFeedback(null), 3500);
        return () => clearTimeout(timer);
    }, [shopFeedback]);

    useEffect(() => {
        if (gameState !== 'kokugoQuestion') {
            stopSpeech();
        }
    }, [gameState, stopSpeech]);

    // Insect capture state
    const [selectedArea, setSelectedArea] = useState(null);
    const [currentInsect, setCurrentInsect] = useState(null);
    const [captureQuestion, setCaptureQuestion] = useState(null);
    const [captureResult, setCaptureResult] = useState(null);

    const [playerStats, setPlayerStats] = useState(() => {
        if (typeof window === 'undefined' || !window.localStorage) {
            return createDefaultPlayerStats();
        }
        try {
            const cached = window.localStorage.getItem(STORAGE_KEYS.stats);
            return cached ? normalizePlayerStats(JSON.parse(cached)) : createDefaultPlayerStats();
        } catch (error) {
            console.warn('Failed to load stats', error);
            return createDefaultPlayerStats();
        }
    });

    useEffect(() => {
        playerStatsRef.current = playerStats;
    }, [playerStats]);

    const [capturedInsects, setCapturedInsects] = useState(() => playerStats.capturedInsects || []);

    const areaInsects = {
        urawa: { insect: 'beetle' },
        omiya: { insect: 'cicada' },
        iwatsuki: { insect: 'dragonfly' }
    };

    useEffect(() => {
        setPlayerStats(prev => {
            if (prev.capturedInsects === capturedInsects) {
                return prev;
            }
            const achievements = { ...prev.achievements };
            if (!achievements.bugCatcher && capturedInsects.length >= Object.keys(areaInsects).length) {
                achievements.bugCatcher = true;
            }
            return { ...prev, capturedInsects, achievements };
        });
    }, [capturedInsects]);

    // Language selector component
    const LanguageSelector = () => (
        <div className="flex justify-center gap-2 mb-4">
            {SUPPORTED_LANGUAGES.map(code => (
                <button
                    key={code}
                    onClick={() => setLanguage(code)}
                    className={`px-3 py-1 rounded text-sm font-bold transition-all ${language === code ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' : 'bg-gray-300 hover:bg-gray-400'}`}
                >
                    {LANGUAGE_LABELS[code] || code.toUpperCase()}
                </button>
            ))}
        </div>
    );


// Save language preference
    useEffect(() => {
        i18n.persistLanguage(language);
    }, [i18n, language]);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.localStorage) {
            window.localStorage.setItem(STORAGE_KEYS.learningLanguage, learningLanguage);
        }
    }, [learningLanguage]);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.localStorage) {
            try {
                window.localStorage.setItem(STORAGE_KEYS.stats, JSON.stringify(playerStats));
            } catch (error) {
                console.warn('Failed to save stats', error);
            }
        }
    }, [playerStats]);

    
const recordLanguageResult = ({ subject, lang, isCorrect, questionType, skillKey, responseTime }) => {
    const subjectKey = subject === 'kokugo' ? 'kokugo' : 'math';
    const targetLang = SUPPORTED_LANGUAGES.includes(lang) ? lang : SUPPORTED_LANGUAGES[0];
    const skill = skillKey || questionType || 'general';

    setPlayerStats(prev => {
        const languageStats = { ...prev.languageStats };
        const subjectStats = { ...languageStats[subjectKey] };
        const currentStats = subjectStats[targetLang] ? { ...subjectStats[targetLang] } : {
            answered: 0,
            correct: 0,
            comprehensionAnswered: 0,
            comprehensionCorrect: 0,
            streak: 0
        };

        currentStats.answered += 1;
        if (isCorrect) {
            currentStats.correct += 1;
            currentStats.streak = (currentStats.streak || 0) + 1;
        } else {
            currentStats.streak = 0;
        }
        if (subjectKey === 'kokugo' && questionType === 'comprehension') {
            currentStats.comprehensionAnswered += 1;
            if (isCorrect) {
                currentStats.comprehensionCorrect += 1;
            }
        }
        subjectStats[targetLang] = currentStats;
        languageStats[subjectKey] = subjectStats;

        const skillMastery = { ...prev.skillMastery };
        const masteryEntry = skillMastery[skill] ? { ...skillMastery[skill] } : {
            answered: 0,
            correct: 0,
            streak: 0,
            accuracy: 0,
            level: 1
        };
        masteryEntry.answered += 1;
        if (isCorrect) {
            masteryEntry.correct += 1;
            masteryEntry.streak = (masteryEntry.streak || 0) + 1;
        } else {
            masteryEntry.streak = 0;
        }
        masteryEntry.accuracy = masteryEntry.correct / Math.max(1, masteryEntry.answered);
        if (isCorrect && masteryEntry.streak >= 5 && masteryEntry.accuracy >= 0.8) {
            masteryEntry.level = Math.min((masteryEntry.level || 1) + 1, 5);
        } else if (!isCorrect && masteryEntry.accuracy < 0.5) {
            masteryEntry.level = Math.max((masteryEntry.level || 1) - 1, 1);
        }
        skillMastery[skill] = masteryEntry;

        const pointsGain = isCorrect ? 20 + (masteryEntry.level || 1) * 2 : Math.max(1, Math.floor((masteryEntry.level || 1) / 2));
        const experienceGain = isCorrect ? 15 + (masteryEntry.level || 1) : 5;

        let experience = prev.experience + experienceGain;
        let level = prev.level;
        let nextLevelExp = prev.nextLevelExp;
        const levelUps = [];
        while (experience >= nextLevelExp) {
            experience -= nextLevelExp;
            level += 1;
            levelUps.push(level);
            nextLevelExp = Math.round(nextLevelExp * 1.35);
        }

        const updatedStats = {
            ...prev,
            languageStats,
            skillMastery,
            points: prev.points + pointsGain,
            experience,
            level,
            nextLevelExp,
            totalQuestionsAnswered: prev.totalQuestionsAnswered + 1,
            correctAnswers: prev.correctAnswers + (isCorrect ? 1 : 0)
        };

        const historyEntry = { timestamp: Date.now(), event: 'question', subject: subjectKey, skill, correct: isCorrect, responseTime };
        const priorHistory = Array.isArray(prev.modeHistory) ? prev.modeHistory : [];
        if (levelUps.length > 0) {
            updatedStats.modeHistory = [...priorHistory, { timestamp: Date.now(), event: 'levelUp', levels: levelUps }].slice(-120);
        } else {
            updatedStats.modeHistory = [...priorHistory, historyEntry].slice(-120);
        }

        const now = new Date();
        const weekKey = `${now.getFullYear()}-W${Math.ceil((now.getDate() + now.getDay()) / 7)}`;
        const existingWeeks = Array.isArray(prev.weeklyProgress) ? prev.weeklyProgress : [];
        const weeklyMap = new Map(existingWeeks.map(entry => [entry.week, { ...entry }]));
        const currentWeek = weeklyMap.get(weekKey) || { week: weekKey, answered: 0, correct: 0, points: 0 };
        currentWeek.answered += 1;
        if (isCorrect) currentWeek.correct += 1;
        currentWeek.points += pointsGain;
        weeklyMap.set(weekKey, currentWeek);
        updatedStats.weeklyProgress = Array.from(weeklyMap.values()).slice(-12);

        if (subjectKey === 'kokugo') {
            const achievements = { ...updatedStats.achievements };
            const compAnswered = currentStats.comprehensionAnswered;
            const compCorrect = currentStats.comprehensionCorrect;
            if (!achievements.langNovice && currentStats.correct >= 5) achievements.langNovice = true;
            if (!achievements.readingChamp && compCorrect >= 3 && compAnswered > 0 && Math.round((compCorrect / Math.max(1, compAnswered)) * 100) >= 70) {
                achievements.readingChamp = true;
            }
            updatedStats.achievements = achievements;
        }

        return finalizeProgressionStats(prev, updatedStats);
    });

    const tutorProfile = aiTutorProfiles[playerStats.tutorProfile] || aiTutorProfiles.adaptiveCoach || {};
    const encouragementPool = isCorrect
        ? (tutorProfile.cheers && tutorProfile.cheers.correct) || (tutorProfile.behaviors && tutorProfile.behaviors.encouragement)
        : (tutorProfile.cheers && tutorProfile.cheers.incorrect) || (tutorProfile.behaviors && tutorProfile.behaviors.encouragement);
    if (encouragementPool && encouragementPool.length > 0) {
        const message = encouragementPool[Math.floor(Math.random() * encouragementPool.length)];
        setCheerMessage({ type: isCorrect ? 'success' : 'encourage', text: message, timestamp: Date.now() });
    }

    setAiCoachLog(prev => {
        const history = Array.isArray(prev) ? prev : [];
        return [...history.slice(-9), { timestamp: Date.now(), skill: skillKey || questionType, isCorrect, responseTime }];
    });
};

// Generate maze
    // Generate maze
    const generateMaze = useCallback((size) => {
        const newMaze = Array(size).fill().map(() => Array(size).fill(0));

        // Add walls (random but avoid start/goal)
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if (Math.random() < 0.2 && !(x === 0 && y === 0) && !(x === size - 1 && y === size - 1)) {
                    newMaze[y][x] = 1;
                }
            }
        }

        // Ensure start and goal
        newMaze[0][0] = 0;
        newMaze[size - 1][size - 1] = 2;

        // Carve a simple path
        for (let i = 0; i < size - 1; i++) {
            if (Math.random() < 0.5) {
                newMaze[i][i] = 0;
                newMaze[i][i + 1] = 0;
            } else {
                newMaze[i][i] = 0;
                newMaze[i + 1][i] = 0;
            }
        }

        const gates = [];
        const bosses = [];
        if (currentLevel > 3 && size >= 7) {
            const gateY = size - 2;
            const gateX = size - 1;
            if (newMaze[gateY][gateX] === 0) {
                newMaze[gateY][gateX] = 3; // gate
                gates.push({ x: gateX, y: gateY, id: 'gate-1' });
            }
        }

        // Place monsters by grade
        const monsterTypes = getMonsterTypes();
        const gradeMonsters = monsterTypes.filter(m => m.grade === selectedGrade);
        const normalMonsters = gradeMonsters.filter(m => !m.isBoss);
        const bossMonsters = gradeMonsters.filter(m => m.isBoss);

        const monsters = [];

        // Boss placement (if gate present)
        if (gates.length > 0 && bossMonsters.length > 0) {
            let bossPlaced = false;
            for (let attempts = 0; attempts < 50 && !bossPlaced; attempts++) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const y = Math.floor(Math.random() * (size - 2)) + 1;
                if (newMaze[y][x] === 0 && !(x === 0 && y === 0) && !(x === size - 1 && y === size - 1)) {
                    const bossType = bossMonsters[Math.floor(Math.random() * bossMonsters.length)];
                    monsters.push({ x, y, type: bossType, id: `boss-${gates[0].id}`, isBoss: true });
                    bosses.push(`boss-${gates[0].id}`);
                    bossPlaced = true;
                }
            }
        }

        // Normal monsters
        const monsterCount = Math.min(Math.floor(size / 2), 4);
        for (let i = 0; i < monsterCount; i++) {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 50) {
                const x = Math.floor(Math.random() * size);
                const y = Math.floor(Math.random() * size);
                if (newMaze[y][x] === 0 && !(x === 0 && y === 0) && !(x === size - 1 && y === size - 1) &&
                    !monsters.some(m => m.x === x && m.y === y)) {
                    const monsterType = normalMonsters[Math.floor(Math.random() * normalMonsters.length)];
                    monsters.push({ x, y, type: monsterType, id: `monster-${i}`, isBoss: false });
                    placed = true;
                }
                attempts++;
            }
        }

        setMaze(newMaze);
        setMonsterPositions(monsters);
        setBossGates(gates);
        setRequiredBosses(bosses);
        setPlayerPosition({ x: 0, y: 0 });
        setDefeatedMonsters([]);
    }, [currentLevel, selectedGrade, getMonsterTypes]);

    // Problem generator
    
const generateProblem = useCallback((type, overrides = {}) => {
    const grade = overrides.grade || selectedGrade;
    const skillKey = overrides.skillKey || overrides.skill || type;
    const mastery = playerStats.skillMastery && playerStats.skillMastery[skillKey];
    const stage = overrides.stage || (mastery && mastery.level ? mastery.level : 1);
    const clampStage = Math.max(1, Math.min(stage, 5));

    const randBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const shuffle = (arr) => arr.map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(item => item.value);
    const numericOptions = (correct, spread, minVal) => {
        const options = new Set();
        options.add(correct);
        while (options.size < 4) {
            const delta = randBetween(1, spread);
            const candidate = Math.max(minVal, correct + (Math.random() > 0.5 ? delta : -delta));
            options.add(candidate);
        }
        return shuffle(Array.from(options));
    };
    const formatTimeLabel = (hour, minute) => `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    const parityLabels = [t.evenLabel || 'Even', t.oddLabel || 'Odd', t.parityBoth || 'Both', t.parityNeither || 'Neither'];

    let problem = { question: '0 + 0 = ?', answer: 0, options: [0, 1, 2, 3], hint: '', skill: skillKey };

    switch (type) {
        case 'addition':
        case 'addition_carry': {
            const maxValue = grade === 2 ? (clampStage >= 3 ? 99 : 60) : 150;
            let a = randBetween(10, maxValue);
            let b = randBetween(10, maxValue);
            if (type === 'addition_carry') {
                while ((a % 10) + (b % 10) < 10) {
                    a = randBetween(10, maxValue);
                    b = randBetween(10, maxValue);
                }
            }
            const answer = a + b;
            problem = {
                question: `${a} + ${b} = ?`,
                answer,
                options: numericOptions(answer, 15, 0),
                hint: type === 'addition_carry' ? (t.additionCarryHint || t.whichBigger) : `${a} + ${b} = ?`,
                skill: skillKey
            };
            break;
        }
        case 'subtraction':
        case 'subtraction_borrow': {
            const maxValue = grade === 2 ? (clampStage >= 3 ? 120 : 80) : 150;
            let minuend = randBetween(30, maxValue);
            let subtrahend = randBetween(5, minuend - 5);
            if (type === 'subtraction_borrow') {
                while ((minuend % 10) >= (subtrahend % 10)) {
                    minuend = randBetween(30, maxValue);
                    subtrahend = randBetween(5, minuend - 5);
                }
            }
            const answer = minuend - subtrahend;
            problem = {
                question: `${minuend} - ${subtrahend} = ?`,
                answer,
                options: numericOptions(answer, 12, 0),
                hint: type === 'subtraction_borrow' ? (t.subtractionBorrowHint || `${minuend} - ${subtrahend}`) : `${minuend} - ${subtrahend} = ?`,
                skill: skillKey
            };
            break;
        }
        case 'comparison': {
            let num1 = randBetween(10, clampStage >= 3 ? 150 : 90);
            let num2 = randBetween(10, clampStage >= 3 ? 150 : 90);
            while (num1 === num2) num2 = randBetween(10, clampStage >= 3 ? 150 : 90);
            const bigger = num1 > num2 ? num1 : num2;
            problem = {
                question: `${t.whichBigger} ${num1} vs ${num2}`,
                answer: bigger,
                options: shuffle([num1, num2, bigger + randBetween(1, 5), Math.max(0, bigger - randBetween(1, 5))]),
                hint: t.comparisonHint || t.whichBigger,
                skill: skillKey
            };
            break;
        }
        case 'clock_reading': {
            const step = clampStage >= 3 ? 5 : clampStage === 2 ? 10 : 15;
            const hour = randBetween(1, 12);
            const minute = randBetween(0, Math.floor(60 / step) - 1) * step;
            const answer = formatTimeLabel(hour, minute);
            const distractors = [
                formatTimeLabel(((hour + randBetween(1, 5) - 1) % 12) + 1, minute),
                formatTimeLabel(hour === 12 ? 1 : hour + 1, minute),
                formatTimeLabel(hour, (minute + step) % 60)
            ];
            problem = {
                question: `${(t.clockMatchPrompt || 'Clock Challenge')}: ${answer}`,
                answer,
                options: shuffle([answer, distractors[0], distractors[1], distractors[2]]),
                hint: t.clockHint || 'Look at the hour and minute hands.',
                skill: skillKey,
                meta: { hour, minute }
            };
            break;
        }
        case 'money_counting': {
            const coinSet = grade === 2 ? [1, 5, 10, 50, 100] : [1, 5, 10, 50, 100, 500];
            const itemCount = randBetween(3, 3 + clampStage);
            const coins = [];
            for (let i = 0; i < itemCount; i += 1) {
                coins.push(coinSet[randBetween(0, coinSet.length - 1)]);
            }
            const answer = coins.reduce((sum, value) => sum + value, 0);
            problem = {
                question: (t.coinGamePrompt || '{expression} = ?').replace('{expression}', coins.map(value => `${t.currencySymbol || 'Â¥'}${value}`).join(' + ')),
                answer,
                options: numericOptions(answer, 30, 0),
                hint: t.coinHint || 'Add each coin value.',
                skill: skillKey,
                meta: { coins }
            };
            break;
        }
        case 'even_odd': {
            const number = randBetween(10, 120 + clampStage * 10);
            const parityText = number % 2 === 0 ? parityLabels[0] : parityLabels[1];
            const translations = {
                ja: `${number}ã¯å¶æ•°ï¼Ÿå¥‡æ•°ï¼Ÿ`,
                en: `${number} is even or odd?`,
                fr: `${number} est pair ou impair ?`,
                zh: `${number} æ˜¯å¶æ•°è¿˜æ˜¯å¥‡æ•°ï¼Ÿ`
            };
            const prompt = translations[language] || translations.en;
            problem = {
                question: prompt,
                answer: parityText,
                options: parityLabels,
                hint: t.evenOddHint || 'Check the ones digit.',
                skill: skillKey,
                meta: { number }
            };
            break;
        }
        case 'multiplication':
        case 'multiplication_array': {
            const a = randBetween(2, clampStage >= 3 ? 12 : 9);
            const b = randBetween(2, clampStage >= 3 ? 12 : 9);
            const answer = a * b;
            problem = {
                question: `${a} Ã— ${b} = ?`,
                answer,
                options: numericOptions(answer, 20, 1),
                hint: t.arrayHint || 'Use rows and columns.',
                skill: skillKey,
                meta: { rows: a, cols: b }
            };
            break;
        }
        case 'division':
        case 'division_basic': {
            const divisor = randBetween(2, clampStage >= 3 ? 12 : 9);
            const quotient = randBetween(2, clampStage >= 3 ? 12 : 9);
            const dividend = divisor * quotient;
            problem = {
                question: `${dividend} Ã· ${divisor} = ?`,
                answer: quotient,
                options: numericOptions(quotient, 8, 1),
                hint: t.divisionHint || 'Division undoes multiplication.',
                skill: skillKey
            };
            break;
        }
        case 'word_problem': {
            const children = randBetween(2, 4 + clampStage);
            const perChild = randBetween(2 + clampStage, 5 + clampStage);
            const total = children * perChild;
            const prompts = {
                ja: `${total}å€‹ã®ãŠã‹ã—ã‚’${children}äººã§åŒã˜æ•°ãšã¤åˆ†ã‘ã¾ã™ã€‚1äººã‚ãŸã‚Šã¯ã„ãã¤ï¼Ÿ`,
                en: `Share ${total} snacks equally among ${children} kids. How many per kid?`,
                fr: `On partage ${total} friandises entre ${children} enfants. Combien chacun ?`,
                zh: `${total}ä¸ªç‚¹å¿ƒå¹³å‡åˆ†ç»™${children}ä¸ªå­©å­ã€‚æ¯äººå¾—åˆ°å¤šå°‘ï¼Ÿ`
            };
            const prompt = prompts[language] || prompts.en;
            problem = {
                question: prompt,
                answer: perChild,
                options: numericOptions(perChild, 8, 1),
                hint: t.wordProblemHint || 'Build the equation from the story.',
                skill: skillKey,
                meta: { total, children }
            };
            break;
        }
        case 'unit_conversion': {
            const conversions = [
                { from: 'm', to: 'cm', factor: 100, base: randBetween(2, 6 + clampStage) },
                { from: 'kg', to: 'g', factor: 1000, base: randBetween(1, 4 + clampStage) },
                { from: 'L', to: 'mL', factor: 1000, base: randBetween(1, 3 + clampStage) },
                { from: 'min', to: 's', factor: 60, base: randBetween(2, 6 + clampStage) }
            ];
            const choice = conversions[randBetween(0, conversions.length - 1)];
            const answer = choice.base * choice.factor;
            problem = {
                question: `${t.unitConversionPrompt || 'Convert the unit:'} ${choice.base} ${choice.from} â†’ ? ${choice.to}`,
                answer,
                options: numericOptions(answer, choice.factor, choice.factor),
                hint: t.unitConversionHint || 'Multiply by the conversion factor.',
                skill: skillKey,
                meta: choice
            };
            break;
        }
        case 'data_reading': {
            const dataset = [
                { label: t.dataLabelA || 'A', value: randBetween(10, 25) },
                { label: t.dataLabelB || 'B', value: randBetween(10, 25) },
                { label: t.dataLabelC || 'C', value: randBetween(10, 25) }
            ];
            const shuffled = shuffle(dataset);
            const best = shuffled.reduce((previous, current) => (current.value > previous.value ? current : previous), shuffled[0]);
            problem = {
                question: `${t.dataReadingPrompt || 'Which is the greatest value?'} ${shuffled.map(item => `${item.label}:${item.value}`).join(' / ')}`,
                answer: best.label,
                options: shuffle(shuffled.map(item => item.label)),
                hint: t.dataReadingHint || 'Compare the numbers carefully.',
                skill: skillKey,
                meta: { dataset: shuffled }
            };
            break;
        }
        default:
            break;
    }

    return problem;
}, [selectedGrade, playerStats.skillMastery, t, language]);
    // Options helper
    const generateOptions = (correctAnswer, min, max) => {
        const options = [correctAnswer];
        while (options.length < 4) {
            const option = Math.floor(Math.random() * (max - min + 1)) + min;
            if (!options.includes(option)) options.push(option);
        }
        return options.sort(() => Math.random() - 0.5);
    };

    // Move player
    const movePlayer = useCallback((direction) => {
        if (gameState !== 'maze') return;

        const newPos = { ...playerPosition };
        if (direction === 'up' && newPos.y > 0) newPos.y--;
        if (direction === 'down' && newPos.y < mazeSize - 1) newPos.y++;
        if (direction === 'left' && newPos.x > 0) newPos.x--;
        if (direction === 'right' && newPos.x < mazeSize - 1) newPos.x++;

        // Wall
        if (maze[newPos.y] && maze[newPos.y][newPos.x] === 1) {
            setMessage(t.wall);
            setTimeout(() => setMessage(''), 2000);
            return;
        }

        // Gate
        if (maze[newPos.y] && maze[newPos.y][newPos.x] === 3) {
            const gate = bossGates.find(g => g.x === newPos.x && g.y === newPos.y);
            if (gate) {
                const requiredBossDefeated = requiredBosses.every(bossId => defeatedMonsters.includes(bossId));
                if (!requiredBossDefeated) {
                    setMessage('âš ï¸ ' + t.gateBlocked);
                    setTimeout(() => setMessage(''), 3000);
                    return;
                } else {
                    const newMaze = maze.map(row => row.slice());
                    newMaze[newPos.y][newPos.x] = 0;
                    setMaze(newMaze);
                    setMessage('âœ¨ ' + t.gateOpened);
                    setTimeout(() => setMessage(''), 2000);
                }
            }
        }

        setPlayerPosition(newPos);

        // Goal
        if (newPos.x === mazeSize - 1 && newPos.y === mazeSize - 1) {
            handleLevelClear();
            return;
        }

        // Monster encounter
        const monster = monsterPositions.find(m => m.x === newPos.x && m.y === newPos.y && !defeatedMonsters.includes(m.id));
        if (monster) startBattle(monster);
    }, [gameState, playerPosition, maze, mazeSize, bossGates, requiredBosses, defeatedMonsters, monsterPositions, t]);

    // Start battle
    const startBattle = (monster) => {
        setMessage('');
        setCurrentMonster(monster);
        const monsterHealth = monster.type.health || (monster.isBoss ? 5 : 3);
        setBattleState({
            monsterHealth,
            maxHealth: monsterHealth,
            currentProblem: generateProblem(monster.type.problemType, { grade: selectedGrade, skillKey: monster.type.problemType, stage: 1 }),
            stage: 1
        });
        setShowHint(false);
        setTimeLeft(monster.isBoss ? 45 : 30);
        setGameState('battle');
    };

    // Handle level clear
    const handleLevelClear = () => {
        setGameState('victory');
        setMessage(`${t.congratulations} ${t.level} ${currentLevel} ${t.clearMessage}`);

        const newBadges = [];
        if (currentLevel === 1 && !playerStats.badges.includes('first_clear')) newBadges.push('first_clear');
        if (defeatedMonsters.length === monsterPositions.length && !playerStats.badges.includes('perfect_clear')) newBadges.push('perfect_clear');
        if (selectedGrade === 3 && !playerStats.badges.includes('multiplication_master')) newBadges.push('multiplication_master');

        if (newBadges.length > 0) {
            setPlayerStats(prev => ({ ...prev, badges: [...prev.badges, ...newBadges] }));
        }
    };

    // Check answer in battle
    
const checkAnswer = (answer) => {
    if (!battleState || !battleState.currentProblem) return;
    setShowHint(false);

    const skill = battleState.currentProblem.skill || (currentMonster ? currentMonster.type.problemType : 'math');
    const baseTime = currentMonster && currentMonster.isBoss ? 45 : 30;
    const responseTime = baseTime - timeLeft;
    const isCorrect = answer === battleState.currentProblem.answer;

    recordLanguageResult({
        subject: 'math',
        lang: language,
        isCorrect,
        questionType: currentMonster ? currentMonster.type.problemType : null,
        skillKey: skill,
        responseTime
    });

    if (isCorrect) {
        setMessage(t.correct);
        const newHealth = battleState.monsterHealth - 1;
        setPlayerStats(prev => ({ ...prev, totalQuestionsAnswered: prev.totalQuestionsAnswered + 1, correctAnswers: prev.correctAnswers + 1 }));
        if (newHealth <= 0) {
            setDefeatedMonsters(prev => [...prev, currentMonster.id]);
            setPlayerStats(prev => {
                const unlocked = prev.unlockedMonsters.includes(currentMonster.type.id)
                    ? prev.unlockedMonsters
                    : [...prev.unlockedMonsters, currentMonster.type.id];
                const battleBonus = currentMonster.isBoss ? 120 : 60;
                return {
                    ...prev,
                    totalMonstersDefeated: prev.totalMonstersDefeated + 1,
                    unlockedMonsters: unlocked,
                    points: prev.points + battleBonus
                };
            });

            if (currentMonster.isBoss) {
                setMessage(`âœ¨ ${t.boss} ${currentMonster.type.name}${t.monsterDefeated}${t.bossDefeated}`);
            } else {
                setMessage(`${currentMonster.type.name}${t.monsterDefeated}`);
            }

            setTimeout(() => {
                setGameState('maze');
                setMessage('');
            }, 2400);
        } else {
            const nextStage = Math.min((battleState.stage || 1) + 1, 5);
            setBattleState({
                monsterHealth: newHealth,
                maxHealth: battleState.maxHealth,
                currentProblem: generateProblem(currentMonster.type.problemType, { grade: selectedGrade, skillKey: skill, stage: nextStage }),
                stage: nextStage
            });
            setTimeLeft(baseTime);
            setTimeout(() => setMessage(''), 1200);
        }
    } else {
        setMessage(t.incorrect);
        setPlayerStats(prev => ({ ...prev, totalQuestionsAnswered: prev.totalQuestionsAnswered + 1 }));
        setTimeout(() => {
            setMessage('');
            setBattleState(prev => {
                if (!prev) return prev;
                const previousStage = prev.stage || 1;
                const nextStage = Math.max(1, previousStage - 1);
                const fallbackSkill = currentMonster ? currentMonster.type.problemType : 'math';
                const nextSkill = prev.currentProblem && prev.currentProblem.skill ? prev.currentProblem.skill : fallbackSkill;
                return {
                    ...prev,
                    currentProblem: generateProblem(currentMonster.type.problemType, { grade: selectedGrade, skillKey: nextSkill, stage: nextStage }),
                    stage: nextStage
                };
            });
            setTimeLeft(baseTime);
        }, 1200);
    }
};

// Timer for battle
    // Timer for battle
    useEffect(() => {
        if (gameState === 'battle' && timeLeft > 0) {
            const timer = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);
            return () => clearTimeout(timer);
        } else if (gameState === 'battle' && timeLeft === 0) {
            setMessage(t.timeUp);
            setTimeout(() => {
                if (currentMonster && battleState) {
                    setBattleState(prev => {
                    if (!prev) return prev;
                    const previousStage = prev.stage || 1;
                    const nextStage = Math.max(1, previousStage - 1);
                    const fallbackSkill = currentMonster ? currentMonster.type.problemType : 'math';
                    const nextSkill = prev.currentProblem && prev.currentProblem.skill ? prev.currentProblem.skill : fallbackSkill;
                    return {
                        ...prev,
                        currentProblem: generateProblem(currentMonster.type.problemType, { grade: selectedGrade, skillKey: nextSkill, stage: nextStage }),
                        stage: nextStage
                    };
                });
                    setTimeLeft(currentMonster.isBoss ? 45 : 30);
                    setShowHint(false);
                }
                setMessage('');
            }, 2000);
        }
    }, [timeLeft, gameState, currentMonster, battleState, generateProblem, t.timeUp]);

    // Keyboard controls
    useEffect(() => {
        const handleKeyPress = (e) => {
            if (gameState !== 'maze') return;
            if (e.key === 'ArrowUp') movePlayer('up');
            if (e.key === 'ArrowDown') movePlayer('down');
            if (e.key === 'ArrowLeft') movePlayer('left');
            if (e.key === 'ArrowRight') movePlayer('right');
        };
        window.addEventListener('keydown', handleKeyPress);
        return () => window.removeEventListener('keydown', handleKeyPress);
    }, [movePlayer, gameState]);

    // Start game
    const startGameWithGrade = (grade) => {
        setSelectedSubject('math');
        setSelectedGrade(grade);
        setCurrentLevel(1);
        setMazeSize(5);
        setTimeout(() => generateMaze(5), 100);
        setGameState('maze');
    };

    const nextLevel = () => {
        const newLevel = currentLevel + 1;
        const newSize = Math.min(5 + Math.floor(newLevel / 2), 9);
        setCurrentLevel(newLevel);
        setMazeSize(newSize);
        setTimeout(() => generateMaze(newSize), 100);
        setGameState('maze');
    };

    // Insect capture handlers
    const startCapture = (insectKey) => {
        setCurrentInsect(insectKey);
        setCaptureQuestion(generateProblem('addition'));
        setCaptureResult(null);
        setGameState('insectQuiz');
    };

    const checkCaptureAnswer = (answer) => {
        if (!captureQuestion) return;
        if (answer === captureQuestion.answer) {
            setCaptureResult('success');
            if (currentInsect && !capturedInsects.includes(currentInsect)) {
                setCapturedInsects(prev => [...prev, currentInsect]);
            }
        } else {
            setCaptureResult('fail');
        }
    };

    const toggleKokugoType = (type) => {
        setKokugoTypes(prev => {
            const next = new Set(prev);
            if (next.has(type)) {
                if (next.size > 1) {
                    next.delete(type);
                }
            } else {
                next.add(type);
            }
            return next;
        });
    };

    const swapLanguages = () => {
        const currentLearning = learningLanguage;
        const currentUi = language;
        setLearningLanguage(currentUi);
        setLanguage(currentLearning);
    };

    const startKokugoSession = () => {
        const selectedTypes = Array.from(kokugoTypes);
        const availableQuestions = questionManager
            .loadQuestions({ grade: kokugoGrade, subject: 'kokugo', lang: learningLanguage })
            .filter(item => (!kokugoDifficulty || item.difficulty === kokugoDifficulty) && selectedTypes.includes(item.type));
        if (availableQuestions.length === 0) {
            setKokugoFeedback({ type: 'error', message: t.kokugoNoQuestions || t.notFound });
            return;
        }

        const total = Math.min(maxKokugoQuestions, availableQuestions.length);
        const first = buildKokugoQuestion({
            grade: kokugoGrade,
            difficulty: kokugoDifficulty,
            lang: learningLanguage,
            supportLang: language,
            questionTypes: selectedTypes,
            excludeIds: []
        });
        if (!first) {
            setKokugoFeedback({ type: 'error', message: t.kokugoNoQuestions || t.notFound });
            return;
        }

        stopSpeech();
        setSelectedSubject('kokugo');
        setKokugoHistory([]);
        setKokugoAnswer('');
        setKokugoHintVisible(false);
        setKokugoFeedback(null);
        setKokugoSession({
            grade: kokugoGrade,
            difficulty: kokugoDifficulty,
            questionTypes: selectedTypes,
            lang: learningLanguage,
            supportLang: language,
            index: 0,
            total,
            current: first,
            usedIds: [first.question.id]
        });
        setGameState('kokugoQuestion');
    };

    const handleKokugoAnswer = (choice) => {
        if (!kokugoSession || !kokugoSession.current || kokugoAnswer !== '') {
            return;
        }
        const { question, support, revealedHints } = kokugoSession.current;
        const selectedValue = typeof choice === 'string' ? choice : String(choice);
        const answerValue = typeof question.answer === 'string' ? question.answer : String(question.answer);
        const isCorrect = selectedValue === answerValue;
        setKokugoAnswer(selectedValue);
        setKokugoFeedback({ type: isCorrect ? 'success' : 'error', message: isCorrect ? t.correct : t.incorrect });
        setKokugoSession(prev => (prev ? { ...prev, current: { ...prev.current, attempts: prev.current.attempts + 1, isCorrect } } : prev));
        setKokugoHistory(prev => ([...prev, {
            id: question.id,
            prompt: question.prompt,
            answer: question.answer,
            selected: selectedValue,
            isCorrect,
            explanation: question.explanation,
            support,
            hintsUsed: revealedHints || 0,
            type: question.type
        }]));
        setPlayerStats(prev => ({
            ...prev,
            totalQuestionsAnswered: prev.totalQuestionsAnswered + 1,
            correctAnswers: prev.correctAnswers + (isCorrect ? 1 : 0)
        }));
        recordLanguageResult({ subject: 'kokugo', lang: kokugoSession.lang, isCorrect, questionType: question.type, skillKey: question.type, responseTime: null });
        stopSpeech();
    };

    const goToNextKokugoQuestion = () => {
        if (!kokugoSession) {
            setGameState('kokugoSummary');
            return;
        }

        const nextIndex = kokugoSession.index + 1;
        const excludeIds = Array.isArray(kokugoSession.usedIds) ? [...kokugoSession.usedIds] : [];
        let nextStep = null;
        let shouldEnd = nextIndex >= kokugoSession.total;

        if (!shouldEnd) {
            nextStep = buildKokugoQuestion({
                grade: kokugoSession.grade,
                difficulty: kokugoSession.difficulty,
                lang: kokugoSession.lang,
                supportLang: kokugoSession.supportLang,
                questionTypes: kokugoSession.questionTypes,
                excludeIds
            });
            if (!nextStep) {
                shouldEnd = true;
            }
        }

        setKokugoSession(prev => {
            if (!prev) {
                return prev;
            }
            if (shouldEnd) {
                return { ...prev, index: nextIndex, current: null };
            }
            return {
                ...prev,
                index: nextIndex,
                current: nextStep,
                usedIds: [...excludeIds, nextStep.question.id]
            };
        });

        setKokugoAnswer('');
        setKokugoHintVisible(false);
        setKokugoFeedback(null);
        stopSpeech();

        if (shouldEnd) {
            setGameState('kokugoSummary');
        }
    };

    const showNextKokugoHint = () => {
        if (!kokugoSession || !kokugoSession.current) {
            return;
        }
        setKokugoSession(prev => {
            if (!prev || !prev.current) {
                return prev;
            }
            const hintsList = prev.current.question.hints || [];
            const revealed = prev.current.revealedHints || 0;
            if (revealed >= hintsList.length) {
                return prev;
            }
            return {
                ...prev,
                current: {
                    ...prev.current,
                    revealedHints: revealed + 1
                }
            };
        });
        setKokugoHintVisible(true);
    };

    const hideKokugoHints = () => {
        setKokugoHintVisible(false);
    };


    // UI rendering by gameState
    if (gameState === 'menu') {
        return (
            <div className="min-h-screen bg-gradient-to-br from-purple-900 to-pink-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h1 className="text-5xl font-bold text-center mb-6 text-purple-600">ğŸ® {t.gameTitle} ğŸ®</h1>
                    <div className="text-center mb-8">
                        <p className="text-2xl mb-4 text-purple-700">{t.becomeHero}</p>
                        <p className="text-2xl text-pink-700">{t.conquerDungeon}</p>
                    </div>
                    <div className="flex flex-col gap-4">
                        <button onClick={() => { setSelectedSubject('math'); setGameState('subjectSelect'); }} className="bg-gradient-to-r from-green-500 to-blue-500 text-white text-2xl font-bold py-4 rounded-2xl hover:from-green-600 hover:to-blue-600 transform hover:scale-105 transition-all">
                            âš”ï¸ {t.startGame} âš”ï¸
                        </button>
                        <button onClick={() => setGameState('map')} className="bg-gradient-to-r from-lime-500 to-green-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-lime-600 hover:to-green-600">
                            ğŸ—ºï¸ {t.insectMission}
                        </button>
                        <button onClick={() => setGameState('stats')} className="bg-gradient-to-r from-purple-500 to-pink-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-purple-600 hover:to-pink-600">
                            ğŸ† {t.stats}
                        </button>
                        <button onClick={() => setGameState('dictionary')} className="bg-gradient-to-r from-orange-500 to-red-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-orange-600 hover:to-red-600">
                            ğŸ“– {t.dictionary}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'subjectSelect') {

        return (

            <div className="min-h-screen bg-gradient-to-br from-purple-900 via-indigo-900 to-blue-900 flex items-center justify-center p-4">

                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-3xl w-full">

                    <LanguageSelector />

                    <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">ğŸ§­ {t.subjectSelect} ğŸ§­</h2>

                    <div className="grid md:grid-cols-2 gap-6">

                        <button onClick={() => { setSelectedSubject('math'); setGameState('gradeSelect'); }} className="bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl p-6 text-white hover:from-blue-600 hover:to-cyan-600 transform hover:scale-105 transition-all">

                            <div className="text-5xl mb-4">ğŸ§®</div>

                            <h3 className="text-2xl font-bold mb-2">{t.subjectMath}</h3>

                            <p className="text-sm opacity-90">{t.subjectMathDescription}</p>

                        </button>

                        <button onClick={() => { setSelectedSubject('kokugo'); setGameState('kokugoSetup'); }} className="bg-gradient-to-br from-rose-500 to-orange-500 rounded-2xl p-6 text-white hover:from-rose-600 hover:to-orange-600 transform hover:scale-105 transition-all">

                            <div className="text-5xl mb-4">ğŸˆ¶</div>

                            <h3 className="text-2xl font-bold mb-2">{t.subjectKokugo}</h3>

                            <p className="text-sm opacity-90">{t.subjectKokugoDescription}</p>

                        </button>

                    </div>

                    <div className="mt-6 text-center">

                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>

                    </div>

                </div>

            </div>

        );

    }



    if (gameState === 'kokugoSetup') {

        const difficultyLabels = {

            easy: t.difficultyEasy,

            normal: t.difficultyNormal,

            hard: t.difficultyHard

        };

        const typeLabels = {

            reading: t.questionTypeReading,

            kanji: t.questionTypeKanji,

            vocab: t.questionTypeVocab,

            comprehension: t.questionTypeComprehension,

            grammar: t.questionTypeGrammar

        };



        return (

            <div className="min-h-screen bg-gradient-to-br from-red-900 via-purple-900 to-indigo-900 flex items-center justify-center p-4">

                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-4xl w-full space-y-6">

                    <LanguageSelector />

                    <h2 className="text-4xl font-bold text-center text-rose-600">ğŸˆ´ {t.startKokugo} ğŸˆ´</h2>

                    <p className="text-center text-gray-600">{t.kokugoIntro}</p>



                    <div>

                        <h3 className="text-lg font-semibold text-gray-700 mb-2">{t.selectGrade}</h3>

                        <div className="flex gap-3 flex-wrap">

                            {[2, 3].map(grade => (

                                <button

                                    key={grade}

                                    onClick={() => setKokugoGrade(grade)}

                                    className={`px-4 py-2 rounded-full text-lg font-semibold ${kokugoGrade === grade ? 'bg-rose-600 text-white shadow-lg' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}

                                >{grade} {t.level}</button>

                            ))}

                        </div>

                    </div>



                    <div>

                        <h3 className="text-lg font-semibold text-gray-700 mb-2">{t.level}</h3>

                        <div className="flex gap-3 flex-wrap">

                            {DIFFICULTY_ORDER.map(level => (

                                <button

                                    key={level}

                                    onClick={() => setKokugoDifficulty(level)}

                                    className={`px-4 py-2 rounded-full text-lg font-semibold ${kokugoDifficulty === level ? 'bg-purple-600 text-white shadow-lg' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}

                                >{difficultyLabels[level]}</button>

                            ))}

                        </div>

                    </div>



                    <div>

                        <h3 className="text-lg font-semibold text-gray-700 mb-2">{t.studyContent}</h3>

                        <div className="flex gap-2 flex-wrap">

                            {KOKUGO_TYPES.map(type => (

                                <button

                                    key={type}

                                    onClick={() => toggleKokugoType(type)}

                                    className={`px-3 py-1 rounded-full text-sm font-semibold ${kokugoTypes.has(type) ? 'bg-indigo-600 text-white shadow' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}

                                >{typeLabels[type]}</button>

                            ))}

                        </div>

                    </div>



                    <div className="grid md:grid-cols-2 gap-4">

                        <div className="flex flex-col gap-2">

                            <label className="text-sm font-semibold text-gray-700">{t.studyLanguageLabel}</label>

                            <select value={learningLanguage} onChange={e => setLearningLanguage(e.target.value)} className="border border-gray-300 rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-rose-500">

                                {SUPPORTED_LANGUAGES.map(code => (

                                    <option key={code} value={code}>{LANGUAGE_LABELS[code] || code.toUpperCase()}</option>

                                ))}

                            </select>

                        </div>

                        <div className="flex flex-col gap-2">

                            <label className="text-sm font-semibold text-gray-700">{t.nativeLanguageLabel}</label>

                            <div className="flex gap-2">

                                <select value={language} onChange={e => setLanguage(e.target.value)} className="border border-gray-300 rounded-xl px-3 py-2 flex-1 focus:outline-none focus:ring-2 focus:ring-rose-500">

                                    {SUPPORTED_LANGUAGES.map(code => (

                                        <option key={code} value={code}>{LANGUAGE_LABELS[code] || code.toUpperCase()}</option>

                                    ))}

                                </select>

                                <button onClick={swapLanguages} className="px-3 py-2 rounded-xl bg-purple-600 text-white font-semibold hover:bg-purple-700">{t.swapLanguages}</button>

                            </div>

                        </div>

                    </div>



                    {kokugoFeedback && kokugoFeedback.type === 'error' && (

                        <div className="bg-red-100 text-red-700 rounded-xl px-4 py-2">{kokugoFeedback.message}</div>

                    )}



                    <div className="flex flex-wrap gap-3 justify-end">

                        <button onClick={() => setGameState('subjectSelect')} className="px-6 py-2 rounded-xl bg-gray-500 text-white hover:bg-gray-600">{t.back}</button>

                        <button onClick={startKokugoSession} className="px-6 py-2 rounded-xl bg-rose-600 text-white font-bold hover:bg-rose-700 transform hover:scale-105 transition-all">{t.startKokugo}</button>

                    </div>

                </div>

            </div>

        );

    }



    if (gameState === 'gradeSelect') {
        return (
            <div className="min-h-screen bg-gradient-to-br from-purple-900 to-pink-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                    <LanguageSelector />
                    <h2 className="text-4xl font-bold text-center mb-8 text-purple-600">ğŸ“ {t.selectGrade} ğŸ“</h2>
                    <div className="grid md:grid-cols-2 gap-6">
                        <button onClick={() => startGameWithGrade(2)} className="bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl p-6 text-white hover:from-blue-600 hover:to-cyan-600 transform hover:scale-105 transition-all">
                            <div className="text-5xl mb-4">ğŸ“˜</div>
                            <h3 className="text-2xl font-bold mb-3">{t.grade2Mode}</h3>
                            <p className="mb-2">{t.studyContent}</p>
                            <ul className="mt-2 text-left">
                                <li>âœ… {t.addition}</li>
                                <li>âœ… {t.subtraction}</li>
                                <li>âœ… {t.comparison}</li>
                            </ul>
                        </button>
                        <button onClick={() => startGameWithGrade(3)} className="bg-gradient-to-br from-purple-500 to-pink-500 rounded-2xl p-6 text-white hover:from-purple-600 hover:to-pink-600 transform hover:scale-105 transition-all">
                            <div className="text-5xl mb-4">ğŸ“•</div>
                            <h3 className="text-2xl font-bold mb-3">{t.grade3Mode}</h3>
                            <p className="mb-2">{t.studyContent}</p>
                            <ul className="mt-2 text-left">
                                <li>âœ… {t.multiplication}</li>
                                <li>âœ… {t.division}</li>
                            </ul>
                        </button>
                    </div>
                    <div className="mt-6 text-center">
                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>
                    </div>
                    <div className="mt-4 text-center text-gray-600"><p>ğŸ’¡ {t.hint}</p></div>
                </div>
            </div>
        );
    }

    

if (gameState === 'modeSelect') {
    const focusSkills = gradeConfig && gradeConfig.focusSkills ? gradeConfig.focusSkills : [];
    const miniGames = Object.values(miniGameConfigs || {}).filter(game => !game.grade || game.grade === selectedGrade);
    const coopScenarios = gradeConfig && gradeConfig.cooperativeScenarios ? gradeConfig.cooperativeScenarios : [];
    const versusScenarios = gradeConfig && gradeConfig.versusScenarios ? gradeConfig.versusScenarios : [];
    const quests = gradeConfig && Array.isArray(gradeConfig.quests) ? gradeConfig.quests : [];
    const heroLoadout = playerStats.heroLoadout || createDefaultPlayerStats().heroLoadout;
    const inventory = playerStats.inventory || {};
    const shopItems = Array.isArray(shopInventory) ? shopInventory.filter(item => !item.grade || item.grade === selectedGrade) : [];
    const shopItemMap = shopItemIndex;
    const companionMap = companionIndex;
    const arMissionsForGrade = Array.isArray(arMissionCatalog) ? arMissionCatalog.filter(mission => {
        if (!mission) return false;
        if (Array.isArray(mission.grade)) {
            return mission.grade.includes(selectedGrade);
        }
        if (typeof mission.grade === 'number') {
            return mission.grade === selectedGrade;
        }
        return true;
    }) : [];
    const rewardTrackMap = new Map((rewardTracks || []).map(track => [track.id, track]));
    const activeRewardTrack = rewardTrackMap.get(selectedRewardTrack) || ((rewardTracks || [])[0] || null);
    const unlockedStorySet = new Set((playerStats.storyBeatsUnlocked || []));

    return (
        <div className="min-h-screen bg-gradient-to-br from-purple-900 to-indigo-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/95 backdrop-blur-lg rounded-3xl shadow-2xl p-8 max-w-5xl w-full">
                <LanguageSelector />
                <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">ğŸ¯ {t.modeSelectTitle || 'Choose your quest'} ğŸ¯</h2>

                <div className="grid gap-4 md:grid-cols-2 mb-6">
                    <div className="rounded-2xl border border-purple-200 p-4 bg-purple-50">
                        <h3 className="text-xl font-semibold text-purple-700 mb-2">{t.focusSkillsTitle || 'Focus skills'}</h3>
                        <ul className="list-disc list-inside space-y-1 text-purple-900">
                            {focusSkills.map(skill => (
                                <li key={skill}>{skillLabel(skill)}</li>
                            ))}
                        </ul>
                    </div>
                    <div className="rounded-2xl border border-indigo-200 p-4 bg-indigo-50">
                        <h3 className="text-xl font-semibold text-indigo-700 mb-2">{t.worldsTitle || 'Theme worlds'}</h3>
                        <div className="flex flex-wrap gap-2">
                            {availableWorlds.length === 0 && <span className="text-indigo-500">{t.notFound}</span>}
                            {availableWorlds.map(world => (
                                <div key={world.id} className="flex items-center gap-2 px-3 py-2 rounded-full bg-white shadow">
                                    <span className="text-2xl">{world.icon || 'ğŸ—ºï¸'}</span>
                                    <span>{world.title}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>

                <div className="grid sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 mb-8">
                    <button onClick={beginDungeonAdventure} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'dungeon' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ—¡ï¸</div>
                        <h3 className="text-xl font-bold">{t.modeDungeon || 'Dungeon Adventure'}</h3>
                        <p className="text-sm opacity-80">{t.modeDungeonDescription || 'Explore mazes and battle monsters with math.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('miniGames')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'miniGames' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ¯</div>
                        <h3 className="text-xl font-bold">{t.modeMiniGames || 'Mini Games'}</h3>
                        <p className="text-sm opacity-80">{t.modeMiniGamesDescription || 'Play focused puzzles to train each skill.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('story')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'story' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ“œ</div>
                        <h3 className="text-xl font-bold">{t.modeStory || 'Story Quest'}</h3>
                        <p className="text-sm opacity-80">{t.modeStoryDescription || 'Unlock chapters of the adventure and collect lore.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('quests')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'quests' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ—ºï¸</div>
                        <h3 className="text-xl font-bold">{t.modeQuests || 'Quest Board'}</h3>
                        <p className="text-sm opacity-80">{t.modeQuestsDescription || 'Follow story missions and seasonal challenges.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('coop')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'coop' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ¤</div>
                        <h3 className="text-xl font-bold">{t.modeCoop || 'Co-op Mission'}</h3>
                        <p className="text-sm opacity-80">{t.modeCoopDescription || 'Team up with a learning buddy to solve challenges.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('versus')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'versus' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">âš”ï¸</div>
                        <h3 className="text-xl font-bold">{t.modeVersus || 'Versus Arena'}</h3>
                        <p className="text-sm opacity-80">{t.modeVersusDescription || 'Race on the same problem set and compare scores.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('customize')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'customize' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ§™â€â™‚ï¸</div>
                        <h3 className="text-xl font-bold">{t.modeCustomize || 'Avatar Studio'}</h3>
                        <p className="text-sm opacity-80">{t.modeCustomizeDescription || 'Change outfits, companions, and auras.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('shop')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'shop' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ›’</div>
                        <h3 className="text-xl font-bold">{t.modeShop || 'Item Shop'}</h3>
                        <p className="text-sm opacity-80">{t.modeShopDescription || 'Spend points on cosmetics and boosts.'}</p>
                    </button>
                    <button onClick={() => setActiveMode('ar')} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'ar' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ“¡</div>
                        <h3 className="text-xl font-bold">{t.modeAR || 'AR Fieldwork'}</h3>
                        <p className="text-sm opacity-80">{t.modeARDescription || 'Take real-world math missions around town.'}</p>
                    </button>
                    <button onClick={openParentDashboard} className={`rounded-2xl border border-purple-200 p-5 bg-white/90 shadow-lg transition transform hover:-translate-y-1 hover:shadow-2xl ${activeMode === 'parent' ? 'ring-4 ring-purple-400' : ''}`}>
                        <div className="text-4xl mb-2">ğŸ‘ª</div>
                        <h3 className="text-xl font-bold">{t.modeParent || 'Parent Dashboard'}</h3>
                        <p className="text-sm opacity-80">{t.modeParentDescription || 'Check progress, badges, and set rewards.'}</p>
              modeQuests: 'Quest Board',
              modeQuestsDescription: 'Follow story missions and seasonal challenges.',
              questTrack: 'Track',
              questComplete: 'Quest complete!',
              questCompleteAction: 'Mark complete',
              questCompleted: 'Completed',
              completed: 'Completed',
              questAlreadyCleared: 'Quest already completed.',
              questTracked: 'Quest pinned!',
              inProgress: 'In progress',
              rewardMilestone: 'Milestone',
              rewardLabel: 'Reward',
              modeHistory: 'Recent activity',
              modeCustomize: 'Avatar Studio',
              modeCustomizeDescription: 'Change outfits, companions, and auras.',
              modeShop: 'Item Shop',
              modeShopDescription: 'Spend points on cosmetics and boosts.',
              modeAR: 'AR Fieldwork',
              modeARDescription: 'Take real-world math missions around town.',
              modeARArea: 'Area',
              modeARSkill: 'Skill',
              modeARStart: 'Start mission',
              replay: 'Replay',
              slotOutfit: 'Outfit',
              slotHead: 'Headwear',
              slotWeapon: 'Tool',
              slotAura: 'Aura',
              slotAccessory: 'Accessory',
              slotCompanion: 'Companion',
              baseOutfit: 'Adventurer Robe',
              baseOutfitDescription: 'Balanced for any adventure.',
              baseHead: 'Explorer Band',
              baseHeadDescription: 'Keeps focus steady.',
              baseWeapon: 'Chalk Wand',
              baseWeaponDescription: 'Sketch strategies mid-battle.',
              baseAura: 'No Aura',
              baseAuraDescription: 'Pure focus with no glow.',
              baseAccessory: 'Travel Light',
              baseAccessoryDescription: 'Nothing extra, just courage.',
              companionNone: 'No companion',
              companionNoneDescription: 'Adventure solo.',
              avatarPreview: 'Current look',
              equip: 'Equip',
              equipped: 'Equipped',
              notPurchased: 'Buy in shop',
              purchase: 'Purchase',
              purchaseComplete: 'Purchase complete!',
              alreadyOwned: 'Already owned.',
              notEnoughPoints: 'Not enough points.',
              noRequirement: 'No requirement',
              requiresBadge: 'Requires badge',
              locked: 'Locked',
                    </button>
                </div>
                <div className="space-y-6">
                    {activeMode === 'miniGames' && (
                        <div>
                            <h3 className="text-2xl font-bold text-purple-600 mb-3">{t.miniGameTitle || 'Skill mini games'}</h3>
                            <div className="grid md:grid-cols-2 gap-4">
                                {miniGames.map(game => (
                                    <div key={game.id} className="mini-game-card">
                                        <div className="flex items-center justify-between mb-2">
                                            <h4 className="text-xl font-semibold text-blue-700">{game.title}</h4>
                                            <span className="text-sm text-blue-500">{skillLabel(skillForMiniGame(game))}</span>
                                        </div>
                                        <p className="text-sm mb-3 text-gray-600">{game.description || ''}</p>
                                        <button onClick={() => startMiniGameSession(game.id)} className="px-4 py-2 rounded-xl bg-gradient-to-r from-blue-500 to-teal-500 text-white font-semibold">{t.miniGameStart || 'Start'}</button>
                                    </div>
                                ))}
                                {miniGames.length === 0 && <p className="text-gray-500">{t.notFound}</p>}
                            </div>
                        </div>
                    )}

                    {activeMode === 'story' && (
                        <div>
                            <h3 className="text-2xl font-bold text-rose-600 mb-3">{t.storyUnlock || 'Story chapters'}</h3>
                            <div className="space-y-3">
                                {storyBeatsForGrade.map(beat => {
                                    const unlocked = unlockedStorySet.has(beat.id);
                                    return (
                                        <div key={beat.id} className={`story-beat ${unlocked ? 'bg-rose-50' : 'bg-gray-100'}`}>
                                            <div className="timeline-dot"></div>
                                            <div>
                                                <h4 className="font-semibold text-lg">{beat.title}</h4>
                                                <p className="text-sm text-gray-600">{beat.summary}</p>
                                                <button onClick={() => openStoryBeat(beat)} className="mt-2 text-sm px-3 py-1 rounded-full bg-rose-500 text-white">{unlocked ? (t.viewStory || 'View chapter') : (t.storyBegin || 'Unlock')}</button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {activeMode === 'coop' && (
                        <div>
                            <h3 className="text-2xl font-bold text-emerald-600 mb-3">{t.modeCoop || 'Co-op Mission'}</h3>
                            <div className="grid md:grid-cols-2 gap-4">
                                {coopScenarios.map(scenario => (
                                    <div key={scenario.id} className="coop-card">
                                        <h4 className="font-semibold text-lg mb-2">{skillLabel(scenario.coreSkill)}</h4>
                                        <p className="text-sm text-gray-600 mb-3">{scenario.description}</p>
                                        <button onClick={() => openCoopMission(scenario)} className="px-3 py-2 rounded-lg bg-emerald-500 text-white text-sm">{t.launchCoop || 'Start mission'}</button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {activeMode === 'versus' && (
                        <div>
                            <h3 className="text-2xl font-bold text-orange-600 mb-3">{t.modeVersus || 'Versus Arena'}</h3>
                            <div className="grid md:grid-cols-2 gap-4">
                                {versusScenarios.map(scenario => (
                                    <div key={scenario.id} className="versus-card">
                                        <h4 className="font-semibold text-lg mb-2">{skillLabel(scenario.coreSkill)}</h4>
                                        <p className="text-sm text-gray-600 mb-3">{scenario.description}</p>
                                        <button onClick={() => openVersusMatch(scenario)} className="px-3 py-2 rounded-lg bg-orange-500 text-white text-sm">{t.launchVersus || 'Start match'}</button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    {activeMode === 'quests' && (() => {
                        const questProgress = playerStats.questProgress || {};
                        return (
                            <div>
                                <h3 className="text-2xl font-bold text-indigo-600 mb-3">{t.modeQuests || 'Quest Board'}</h3>
                                <div className="grid md:grid-cols-2 gap-4">
                                    {quests.map(quest => {
                                        const progress = questProgress[quest.id];
                                        const completed = progress && progress.completed;
                                        return (
                                            <div key={quest.id} className={`rounded-2xl border p-4 ${completed ? 'border-emerald-300 bg-emerald-50' : 'border-indigo-200 bg-indigo-50'}`}>
                                                <h4 className="font-semibold text-lg text-indigo-800 mb-1">{quest.title}</h4>
                                                <p className="text-sm text-gray-600 mb-3">{quest.summary}</p>
                                                <ul className="list-disc list-inside text-xs text-gray-500 space-y-1 mb-3">
                                                    {(quest.steps || []).map((step, idx) => <li key={idx}>{step}</li>)}
                                                </ul>
                                                <div className="flex flex-wrap gap-2">
                                                    <button onClick={() => trackQuest(quest)} className="px-3 py-1 rounded-lg bg-indigo-500 text-white text-xs">{t.questTrack || 'Track'}</button>
                                                    <button onClick={() => completeQuest(quest)} className={`px-3 py-1 rounded-lg text-xs ${completed ? 'bg-gray-300 text-gray-600 cursor-not-allowed' : 'bg-emerald-500 text-white'}`} disabled={completed}>
                                                        {completed ? (t.questCompleted || 'Completed') : (t.questCompleteAction || 'Mark complete')}
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })}
                                    {quests.length === 0 && <p className="text-gray-500">{t.notFound}</p>}
                                </div>
                                {activeQuest && (
                                    <div className="mt-6 bg-white/80 border border-indigo-100 rounded-2xl p-4">
                                        <h4 className="font-semibold text-indigo-600 text-lg mb-2">{activeQuest.title}</h4>
                                        <p className="text-sm text-gray-600 mb-3">{activeQuest.summary}</p>
                                        <ul className="list-disc list-inside text-xs text-gray-500 space-y-1 mb-3">
                                            {(activeQuest.steps || []).map((step, idx) => <li key={idx}>{step}</li>)}
                                        </ul>
                                        <div className="flex gap-2">
                                            <button onClick={() => completeQuest(activeQuest)} className="px-3 py-1 rounded-lg bg-emerald-500 text-white text-xs">{t.questCompleteAction || 'Mark complete'}</button>
                                            <button onClick={() => setActiveQuest(null)} className="px-3 py-1 rounded-lg bg-gray-200 text-gray-700 text-xs">{t.back || 'Back'}</button>
                                        </div>
                                    </div>
                                )}
                                {activeRewardTrack && (
                                    <div className="mt-6 bg-white/80 border border-indigo-200 rounded-2xl p-5">
                                        <div className="flex flex-wrap justify-between items-center gap-2 mb-3">
                                            <h4 className="font-semibold text-indigo-600">{activeRewardTrack.title}</h4>
                                            <div className="flex gap-2">
                                                {(rewardTracks || []).map(track => (
                                                    <button key={track.id} onClick={() => setSelectedRewardTrack(track.id)} className={`px-3 py-1 rounded-full text-xs ${selectedRewardTrack === track.id ? 'bg-indigo-500 text-white' : 'bg-indigo-100 text-indigo-600'}`}>
                                                        {track.title}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                        <p className="text-sm text-gray-600 mb-4">{activeRewardTrack.description}</p>
                                        <div className="space-y-2">
                                            {(activeRewardTrack.milestones || []).map((milestone, idx) => {
                                                const requirement = typeof milestone.points === 'number' ? milestone.points : (milestone.count || 0);
                                                let progressValue = 0;
                                                if (typeof milestone.points === 'number') {
                                                    progressValue = playerStats.points || 0;
                                                } else if (milestone.count) {
                                                    progressValue = Array.isArray(playerStats.arMissionsCompleted) ? playerStats.arMissionsCompleted.length : 0;
                                                }
                                                const achieved = progressValue >= requirement;
                                                return (
                                                    <div key={idx} className={`flex justify-between items-center px-3 py-2 rounded-xl text-sm ${achieved ? 'bg-emerald-100 text-emerald-700' : 'bg-indigo-100 text-indigo-700'}`}>
                                                        <span>{t.rewardMilestone || 'Milestone'} {idx + 1}</span>
                                                        <span className="text-xs">{achieved ? (t.completed || 'Achieved') : `${progressValue}/${requirement}`}</span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })()}

                    {activeMode === 'customize' && (() => {
                        const slotLabels = { outfit: t.slotOutfit || 'Outfit', head: t.slotHead || 'Headwear', weapon: t.slotWeapon || 'Tool', aura: t.slotAura || 'Aura', accessory: t.slotAccessory || 'Accessory', companion: t.slotCompanion || 'Companion' };
                        const slots = Object.keys(slotLabels);
                        const baseItems = {
                            outfit: { id: 'starter_robe', name: t.baseOutfit || 'Adventurer Robe', icon: 'ğŸ¦¸', description: t.baseOutfitDescription || 'Balanced for any adventure.' },
                            head: { id: 'starter_band', name: t.baseHead || 'Explorer Band', icon: 'ğŸ—ï¸', description: t.baseHeadDescription || 'Keeps focus steady.' },
                            weapon: { id: 'chalk_wand', name: t.baseWeapon || 'Chalk Wand', icon: 'ğŸª„', description: t.baseWeaponDescription || 'Sketch strategies mid-battle.' },
                            aura: { id: 'none_aura', name: t.baseAura || 'No Aura', icon: 'âœ¨', description: t.baseAuraDescription || 'Pure focus with no glow.' },
                            accessory: { id: 'none_accessory', name: t.baseAccessory || 'Travel Light', icon: 'ğŸ’', description: t.baseAccessoryDescription || 'Nothing extra, just courage.' }
                        };
                        const availableCompanions = companionCatalog.filter(comp => (playerStats.companionRoster || []).includes(comp.id));
                        const getItemsForSlot = (slot) => {
                            if (slot === 'companion') {
                                const baseOption = { id: null, name: t.companionNone || 'No companion', icon: 'ğŸš¶', description: t.companionNoneDescription || 'Adventure solo.', available: true, owned: true, unlocked: true };
                                const roster = availableCompanions.map(comp => ({ id: comp.id, name: comp.name, icon: comp.icon || 'ğŸ§š', description: comp.description || '', available: true, owned: true, unlocked: true }));
                                return [baseOption, ...roster];
                            }
                            const baseList = baseItems[slot] ? [{ ...baseItems[slot], available: true, owned: true, unlocked: true }] : [];
                            const items = shopItems.filter(item => item.slot === slot).map(item => {
                                const unlocked = isItemUnlocked(item);
                                const owned = !!(inventory[item.id] && inventory[item.id].owned);
                                return {
                                    ...item,
                                    unlocked,
                                    owned,
                                    available: unlocked && owned
                                };
                            });
                            return [...baseList, ...items];
                        };
                        const selectedId = (slot) => {
                            if (slot === 'companion') {
                                return heroLoadout.companion || null;
                            }
                            return heroLoadout[slot] || (baseItems[slot] && baseItems[slot].id) || null;
                        };
                        const resolveName = (id, slot) => {
                            if (!id) {
                                return slot === 'companion' ? (t.companionNone || 'No companion') : (baseItems[slot] ? baseItems[slot].name : '');
                            }
                            if (baseItems[slot] && baseItems[slot].id === id) return baseItems[slot].name;
                            const shop = shopItemMap.get(id);
                            if (shop) return shop.name;
                            const companion = companionMap.get(id);
                            if (companion) return companion.name;
                            return id;
                        };
                        const resolveIcon = (id, slot) => {
                            if (!id) return slot === 'companion' ? 'ğŸš¶' : 'ğŸ¦¸';
                            if (baseItems[slot] && baseItems[slot].id === id) return baseItems[slot].icon;
                            const shop = shopItemMap.get(id);
                            if (shop && shop.icon) return shop.icon;
                            const companion = companionMap.get(id);
                            if (companion && companion.icon) return companion.icon;
                            return 'â­';
                        };
                        return (
                            <div>
                                <h3 className="text-2xl font-bold text-purple-600 mb-3">{t.modeCustomize || 'Avatar Studio'}</h3>
                                <div className="grid lg:grid-cols-2 gap-6">
                                    <div className="bg-purple-50 border border-purple-200 rounded-2xl p-6 flex flex-col items-center text-center gap-3">
                                        <div className="text-6xl">{resolveIcon(heroLoadout.outfit, 'outfit')}</div>
                                        <div className="text-sm text-gray-600">{t.avatarPreview || 'Current look'}</div>
                                        <div className="text-xs text-gray-500 space-y-1">
                                            {slots.map(slot => (
                                                <p key={slot}>{slotLabels[slot]}: {resolveName(heroLoadout[slot], slot)}</p>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="space-y-4">
                                        <div className="flex flex-wrap gap-2">
                                            {slots.map(slot => (
                                                <button key={slot} onClick={() => setCustomizationTab(slot)} className={`px-3 py-1 rounded-full text-xs ${customizationTab === slot ? 'bg-purple-500 text-white' : 'bg-purple-100 text-purple-700'}`}>
                                                    {slotLabels[slot]}
                                                </button>
                                            ))}
                                        </div>
                                        <div className="grid sm:grid-cols-2 gap-3">
                                            {getItemsForSlot(customizationTab).map(item => {
                                                const itemId = item.id === undefined ? null : item.id;
                                                const isSelected = (selectedId(customizationTab) || null) === (itemId || null);
                                                return (
                                                    <div key={itemId === null ? 'none' : itemId} className={`rounded-xl border p-3 ${isSelected ? 'border-purple-400 bg-purple-50' : 'border-gray-200 bg-white'}`}>
                                                        <div className="flex justify-between items-center mb-2">
                                                            <span className="text-2xl">{item.icon || resolveIcon(itemId, customizationTab)}</span>
                                                            {item.available ? (
                                                                <button onClick={() => equipHeroItem(customizationTab, itemId)} className={`px-3 py-1 rounded-lg text-xs ${isSelected ? 'bg-purple-400 text-white' : 'bg-purple-500 text-white'}`}>
                                                                    {isSelected ? (t.equipped || 'Equipped') : (t.equip || 'Equip')}
                                                                </button>
                                                            ) : (
                                                                <span className="text-xs text-gray-400">{item.unlocked ? (t.notPurchased || 'Buy in shop') : (t.locked || 'Locked')}</span>
                                                            )}
                                                        </div>
                                                        <h5 className="font-semibold text-sm">{item.name || resolveName(itemId, customizationTab)}</h5>
                                                        <p className="text-xs text-gray-500">{item.description || ''}</p>
                                                        {!item.available && item.requirement && item.requirement.badge && (
                                                            <p className="text-[11px] text-gray-400 mt-1">{t.requiresBadge || 'Requires badge'}: {item.requirement.badge}</p>
                                                        )}
                                                        {item.available && item.owned === false && (
                                                            <p className="text-[11px] text-gray-400 mt-1">{t.notPurchased || 'Buy in shop'}</p>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })()}

                    {activeMode === 'shop' && (() => {
                        const sortedItems = shopItems.slice().sort((a, b) => a.price - b.price);
                        return (
                            <div>
                                <h3 className="text-2xl font-bold text-amber-600 mb-3">{t.modeShop || 'Item Shop'}</h3>
                                <div className="flex justify-between items-center mb-3 text-sm text-gray-600">
                                    <span>{t.pointsLabel || 'Points'}: {playerStats.points}</span>
                                    {shopFeedback && (<span className={`px-3 py-1 rounded-full text-xs ${shopFeedback.type === 'success' ? 'bg-emerald-100 text-emerald-700' : shopFeedback.type === 'error' ? 'bg-red-100 text-red-700' : 'bg-indigo-100 text-indigo-700'}`}>{shopFeedback.text}</span>)}
                                </div>
                                <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    {sortedItems.map(item => {
                                        const owned = inventory[item.id] && inventory[item.id].owned;
                                        const unlocked = isItemUnlocked(item);
                                        return (
                                            <div key={item.id} className="rounded-2xl border border-amber-200 bg-white p-4 flex flex-col gap-2">
                                                <div className="flex justify-between items-center">
                                                    <span className="text-2xl">{item.icon || 'â­'}</span>
                                                    <span className="text-sm font-semibold text-amber-600">{item.price} {t.pointsLabel || 'pts'}</span>
                                                </div>
                                                <h4 className="font-semibold text-lg">{item.name}</h4>
                                                <p className="text-sm text-gray-600 flex-1">{item.description}</p>
                                                <p className="text-xs text-gray-400">{item.requirement && item.requirement.badge ? `${t.requiresBadge || 'Requires badge'}: ${item.requirement.badge}` : (t.noRequirement || 'No requirement')}</p>
                                                <button onClick={() => purchaseItem(item)} className={`w-full px-3 py-2 rounded-lg text-sm font-semibold ${owned ? 'bg-emerald-500 text-white' : unlocked ? 'bg-amber-500 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`} disabled={!unlocked || owned}>
                                                    {owned ? (t.alreadyOwned || 'Owned') : unlocked ? (t.purchase || 'Purchase') : (t.locked || 'Locked')}
                                                </button>
                                            </div>
                                        );
                                    })}
                                    {sortedItems.length === 0 && <p className="text-gray-500">{t.notFound}</p>}
                                </div>
                            </div>
                        );
                    })()}

                    {activeMode === 'ar' && (() => {
                        return (
                            <div>
                                <h3 className="text-2xl font-bold text-emerald-600 mb-3">{t.modeAR || 'AR Fieldwork'}</h3>
                                <div className="grid md:grid-cols-2 gap-4">
                                    {arMissionsForGrade.map(mission => {
                                        const completed = Array.isArray(playerStats.arMissionsCompleted) && playerStats.arMissionsCompleted.includes(mission.id);
                                        return (
                                            <div key={mission.id} className={`rounded-2xl border p-4 ${completed ? 'border-emerald-300 bg-emerald-50' : 'border-sky-200 bg-sky-50'}`}>
                                                <h4 className="font-semibold text-lg text-sky-700">{mission.title}</h4>
                                                <p className="text-sm text-gray-600 mb-3">{mission.description}</p>
                                                <p className="text-xs text-gray-500 mb-1">{t.modeARArea || 'Area'}: {mission.area}</p>
                                                <p className="text-xs text-gray-500 mb-3">{t.modeARSkill || 'Skill'}: {skillLabel(mission.skill || 'addition_carry')}</p>
                                                <p className="text-xs text-gray-500 mb-3">{t.rewardLabel || 'Reward'}: {(mission.reward && mission.reward.points) || 0} {t.pointsLabel || 'pts'}{mission.reward && mission.reward.badge ? ` + ${mission.reward.badge}` : ''}</p>
                                                <div className="flex gap-2">
                                                    <button onClick={() => startARMission(mission)} className="px-3 py-1 rounded-lg bg-sky-500 text-white text-xs">{completed ? (t.replay || 'Replay') : (t.modeARStart || 'Start Mission')}</button>
                                                    {completed && <span className="text-xs text-emerald-600 self-center">{t.completed || 'Completed'}</span>}
                                                </div>
                                            </div>
                                        );
                                    })}
                                    {arMissionsForGrade.length === 0 && <p className="text-gray-500">{t.notFound}</p>}
                                </div>
                            </div>
                        );
                    })()}
                </div>
            </div>
        </div>
    );
}


if (gameState === 'miniGame' && activeMiniGame && miniGameState) {
    const problem = miniGameState.problem;
    const options = problem && problem.options ? problem.options : null;
    const config = miniGameState.config;
    return (
        <div className="min-h-screen bg-gradient-to-br from-sky-900 to-teal-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/95 rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                <h2 className="text-3xl font-bold text-center text-sky-600 mb-4">{config.title}</h2>
                <p className="text-center text-sm text-sky-500 mb-6">{config.description || ''}</p>
                {problem && (
                    <div className="space-y-4">
                        <div className="bg-sky-100 rounded-2xl p-6 text-center text-2xl font-semibold text-sky-800">
                            {problem.question}
                        </div>
                        {options ? (
                            <div className="grid grid-cols-2 gap-4">
                                {options.map((option, idx) => (
                                    <button key={idx} onClick={() => handleMiniGameChoice(option)} className="py-3 rounded-xl bg-gradient-to-r from-sky-500 to-teal-500 text-white text-xl font-bold">
                                        {option}
                                    </button>
                                ))}
                            </div>
                        ) : (
                            <div className="flex flex-col items-center gap-3">
                                <input value={miniGameAnswer} onChange={e => setMiniGameAnswer(e.target.value)} className="w-full border border-sky-200 rounded-xl px-4 py-3 text-center text-xl" placeholder={t.answer || 'Answer'} />
                                <button onClick={() => submitMiniGameAnswer(miniGameAnswer)} className="px-4 py-2 rounded-xl bg-sky-600 text-white font-semibold">{t.submit || 'Submit'}</button>
                            </div>
                        )}
                        {miniGameFeedback && <div className="encouragement-toast text-center">{miniGameFeedback}</div>}
                    </div>
                )}
                <div className="mt-6 flex justify-between text-sm text-gray-500">
                    <span>{t.miniGameSkill || 'Skill'}: {skillLabel(skillForMiniGame(config))}</span>
                    <span>{t.progress || 'Progress'}: {miniGameState.successCount}</span>
                </div>
                <button onClick={endMiniGameSession} className="mt-6 w-full bg-gray-500 text-white py-3 rounded-xl">{t.backToModes || 'Back to mode select'}</button>
            </div>
        </div>
    );
}

if (gameState === 'story' && storyScene) {
    const { beat, unlocked } = storyScene;
    return (
        <div className="min-h-screen bg-gradient-to-br from-rose-900 to-purple-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/90 rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                <h2 className="text-3xl font-bold text-center text-rose-600 mb-3">{beat.title}</h2>
                <p className="text-gray-700 leading-relaxed whitespace-pre-line">{beat.summary}</p>
                <div className="mt-6 flex gap-3">
                    <button onClick={() => completeStoryBeat(beat)} className="flex-1 bg-rose-600 text-white py-3 rounded-xl font-semibold">{t.completeStory || 'Mark as completed'}</button>
                    <button onClick={() => { setStoryScene(null); setGameState('modeSelect'); }} className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl">{t.backToModes || 'Back'}</button>
                </div>
                {!unlocked && <p className="text-xs text-rose-500 mt-2">{t.storyLocked || 'New chapter unlocked!'}</p>}
            </div>
        </div>
    );
}

if (gameState === 'coop' && coopSession) {
    const { scenario, problem } = coopSession;
    return (
        <div className="min-h-screen bg-gradient-to-br from-emerald-900 to-blue-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/95 rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                <h2 className="text-3xl font-bold text-center text-emerald-600 mb-3">{t.modeCoop || 'Co-op Mission'}</h2>
                <p className="text-sm text-emerald-500 mb-4 text-center">{scenario.description}</p>
                {problem && (
                    <div className="bg-emerald-100 rounded-2xl p-6 mb-4 text-center text-2xl font-semibold text-emerald-800">
                        {problem.question}
                    </div>
                )}
                <input value={coopAnswer} onChange={e => setCoopAnswer(e.target.value)} className="w-full border border-emerald-200 rounded-xl px-4 py-3 text-center text-xl mb-3" placeholder={t.answer || 'Answer'} />
                <div className="flex gap-3">
                    <button onClick={() => submitCoopAnswer(coopAnswer)} className="flex-1 bg-emerald-600 text-white py-3 rounded-xl">{t.submit || 'Submit'}</button>
                    <button onClick={() => { setCoopSession(null); setGameState('modeSelect'); }} className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl">{t.backToModes || 'Back'}</button>
                </div>
            </div>
        </div>
    );
}

if (gameState === 'versus' && versusSession) {
    const { scenario, problem } = versusSession;
    return (
        <div className="min-h-screen bg-gradient-to-br from-orange-900 to-red-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/95 rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                <h2 className="text-3xl font-bold text-center text-orange-500 mb-3">{t.modeVersus || 'Versus Arena'}</h2>
                <p className="text-sm text-orange-500 mb-4 text-center">{scenario.description}</p>
                {problem && (
                    <div className="bg-orange-100 rounded-2xl p-6 mb-4 text-center text-2xl font-semibold text-orange-800">
                        {problem.question}
                    </div>
                )}
                <input value={versusAnswer} onChange={e => setVersusAnswer(e.target.value)} className="w-full border border-orange-200 rounded-xl px-4 py-3 text-center text-xl mb-3" placeholder={t.answer || 'Answer'} />
                <div className="flex gap-3">
                    <button onClick={() => submitVersusAnswer(versusAnswer)} className="flex-1 bg-orange-500 text-white py-3 rounded-xl">{t.submit || 'Submit'}</button>
                    <button onClick={() => { setVersusSession(null); setGameState('modeSelect'); }} className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl">{t.backToModes || 'Back'}</button>
                </div>
            </div>
        </div>
    );
}

if (gameState === 'arMission' && activeARMission) {
    const { mission, problem } = activeARMission;
    return (
        <div className="min-h-screen bg-gradient-to-br from-sky-900 to-emerald-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/95 rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                <h2 className="text-3xl font-bold text-center text-sky-600 mb-2">{mission.title}</h2>
                <p className="text-center text-sm text-gray-600 mb-4">{mission.description}</p>
                <div className="flex justify-between text-xs text-gray-500 mb-4">
                    <span>{t.modeARArea || 'Area'}: {mission.area}</span>
                    <span>{t.modeARSkill || 'Skill'}: {skillLabel(mission.skill || 'addition_carry')}</span>
                </div>
                <p className="text-xs text-gray-500 mb-3">{t.rewardLabel || 'Reward'}: {(mission.reward && mission.reward.points) || 0} {t.pointsLabel || 'pts'}{mission.reward && mission.reward.badge ? ` + ${mission.reward.badge}` : ''}</p>
                {problem && (
                    <div className="bg-sky-100 rounded-2xl p-6 text-center text-2xl font-semibold text-sky-800 mb-4">
                        {problem.question}
                    </div>
                )}
                <input value={arAnswer} onChange={e => setArAnswer(e.target.value)} className="w-full border border-sky-200 rounded-xl px-4 py-3 text-center text-xl mb-3" placeholder={t.answer || 'Answer'} />
                {arFeedback && <p className="text-center text-sm text-red-500 mb-3">{arFeedback}</p>}
                <div className="flex gap-3">
                    <button onClick={() => submitARMissionAnswer(arAnswer)} className="flex-1 bg-sky-500 text-white py-3 rounded-xl font-semibold">{t.submit || 'Submit'}</button>
                    <button onClick={cancelARMission} className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl">{t.backToModes || 'Back'}</button>
                </div>
            </div>
        </div>
    );
}

if (gameState === 'parentDashboard') {
    const weekly = playerStats.weeklyProgress || [];
    const miniRecords = playerStats.miniGameRecords || {};
    const questProgress = playerStats.questProgress || {};
    const allQuests = [];
    Object.values(gradeCurriculum || {}).forEach(grade => {
        if (Array.isArray(grade.quests)) {
            allQuests.push(...grade.quests);
        }
    });
    const questsCompleted = Object.values(questProgress).filter(entry => entry && entry.completed).length;
    const totalAvailableQuests = allQuests.length;
    const arCompleted = Array.isArray(playerStats.arMissionsCompleted) ? playerStats.arMissionsCompleted : [];
    const totalArMissions = arMissionCatalog.length;
    const heroLoadout = playerStats.heroLoadout || createDefaultPlayerStats().heroLoadout;
    const baseCosmetics = {
        outfit: t.baseOutfit || 'Adventurer Robe',
        head: t.baseHead || 'Explorer Band',
        weapon: t.baseWeapon || 'Chalk Wand',
        aura: t.baseAura || 'No Aura',
        accessory: t.baseAccessory || 'Travel Light',
        companion: t.companionNone || 'No companion'
    };
    const describeCosmetic = (id, slot) => {
        if (!id) {
            return baseCosmetics[slot] || baseCosmetics.companion;
        }
        if (slot === 'companion') {
            const comp = companionIndex.get(id);
            return comp ? comp.name : baseCosmetics.companion;
        }
        if (slot === 'outfit' && id === 'starter_robe') return baseCosmetics.outfit;
        if (slot === 'head' && id === 'starter_band') return baseCosmetics.head;
        if (slot === 'weapon' && id === 'chalk_wand') return baseCosmetics.weapon;
        if (slot === 'aura' && id === 'none_aura') return baseCosmetics.aura;
        if (slot === 'accessory' && id === 'none_accessory') return baseCosmetics.accessory;
        const shop = shopItemIndex.get(id);
        return shop ? shop.name : id;
    };
    const formatHistoryEntry = (entry) => {
        if (!entry) return '';
        switch (entry.event) {
            case 'quest':
                return `${t.modeQuests || 'Quest'}: ${entry.id}`;
            case 'purchase': {
                const item = shopItemIndex.get(entry.id);
                return `${t.purchase || 'Purchase'}: ${item ? item.name : entry.id}`;
            }
            case 'story':
                return `${t.modeStory || 'Story'}: ${entry.id}`;
            case 'levelUp':
                return `${t.levelLabel || 'Level'} ${Array.isArray(entry.levels) ? entry.levels.join(', ') : entry.levels || ''}`;
            case 'arMission':
                return `${t.modeAR || 'AR Fieldwork'}: ${entry.id}`;
            case 'question':
            default: {
                const subjectLabel = entry.subject === 'kokugo' ? (t.subjectKokugo || 'Language') : (t.subjectMath || 'Math');
                const skillText = entry.skill ? entry.skill.replace(/_/g, ' ') : 'practice';
                const resultIcon = entry.correct ? 'âœ“' : 'âœ—';
                return `${subjectLabel} - ${skillText} ${resultIcon}`;
            }
        }
    };
    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 to-purple-900 flex items-center justify-center p-4">
            <CheerToast />
            <div className="bg-white/95 rounded-3xl shadow-2xl p-8 max-w-5xl w-full">
                <h2 className="text-3xl font-bold text-center text-purple-600 mb-6">{t.parentDashboard || 'Parent Dashboard'}</h2>
                <div className="grid md:grid-cols-2 xl:grid-cols-4 gap-4 mb-6">
                    <div className="rounded-2xl border border-purple-200 p-4 bg-purple-50">
                        <h3 className="text-sm text-gray-500 uppercase tracking-wide">{t.levelLabel || 'Level'}</h3>
                        <p className="text-3xl font-bold text-purple-600">{playerStats.level}</p>
                        <p className="text-xs text-gray-500">{t.nextReward || 'Next reward at'} {Math.max(0, playerStats.nextLevelExp - playerStats.experience)} XP</p>
                    </div>
                    <div className="rounded-2xl border border-green-200 p-4 bg-green-50">
                        <h3 className="text-sm text-gray-500 uppercase tracking-wide">{t.pointsLabel || 'Points'}</h3>
                        <p className="text-3xl font-bold text-green-600">{playerStats.points}</p>
                    </div>
                    <div className="rounded-2xl border border-sky-200 p-4 bg-sky-50">
                        <h3 className="text-sm text-gray-500 uppercase tracking-wide">{t.totalQuestions || 'Questions answered'}</h3>
                        <p className="text-3xl font-bold text-sky-600">{playerStats.totalQuestionsAnswered}</p>
                    </div>
                    <div className="rounded-2xl border border-amber-200 p-4 bg-amber-50">
                        <h3 className="text-sm text-gray-500 uppercase tracking-wide">{t.badges || 'Badges'}</h3>
                        <p className="text-3xl font-bold text-amber-600">{playerStats.badges ? playerStats.badges.length : 0}</p>
                    </div>
                    <div className="rounded-2xl border border-indigo-200 p-4 bg-indigo-50">
                        <h3 className="text-sm text-gray-500 uppercase tracking-wide">{t.modeQuests || 'Quest Board'}</h3>
                        <p className="text-3xl font-bold text-indigo-600">{questsCompleted}/{totalAvailableQuests}</p>
                    </div>
                    <div className="rounded-2xl border border-emerald-200 p-4 bg-emerald-50">
                        <h3 className="text-sm text-gray-500 uppercase tracking-wide">{t.modeAR || 'AR Fieldwork'}</h3>
                        <p className="text-3xl font-bold text-emerald-600">{arCompleted.length}/{totalArMissions}</p>
                    </div>
                </div>

                <div className="grid md:grid-cols-2 gap-6">
                    <div className="rounded-2xl border border-purple-200 p-4">
                        <h3 className="text-lg font-semibold text-purple-600 mb-2">{t.weeklyProgress || 'Weekly progress'}</h3>
                        <ul className="space-y-2 max-h-48 overflow-y-auto">
                            {weekly.slice().reverse().map(week => (
                                <li key={week.week} className="flex justify-between text-sm">
                                    <span>{week.week}</span>
                                    <span>{week.correct}/{week.answered} ({week.points} pts)</span>
                                </li>
                            ))}
                            {weekly.length === 0 && <li className="text-gray-500 text-sm">{t.notFound}</li>}
                        </ul>
                    </div>
                    <div className="rounded-2xl border border-purple-200 p-4">
                        <h3 className="text-lg font-semibold text-purple-600 mb-2">{t.miniGameStat || 'Mini game streaks'}</h3>
                        <ul className="space-y-2 max-h-48 overflow-y-auto">
                            {Object.keys(miniRecords).length === 0 && <li className="text-gray-500 text-sm">{t.notFound}</li>}
                            {Object.entries(miniRecords).map(([id, record]) => (
                                <li key={id} className="flex justify-between text-sm">
                                    <span>{id}</span>
                                    <span>{record.wins} / {record.attempts}</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>

                <div className="grid md:grid-cols-2 gap-6 mt-6">
                    <div className="rounded-2xl border border-indigo-200 p-4">
                        <h3 className="text-lg font-semibold text-indigo-600 mb-2">{t.modeQuests || 'Quest Board'}</h3>
                        <ul className="space-y-2 max-h-48 overflow-y-auto">
                            {allQuests.length === 0 && <li className="text-gray-500 text-sm">{t.notFound}</li>}
                            {allQuests.map(quest => {
                                const progress = questProgress[quest.id];
                                const completed = progress && progress.completed;
                                return (
                                    <li key={quest.id} className="flex justify-between text-sm">
                                        <span>{quest.title}</span>
                                        <span className={completed ? 'text-emerald-600' : 'text-gray-500'}>{completed ? (t.questCompleted || 'Completed') : (t.inProgress || 'In progress')}</span>
                                    </li>
                                );
                            })}
                        </ul>
                    </div>
                    <div className="rounded-2xl border border-emerald-200 p-4">
                        <h3 className="text-lg font-semibold text-emerald-600 mb-2">{t.modeAR || 'AR Fieldwork'}</h3>
                        <ul className="space-y-2 max-h-48 overflow-y-auto">
                            {arMissionCatalog.map(mission => {
                                const completed = arCompleted.includes(mission.id);
                                return (
                                    <li key={mission.id} className="flex justify-between text-sm">
                                        <span>{mission.title}</span>
                                        <span className={completed ? 'text-emerald-600' : 'text-gray-500'}>{completed ? (t.completed || 'Completed') : `${(mission.reward && mission.reward.points) || 0} ${t.pointsLabel || 'pts'}`}</span>
                                    </li>
                                );
                            })}
                            {arMissionCatalog.length === 0 && <li className="text-gray-500 text-sm">{t.notFound}</li>}
                        </ul>
                    </div>
                </div>

                <div className="grid md:grid-cols-2 gap-6 mt-6">
                    <div className="rounded-2xl border border-purple-200 p-4">
                        <h3 className="text-lg font-semibold text-purple-600 mb-2">{t.modeCustomize || 'Avatar Studio'}</h3>
                        <ul className="space-y-1 text-sm text-gray-600">
                            <li>{t.slotOutfit || 'Outfit'}: {describeCosmetic(heroLoadout.outfit, 'outfit')}</li>
                            <li>{t.slotHead || 'Headwear'}: {describeCosmetic(heroLoadout.head, 'head')}</li>
                            <li>{t.slotWeapon || 'Tool'}: {describeCosmetic(heroLoadout.weapon, 'weapon')}</li>
                            <li>{t.slotAura || 'Aura'}: {describeCosmetic(heroLoadout.aura, 'aura')}</li>
                            <li>{t.slotAccessory || 'Accessory'}: {describeCosmetic(heroLoadout.accessory, 'accessory')}</li>
                            <li>{t.slotCompanion || 'Companion'}: {describeCosmetic(heroLoadout.companion, 'companion')}</li>
                        </ul>
                    </div>
                    <div className="rounded-2xl border border-gray-200 p-4">
                        <h3 className="text-lg font-semibold text-gray-700 mb-2">{t.modeHistory || 'Recent activity'}</h3>
                        <ul className="space-y-2 text-sm text-gray-600 max-h-48 overflow-y-auto">
                            {recentHistory.length === 0 && <li className="text-gray-500 text-sm">{t.notFound}</li>}
                            {recentHistory.map((entry, idx) => (
                                <li key={idx} className="flex justify-between gap-2">
                                    <span className="text-xs text-gray-400">{new Date(entry.timestamp).toLocaleDateString()}</span>
                                    <span>{formatHistoryEntry(entry)}</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>

                <button onClick={() => setGameState('modeSelect')} className="mt-6 w-full bg-gray-500 text-white py-3 rounded-xl">{t.backToModes || 'Back to mode select'}</button>
            </div>
        </div>
    );
}
if (gameState === 'map') {
        return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-3xl font-bold text-center mb-6 text-green-700">ğŸ—ºï¸ {t.selectArea} ğŸ—ºï¸</h2>
                    <div className="flex flex-col gap-4">
                        {['urawa', 'omiya', 'iwatsuki'].map(area => (
                            <button key={area} onClick={() => { setSelectedArea(area); setGameState('area'); }} className="bg-gradient-to-r from-green-500 to-lime-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-green-600 hover:to-lime-600">
                                {t[area]}
                            </button>
                        ))}
                    </div>
                    <div className="mt-6 text-center">
                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'area' && selectedArea) {
        const insectKey = areaInsects[selectedArea].insect;
        return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-3xl font-bold text-center mb-6 text-green-700">{t[selectedArea]}</h2>
                    <div className="text-center mb-6">
                        <p className="text-2xl">{t[insectKey]}</p>
                        <p className="mt-2">{t[`${insectKey}Fact`]}</p>
                    </div>
                    <div className="flex flex-col gap-4 items-center">
                        <button onClick={() => startCapture(insectKey)} className="bg-green-500 text-white px-6 py-3 rounded-xl hover:bg-green-600">{t.attemptCapture}</button>
                        <button onClick={() => setGameState('map')} className="bg-gray-500 text-white px-6 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'insectQuiz' && captureQuestion) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-3xl font-bold text-center mb-6 text-green-700">{t.captureInsect}</h2>
                    <div className="text-center text-2xl mb-6">{captureQuestion.question}</div>
                    {captureResult ? (
                        <div className="text-center text-2xl mb-6">{captureResult === 'success' ? t.captureSuccess : t.captureFail}</div>
                    ) : (
                        <div className="grid grid-cols-2 gap-4 mb-6">
                            {captureQuestion.options.map((opt, idx) => (
                                <button key={idx} onClick={() => checkCaptureAnswer(opt)} className="bg-purple-500 text-white text-3xl font-bold py-4 rounded-2xl hover:scale-105 transition-all">{opt}</button>
                            ))}
                        </div>
                    )}
                    <div className="text-center">
                        <button onClick={() => setGameState('map')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{captureResult ? t.selectArea : t.back}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'kokugoQuestion' && kokugoSession && kokugoSession.current) {

        const difficultyLabels = {

            easy: t.difficultyEasy,

            normal: t.difficultyNormal,

            hard: t.difficultyHard

        };

        const { question, support, revealedHints } = kokugoSession.current;

        const hints = question.hints || [];

        const progressText = formatText(t.questionProgress, { current: kokugoSession.index + 1, total: kokugoSession.total });

        const hintsText = hints.length > 0 ? formatText(t.hintsRemaining, { remaining: Math.max(hints.length - (revealedHints || 0), 0), total: hints.length }) : null;

        const isLastQuestion = kokugoSession.index + 1 >= kokugoSession.total;

        const nextLabel = isLastQuestion ? (t.kokugoViewResults || t.kokugoSummaryMenu || 'OK') : (t.nextQuestion || t.nextLevel);

        const supportLangLabel = support && support.lang ? (LANGUAGE_LABELS[support.lang] || support.lang.toUpperCase()) : '';



        return (

            <div className="min-h-screen bg-gradient-to-br from-red-800 via-purple-900 to-indigo-900 flex items-center justify-center p-4">

                <div className="bg-white rounded-3xl shadow-2xl p-6 max-w-4xl w-full space-y-6">

                    <LanguageSelector />

                    <div className="flex flex-wrap justify-between items-center gap-3">

                        <span className="text-sm font-semibold text-purple-600 uppercase tracking-wide">{progressText}</span>

                        <span className="text-sm text-gray-500">{difficultyLabels[kokugoDifficulty]}</span>

                    </div>



                    <div className="bg-purple-100 rounded-2xl p-6">

                        <p className="text-2xl font-bold text-purple-800 whitespace-pre-wrap">{question.prompt}</p>

                    </div>



                    <div className="flex flex-wrap gap-3">

                        <button onClick={() => speak(question.tts?.text || question.prompt, question.tts?.lang || getSpeechLocale(kokugoSession.lang))} className="px-4 py-2 rounded-xl bg-rose-500 text-white hover:bg-rose-600 disabled:opacity-50" disabled={!question.prompt}>{isTTSSpeaking ? t.ttsStop : t.ttsPlay}</button>

                        <button onClick={stopSpeech} className="px-4 py-2 rounded-xl bg-gray-300 text-gray-700 hover:bg-gray-400">{t.ttsStop}</button>

                        {hints.length > 0 && (

                            <button onClick={showNextKokugoHint} className="px-4 py-2 rounded-xl bg-indigo-500 text-white hover:bg-indigo-600 disabled:opacity-50" disabled={revealedHints >= hints.length}>{t.viewHint}</button>

                        )}

                        {kokugoHintVisible && hints.length > 0 && (

                            <button onClick={hideKokugoHints} className="px-4 py-2 rounded-xl bg-gray-200 text-gray-700 hover:bg-gray-300">{t.hideHint}</button>

                        )}

                        {hintsText && <span className="text-sm text-gray-500 self-center">{hintsText}</span>}

                    </div>



                    <div className="grid sm:grid-cols-2 gap-3">

                        {(question.choices || []).map(choice => {

                            const key = typeof choice === 'string' ? choice : String(choice);

                            const isSelected = kokugoAnswer === key;

                            return (

                                <button

                                    key={key}

                                    onClick={() => handleKokugoAnswer(choice)}

                                    className={`px-4 py-3 rounded-2xl text-lg font-semibold border-2 transition-all ${isSelected ? 'bg-rose-600 border-rose-600 text-white shadow-lg' : 'bg-white border-purple-300 text-purple-700 hover:border-rose-400'}`}

                                    disabled={kokugoAnswer !== ''}

                                >{choice}</button>

                            );

                        })}

                    </div>



                    {kokugoHintVisible && hints.length > 0 && (

                        <div className="bg-amber-50 border border-amber-200 rounded-2xl p-4">

                            <h4 className="font-semibold text-amber-700 mb-2">{t.hint}</h4>

                            <ul className="space-y-1 text-amber-700">

                                {hints.slice(0, revealedHints || 0).map((hint, index) => (

                                    <li key={index}>â€¢ {hint}</li>

                                ))}

                            </ul>

                        </div>

                    )}



                    {support && (

                        <div className="bg-gray-100 rounded-2xl p-4">

                            <h4 className="font-semibold text-gray-600 mb-1">{formatText(t.supportPrompt, { lang: supportLangLabel })}</h4>

                            <p className="text-gray-700">{support.prompt}</p>

                        </div>

                    )}



                    {kokugoFeedback && (

                        <div className={`rounded-2xl p-4 text-lg font-semibold ${kokugoFeedback.type === 'success' ? 'bg-emerald-100 text-emerald-700' : 'bg-red-100 text-red-700'}`}>{kokugoFeedback.message}</div>

                    )}



                    {kokugoAnswer !== '' && question.explanation && (

                        <div className="bg-blue-50 border border-blue-200 rounded-2xl p-4 text-blue-700">{question.explanation}</div>

                    )}



                    <div className="flex justify-end">

                        <button onClick={goToNextKokugoQuestion} className="px-6 py-2 rounded-xl bg-purple-600 text-white font-bold hover:bg-purple-700 disabled:opacity-50" disabled={kokugoAnswer === ''}>{nextLabel}</button>

                    </div>

                </div>

            </div>

        );

    }



    if (gameState === 'maze') {
        return (
            <div className="min-h-screen bg-gradient-to-b from-indigo-950 to-slate-950 p-4">
                <div className="max-w-4xl mx-auto">
                    <div className="bg-purple-900/80 rounded-2xl p-4 mb-4">
                        <div className="flex justify-between items-center flex-wrap gap-2">
                            <div className="text-2xl font-bold text-white">{t.level} {currentLevel}</div>
                            <div className="text-xl text-yellow-400">âš”ï¸ {t.defeated}: {defeatedMonsters.length}/{monsterPositions.length}</div>
                            <button onClick={() => setGameState('menu')} className="bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600">{t.menu}</button>
                        </div>
                        {requiredBosses.length > 0 && (
                            <div className="mt-2 text-center">
                                {requiredBosses.every(id => defeatedMonsters.includes(id)) ? (
                                    <span className="text-green-400 font-bold text-lg animate-pulse">âœ¨ {t.defeatedBoss} âœ¨</span>
                                ) : (
                                    <span className="text-orange-400 font-bold text-lg animate-pulse">âš ï¸ {t.needDefeatBoss} âš ï¸</span>
                                )}
                            </div>
                        )}
                    </div>

                    {message && (
                        <div className="bg-yellow-500 text-white text-center text-2xl font-bold p-3 rounded-xl mb-4 animate-bounce">{message}</div>
                    )}

                    <div className="bg-slate-900 rounded-3xl p-8">
                        <h3 className="text-2xl font-bold text-center mb-4 text-white">âš”ï¸ {t.dungeonExploring} âš”ï¸</h3>

                        <div className="grid gap-1 mx-auto" style={{ gridTemplateColumns: `repeat(${mazeSize}, minmax(0, 1fr))`, maxWidth: `${mazeSize * 60}px` }}>
                            {maze.map((row, y) => row.map((cell, x) => {
                                const isPlayer = playerPosition.x === x && playerPosition.y === y;
                                const monster = monsterPositions.find(m => m.x === x && m.y === y && !defeatedMonsters.includes(m.id));
                                const isGoal = x === mazeSize - 1 && y === mazeSize - 1;
                                const isGate = cell === 3;
                                const isBossMonster = monster && monster.isBoss;

                                return (
                                    <div key={`${x}-${y}`} className={`aspect-square flex items-center justify-center rounded text-3xl ${cell === 1 ? 'bg-gray-800' : 'bg-teal-900/40'} ${isGoal && !isPlayer ? 'bg-gradient-to-br from-yellow-500 to-orange-500' : ''} ${isGate ? 'bg-gradient-to-br from-red-900 to-orange-800' : ''}`}>
                                        {isPlayer && <span className="animate-hero">ğŸ¦¸</span>}
                                        {monster && <span className={isBossMonster ? "animate-boss" : "animate-monster"}>{monster.type.emoji}</span>}
                                        {isGoal && !isPlayer && <span className="animate-goal">ğŸ</span>}
                                        {isGate && !isPlayer && <span className="text-2xl">ğŸ”’</span>}
                                    </div>
                                );
                            }))}
                        </div>

                        <div className="mt-6 flex justify-center gap-2 text-sm">
                            <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white"><div className="w-4 h-4 bg-blue-500 rounded"></div><span>{t.you}</span></div>
                            <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white"><div className="w-4 h-4 bg-red-500 rounded"></div><span>{t.monster}</span></div>
                            <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white"><div className="w-4 h-4 bg-purple-500 rounded"></div><span>{t.boss}</span></div>
                        </div>

                        <div className="mt-6 flex flex-col items-center">
                            <button onClick={() => movePlayer('up')} className="bg-blue-600 text-white p-3 rounded-xl mb-2 hover:bg-blue-700">â¬†ï¸</button>
                            <div className="flex gap-2">
                                <button onClick={() => movePlayer('left')} className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700">â¬…ï¸</button>
                                <button onClick={() => movePlayer('down')} className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700">â¬‡ï¸</button>
                                <button onClick={() => movePlayer('right')} className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700">â¡ï¸</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'battle' && currentMonster && battleState) {
        return (
            <div className={`min-h-screen ${currentMonster.isBoss ? 'bg-gradient-to-b from-purple-600 to-red-600' : 'bg-gradient-to-b from-red-400 to-orange-400'} flex items-center justify-center p-4`}>
                <CheerToast />
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <div className="text-center mb-6">
                        <div className={`${currentMonster.isBoss ? 'text-8xl' : 'text-6xl'} mb-4`}>{currentMonster.type.emoji}</div>
                        <h2 className="text-3xl font-bold text-purple-600">
                            {currentMonster.isBoss && `ğŸ’€ ${t.bossBattle} ğŸ’€`}
                            {!currentMonster.isBoss && `${currentMonster.type.name}${t.appeared}`}
                            {currentMonster.isBoss && <div className="text-2xl mt-2">{currentMonster.type.name}</div>}
                        </h2>
                        <p className="text-xl mt-2">{currentMonster.type.description}</p>
                    </div>

                    <div className="flex justify-center gap-2 mb-6">
                        {[...Array(battleState.maxHealth)].map((_, i) => (
                            <span key={i} className={`heart ${i < battleState.monsterHealth ? 'filled' : 'empty'}`}>â¤ï¸</span>
                        ))}
                    </div>

                    <div className={`text-center text-3xl font-bold mb-6 ${timeLeft <= 10 ? 'text-red-600 animate-pulse' : 'text-blue-600'}`}>{t.timeLeft}: {timeLeft}{t.seconds}</div>

                    <div className="bg-blue-100 rounded-2xl p-6 mb-6">
                        <div className="text-4xl font-bold text-center text-blue-800">{battleState.currentProblem.question}</div>
                    </div>

                    {message && <div className={`text-center text-2xl font-bold mb-4 ${message.includes(t.correct) ? 'text-green-600' : 'text-orange-600'}`}>{message}</div>}

                    {battleState.currentProblem.hint && (
                        <div className="text-center mb-4">
                            <button onClick={() => setShowHint(!showHint)} className="bg-yellow-300 text-yellow-800 font-bold px-4 py-2 rounded-lg hover:bg-yellow-400">{showHint ? t.hideHint : t.viewHint}</button>
                        </div>
                    )}

                    {showHint && battleState.currentProblem.hint && (
                        <div className="text-center text-xl text-yellow-800 mb-4">{battleState.currentProblem.hint}</div>
                    )}

                    <div className="grid grid-cols-2 gap-4">
                        {battleState.currentProblem.options.map((option, index) => (
                            <button key={index} onClick={() => checkAnswer(option)} className={`${currentMonster.isBoss ? 'bg-gradient-to-r from-purple-600 to-red-600' : 'bg-gradient-to-r from-purple-500 to-pink-500'} text-white text-3xl font-bold py-6 rounded-2xl hover:scale-105 transition-all`} disabled={message !== ''}>
                                {option}
                            </button>
                        ))}
                    </div>

                    {currentMonster.isBoss && <div className="mt-4 text-center text-red-600 font-bold animate-pulse">âš ï¸ {t.bossWarning} âš ï¸</div>}
                </div>
            </div>
        );
    }

    if (gameState === 'kokugoSummary') {

        const typeLabels = {

            reading: t.questionTypeReading,

            kanji: t.questionTypeKanji,

            vocab: t.questionTypeVocab,

            comprehension: t.questionTypeComprehension,

            grammar: t.questionTypeGrammar

        };

        const total = kokugoHistory.length;

        const correct = kokugoHistory.filter(item => item.isCorrect).length;

        const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;

        const comprehensionTotal = kokugoHistory.filter(item => item.type === 'comprehension').length;

        const comprehensionCorrect = kokugoHistory.filter(item => item.type === 'comprehension' && item.isCorrect).length;

        const comprehensionAccuracy = comprehensionTotal > 0 ? Math.round((comprehensionCorrect / comprehensionTotal) * 100) : 0;



        return (

            <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 flex items-center justify-center p-4">

                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-4xl w-full space-y-6">

                    <LanguageSelector />

                    <h2 className="text-4xl font-bold text-center text-purple-600">ğŸ‰ {t.kokugoSummaryTitle} ğŸ‰</h2>

                    <div className="grid sm:grid-cols-2 gap-4">

                        <div className="bg-emerald-100 text-emerald-700 rounded-2xl p-4 text-center font-semibold text-xl">{t.kokugoSummaryAccuracy}: {accuracy}%</div>

                        <div className="bg-indigo-100 text-indigo-700 rounded-2xl p-4 text-center font-semibold text-xl">{t.kokugoSummaryCorrect}: {correct} / {total}</div>

                        <div className="bg-amber-100 text-amber-700 rounded-2xl p-4 text-center font-semibold text-xl">{t.comprehensionAccuracy}: {comprehensionAccuracy}%</div>

                    </div>



                    <div>

                        <h3 className="text-2xl font-bold text-gray-700 mb-3">{t.kokugoSummaryDetails}</h3>

                        <div className="max-h-80 overflow-y-auto space-y-3">

                            {kokugoHistory.map((entry, index) => (

                                <div key={entry.id + index} className="border border-purple-200 rounded-2xl p-4 bg-purple-50 text-purple-800">

                                    <div className="flex justify-between items-center mb-2">

                                        <span className="font-semibold">#{index + 1} {entry.type ? (typeLabels[entry.type] || entry.type) : ''}</span>

                                        <span className={entry.isCorrect ? 'text-emerald-600 font-semibold' : 'text-red-600 font-semibold'}>{entry.isCorrect ? 'â—' : 'âœ•'}</span>

                                    </div>

                                    <p className="font-bold mb-1">{entry.prompt}</p>

                                    <p className="text-sm mb-1">{t.correctAnswers}: {entry.answer}</p>

                                    <p className="text-sm mb-1">{t.question}: {entry.selected}</p>

                                    {entry.explanation && <p className="text-sm text-gray-700">{entry.explanation}</p>}

                                </div>

                            ))}

                        </div>

                    </div>



                    <div className="flex flex-wrap gap-3 justify-end">

                        <button onClick={startKokugoSession} className="px-6 py-2 rounded-xl bg-rose-600 text-white font-bold hover:bg-rose-700 transform hover:scale-105 transition-all">{t.kokugoSummaryAgain}</button>

                        <button onClick={() => setGameState('subjectSelect')} className="px-6 py-2 rounded-xl bg-gray-500 text-white hover:bg-gray-600">{t.kokugoSummaryMenu}</button>

                    </div>

                </div>

            </div>

        );

    }



    if (gameState === 'victory') {
        return (
            <div className="min-h-screen bg-gradient-to-b from-yellow-400 to-orange-400 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full text-center">
                    <div className="text-6xl mb-4">ğŸ‰ğŸ†ğŸ‰</div>
                    <h1 className="text-5xl font-bold text-purple-600 mb-6">{t.level} {currentLevel} {t.clearMessage}</h1>
                    <div className="bg-blue-100 rounded-2xl p-6 mb-6">
                        <p className="text-2xl mb-2">{t.defeated}: {defeatedMonsters.length}{t.body}</p>
                        <p className="text-2xl">{t.accuracy}: {playerStats.totalQuestionsAnswered > 0 ? Math.round((playerStats.correctAnswers / playerStats.totalQuestionsAnswered) * 100) : 0}%</p>
                    </div>

                    {playerStats.badges.length > 0 && (
                        <div className="mb-6">
                            <h3 className="text-2xl font-bold mb-3">{t.badges}</h3>
                            <div className="flex justify-center gap-3">
                                {playerStats.badges.includes('first_clear') && <div className="text-center"><div className="text-5xl">â­</div><p className="text-sm mt-1">{t.firstClear}</p></div>}
                                {playerStats.badges.includes('perfect_clear') && <div className="text-center"><div className="text-5xl">ğŸ†</div><p className="text-sm mt-1">{t.perfectClear}</p></div>}
                                {playerStats.badges.includes('multiplication_master') && <div className="text-center"><div className="text-5xl">ğŸŒŸ</div><p className="text-sm mt-1">{t.multiplicationMaster}</p></div>}
                            </div>
                        </div>
                    )}

                    <div className="flex flex-col gap-4">
                        <button onClick={nextLevel} className="bg-gradient-to-r from-green-500 to-blue-500 text-white text-3xl font-bold py-6 rounded-2xl hover:from-green-600 hover:to-blue-600">{t.nextLevel}</button>
                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600">{t.menu}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'stats') {
        const subjects = [
            { key: 'math', label: t.subjectMath },
            { key: 'kokugo', label: t.subjectKokugo }
        ];
        const achievementList = [
            { key: 'langNovice', label: t.badgeLangNovice, icon: 'ğŸ“˜' },
            { key: 'readingChamp', label: t.badgeReadingChamp, icon: 'ğŸ“š' },
            { key: 'bugCatcher', label: t.badgeBugCatcher, icon: 'ğŸª²' }
        ];

        return (
            <div className="min-h-screen bg-gradient-to-b from-purple-400 to-blue-400 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-5xl w-full space-y-8">
                    <LanguageSelector />
                    <h2 className="text-4xl font-bold text-center mb-4 text-purple-600">ğŸ† {t.yourStats}</h2>

                    <div className="grid sm:grid-cols-2 lg:grid-cols-4 gap-4">
                        <div className="bg-blue-100 rounded-xl p-4 text-center"><p className="text-lg font-semibold text-blue-800">ğŸ¯ {t.totalDefeated}</p><p className="text-3xl font-bold text-blue-900">{playerStats.totalMonstersDefeated}</p></div>
                        <div className="bg-green-100 rounded-xl p-4 text-center"><p className="text-lg font-semibold text-green-800">ğŸ“ {t.totalQuestions}</p><p className="text-3xl font-bold text-green-900">{playerStats.totalQuestionsAnswered}</p></div>
                        <div className="bg-yellow-100 rounded-xl p-4 text-center"><p className="text-lg font-semibold text-yellow-800">âœ… {t.correctAnswers}</p><p className="text-3xl font-bold text-yellow-900">{playerStats.correctAnswers}</p></div>
                        <div className="bg-purple-100 rounded-xl p-4 text-center"><p className="text-lg font-semibold text-purple-800">ğŸ“Š {t.accuracy}</p><p className="text-3xl font-bold text-purple-900">{playerStats.totalQuestionsAnswered > 0 ? Math.round((playerStats.correctAnswers / playerStats.totalQuestionsAnswered) * 100) : 0}%</p></div>
                    </div>

                    <div>
                        <h3 className="text-2xl font-bold text-gray-700 mb-2">{t.languageStatsTitle}</h3>
                        <p className="text-sm text-gray-500 mb-3">{t.languageStatsDescription}</p>
                        <div className="space-y-4">
                            {subjects.map(subject => {
                                const subjectStats = playerStats.languageStats[subject.key];
                                if (!subjectStats) return null;
                                return (
                                    <div key={subject.key} className="border border-purple-200 rounded-2xl overflow-hidden">
                                        <div className="bg-purple-100 px-4 py-2 font-semibold text-purple-700">{subject.label}</div>
                                        <div className="overflow-x-auto">
                                            <table className="min-w-full text-sm">
                                                <thead className="bg-gray-50 text-gray-600 uppercase tracking-wide">
                                                    <tr>
                                                        <th className="px-4 py-2 text-left">{t.languageColumn}</th>
                                                        <th className="px-4 py-2 text-left">{t.answeredColumn}</th>
                                                        <th className="px-4 py-2 text-left">{t.correctColumn}</th>
                                                        <th className="px-4 py-2 text-left">{t.accuracyColumn}</th>
                                                        {subject.key === 'kokugo' && <th className="px-4 py-2 text-left">{t.comprehensionAccuracy}</th>}
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {SUPPORTED_LANGUAGES.map(code => {
                                                        const stats = subjectStats[code];
                                                        if (!stats) return null;
                                                        const answered = stats.answered || 0;
                                                        const correct = stats.correct || 0;
                                                        const accuracy = answered > 0 ? Math.round((correct / answered) * 100) : 0;
                                                        const compAnswered = stats.comprehensionAnswered || 0;
                                                        const compCorrect = stats.comprehensionCorrect || 0;
                                                        const compAccuracy = compAnswered > 0 ? Math.round((compCorrect / compAnswered) * 100) : 0;
                                                        return (
                                                            <tr key={code} className="odd:bg-white even:bg-gray-50 text-gray-700">
                                                                <td className="px-4 py-2 font-semibold">{LANGUAGE_LABELS[code] || code.toUpperCase()}</td>
                                                                <td className="px-4 py-2">{answered}</td>
                                                                <td className="px-4 py-2">{correct}</td>
                                                                <td className="px-4 py-2">{accuracy}%</td>
                                                                {subject.key === 'kokugo' && <td className="px-4 py-2">{compAccuracy}% ({compCorrect}/{compAnswered})</td>}
                                                            </tr>
                                                        );
                                                    })}
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    <div className="grid sm:grid-cols-2 gap-4">
                        {achievementList.map(ach => {
                            const unlocked = playerStats.achievements && playerStats.achievements[ach.key];
                            return (
                                <div key={ach.key} className={`rounded-2xl p-4 text-center border-2 ${unlocked ? 'border-emerald-400 bg-emerald-50 text-emerald-700' : 'border-gray-200 bg-gray-50 text-gray-400'}`}>
                                    <div className="text-4xl">{ach.icon}</div>
                                    <p className="mt-2 font-semibold">{ach.label}</p>
                                    <p className="text-xs mt-1">{unlocked ? t.congratulations : t.notFound}</p>
                                </div>
                            );
                        })}
                    </div>

                    {playerStats.badges.length > 0 && (
                        <div>
                            <h3 className="text-2xl font-bold mb-3 text-gray-700 text-center">{t.badges}</h3>
                            <div className="flex justify-center gap-4 flex-wrap">
                                {playerStats.badges.includes('first_clear') && <div className="text-center"><div className="text-6xl">â­</div><p className="text-sm mt-1">{t.firstClear}</p></div>}
                                {playerStats.badges.includes('perfect_clear') && <div className="text-center"><div className="text-6xl">ğŸ†</div><p className="text-sm mt-1">{t.perfectClear}</p></div>}
                                {playerStats.badges.includes('multiplication_master') && <div className="text-center"><div className="text-6xl">ğŸŒŸ</div><p className="text-sm mt-1">{t.multiplicationMaster}</p></div>}
                            </div>
                        </div>
                    )}

                    <button onClick={() => setGameState('menu')} className="w-full bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600">{t.back}</button>
                </div>
            </div>
        );
    }



    if (gameState === 'dictionary') {
        const monsterTypes = getMonsterTypes();
        return (
            <div className="min-h-screen bg-gradient-to-b from-green-400 to-blue-400 flex items-center justify-center p-4">
                <CheerToast />
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">ğŸ“– {t.dictionary}</h2>

                    <div className="space-y-4 max-h-96 overflow-y-auto">
                        {monsterTypes.map(monster => {
                            const isUnlocked = playerStats.unlockedMonsters.includes(monster.id);
                            return (
                                <div key={monster.id} className={`rounded-xl p-4 ${isUnlocked ? monster.isBoss ? 'bg-gradient-to-r from-purple-200 to-red-200 border-2 border-purple-400' : 'bg-gradient-to-r from-purple-100 to-pink-100' : 'bg-gray-100'}`}>
                                    <div className="flex items-center gap-4">
                                        <div className={`${monster.isBoss ? 'text-6xl' : 'text-5xl'}`}>{isUnlocked ? monster.emoji : 'â“'}</div>
                                        <div className="flex-1">
                                            <h3 className="text-2xl font-bold flex items-center gap-2">{isUnlocked ? monster.name : 'ï¼Ÿï¼Ÿï¼Ÿ'}{isUnlocked && monster.isBoss && <span className="text-purple-600">ğŸ‘‘ {t.boss}</span>}</h3>
                                            <p className="text-lg text-gray-600">{isUnlocked ? monster.description : t.notFound}</p>
                                            {isUnlocked && monster.isBoss && <p className="text-sm text-purple-600 mt-1">{t.hp}: {monster.health} â¤ï¸</p>}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    <div className="mt-6 text-center text-gray-600"><p className="text-xl font-bold">{playerStats.unlockedMonsters.length} / {getMonsterTypes().length} {t.found}</p></div>

                    <button onClick={() => setGameState('menu')} className="mt-6 w-full bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600">{t.back}</button>
                </div>
            </div>
        );
    }

    return null;
};

// Render
ReactDOM.render(<MathMazeGame />, document.getElementById('root'));
</script>
</body>
</html>








