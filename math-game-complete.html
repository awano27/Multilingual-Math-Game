<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Dungeon - Complete Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes heroFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        @keyframes monsterFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-8px) scale(1.05); }
        }
        @keyframes bossFloat {
            0%, 100% { transform: translateY(0px) scale(1) rotate(0deg); }
            25% { transform: translateY(-5px) scale(1.05) rotate(-5deg); }
            50% { transform: translateY(-10px) scale(1.1) rotate(0deg); }
            75% { transform: translateY(-5px) scale(1.05) rotate(5deg); }
        }
        @keyframes goalRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .animate-hero { animation: heroFloat 2s ease-in-out infinite; }
        .animate-monster { animation: monsterFloat 3s ease-in-out infinite; }
        .animate-boss { animation: bossFloat 1.5s ease-in-out infinite; }
        .animate-goal { animation: goalRotate 3s linear infinite; }
        
        /* Prevent text selection and zooming on mobile */
        body {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        /* Heart icon styles */
        .heart {
            display: inline-block;
            width: 30px;
            height: 30px;
        }
        .heart.filled {
            color: #ef4444;
        }
        .heart.empty {
            color: #d1d5db;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;
        
        const MathMazeGame = () => {
            // Language settings
            const [language, setLanguage] = useState('ja');
            
            // Translations (all languages)
            const translations = {
                ja: {
                    gameTitle: 'ã•ã‚“ã™ã†ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³',
                    startGame: 'ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼',
                    stats: 'ã›ã„ã›ã',
                    dictionary: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãšã‹ã‚“',
                    selectGrade: 'ãŒãã­ã‚“ã‚’ ãˆã‚‰ã¼ã†ï¼',
                    grade2Mode: '2å¹´ç”Ÿãƒ¢ãƒ¼ãƒ‰',
                    grade3Mode: '3å¹´ç”Ÿãƒ¢ãƒ¼ãƒ‰',
                    studyContent: 'ã¹ã‚“ãã‚‡ã†ã™ã‚‹å†…å®¹ï¼š',
                    addition: 'ãŸã—ç®—',
                    subtraction: 'ã²ãç®—',
                    comparison: 'æ•°ã®å¤§å°ãã‚‰ã¹',
                    multiplication: 'ã‹ã‘ç®—ï¼ˆä¹ä¹ï¼‰',
                    division: 'ã‚ã‚Šç®—ï¼ˆã‚ã¾ã‚Šãªã—ï¼‰',
                    back: 'ã‚‚ã©ã‚‹',
                    level: 'ãƒ¬ãƒ™ãƒ«',
                    defeated: 'ãŸãŠã—ãŸ',
                    timeLeft: 'ã®ã“ã‚Šæ™‚é–“',
                    seconds: 'ç§’',
                    correct: 'ã›ã„ã‹ã„ï¼ã™ã”ã„ã­ï¼',
                    incorrect: 'ã–ã‚“ã­ã‚“ï¼ã‚‚ã†ã„ã¡ã©ï¼',
                    timeUp: 'ã˜ã‹ã‚“ãŽã‚Œï¼ã‚‚ã†ã„ã¡ã©ï¼',
                    wall: 'ã‹ã¹ã ã‚ˆï¼ã¹ã¤ã®é“ã‚’ã•ãŒãã†ï¼',
                    gateBlocked: 'ãƒœã‚¹ã‚’ãŸãŠã•ãªã„ã¨ ã¨ãŠã‚Œãªã„ï¼',
                    gateOpened: 'ã‚²ãƒ¼ãƒˆãŒã²ã‚‰ã„ãŸï¼',
                    bossDefeated: 'ãƒœã‚¹ã‚’ãŸãŠã—ãŸï¼ã‚²ãƒ¼ãƒˆãŒã²ã‚‰ãã‚ˆï¼',
                    monsterDefeated: 'ã‚’ãŸãŠã—ãŸï¼',
                    levelClear: 'ãƒ¬ãƒ™ãƒ«',
                    clearMessage: 'ã‚¯ãƒªã‚¢ï¼',
                    nextLevel: 'ã¤ãŽã®ãƒ¬ãƒ™ãƒ«ã¸ï¼',
                    menu: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸',
                    becomeHero: 'ã•ã‚“ã™ã†å‹‡è€…ã«ãªã£ã¦',
                    conquerDungeon: 'ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚’åˆ¶è¦‡ã—ã‚ˆã†ï¼',
                    dungeonExploring: 'ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³æŽ¢ç´¢ä¸­',
                    bossBattle: 'ãƒœã‚¹ãƒãƒˆãƒ«ï¼',
                    appeared: 'ãŒã‚ã‚‰ã‚ã‚ŒãŸï¼',
                    bossWarning: 'ã“ã®ãƒœã‚¹ã‚’ãŸãŠã•ãªã„ã¨ ã‚´ãƒ¼ãƒ«ã§ããªã„ï¼',
                    defeatedBoss: 'ãƒœã‚¹ã‚’ãŸãŠã—ãŸï¼ã‚´ãƒ¼ãƒ«ã¸å‘ã‹ãŠã†ï¼',
                    needDefeatBoss: 'ãƒœã‚¹ã‚’ãŸãŠã•ãªã„ã¨ã‚´ãƒ¼ãƒ«ã§ããªã„ï¼',
                    you: 'ã˜ã¶ã‚“',
                    monster: 'ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼',
                    boss: 'ãƒœã‚¹',
                    gate: 'ã‚²ãƒ¼ãƒˆ',
                    goal: 'ã‚´ãƒ¼ãƒ«',
                    totalDefeated: 'ãœã‚“ã¶ã§ãŸãŠã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼',
                    totalQuestions: 'ã¨ã„ãŸã‚‚ã‚“ã ã„',
                    correctAnswers: 'ã›ã„ã‹ã„ã—ãŸã‚‚ã‚“ã ã„',
                    accuracy: 'ã›ã„ã‹ã„çŽ‡',
                    congratulations: 'ãŠã‚ã§ã¨ã†ï¼',
                    yourStats: 'ãã¿ã®ã›ã„ã›ã',
                    found: 'ã¿ã¤ã‘ãŸ',
                    notFound: 'ã¾ã ã¿ã¤ã‘ã¦ã„ãªã„ã‚ˆ',
                    hp: 'ãŸã„ã‚Šã‚‡ã',
                    whichBigger: 'ã©ã¡ã‚‰ãŒå¤§ãã„ï¼Ÿ',
                    body: 'ä½“',
                    question: 'å•',
                    badges: 'ãƒãƒƒã‚¸',
                    firstClear: 'ã¯ã˜ã‚ã¦ã®ã‚¯ãƒªã‚¢',
                    perfectClear: 'ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆ',
                    multiplicationMaster: 'ä¹ä¹ãƒžã‚¹ã‚¿ãƒ¼',
                    typesOfMonsters: 'ã—ã‚…ã‚‹ã„ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼',
                    hint: 'ãƒ’ãƒ³ãƒˆ: ã˜ã¶ã‚“ã®å­¦å¹´ã«ã‚ã£ãŸãƒ¢ãƒ¼ãƒ‰ã‚’ãˆã‚‰ã¼ã†ï¼',
                    viewHint: 'ãƒ’ãƒ³ãƒˆã‚’ã¿ã‚‹',
                    hideHint: 'ãƒ’ãƒ³ãƒˆã‚’éš ã™',
                    insectMission: 'è™«å–ã‚ŠãƒŸãƒƒã‚·ãƒ§ãƒ³',
                    selectArea: 'ã‚¨ãƒªã‚¢ã‚’é¸ã¼ã†',
                    urawa: 'æµ¦å’Œ',
                    omiya: 'å¤§å®®',
                    iwatsuki: 'å²©æ§»',
                    cicada: 'ã‚»ãƒŸ',
                    cicadaFact: 'å¤§å®®å…¬åœ’ã§ã¯ã‚»ãƒŸãŒãŸãã•ã‚“é³´ã„ã¦ã„ã‚‹ã‚ˆã€‚',
                    beetle: 'ã‚«ãƒ–ãƒˆãƒ ã‚·',
                    beetleFact: 'æµ¦å’Œã§ã¯ã‚«ãƒ–ãƒˆãƒ ã‚·ãŒäººæ°—ã ã‚ˆã€‚',
                    dragonfly: 'ãƒˆãƒ³ãƒœ',
                    dragonflyFact: 'è¦‹æ²¼ç”°ã‚“ã¼ã§ã¯ãƒˆãƒ³ãƒœãŒé£›ã³å›žã£ã¦ã„ã‚‹ã‚ˆã€‚',
                    attemptCapture: 'æ•ç²ã«æŒ‘æˆ¦',
                    captureInsect: 'è™«ã‚’æ•ã¾ãˆã‚ˆã†',
                    captureSuccess: 'æ•ç²æˆåŠŸï¼',
                    captureFail: 'é€ƒã’ã‚‰ã‚ŒãŸï¼'
                },
                en: {
                    gameTitle: 'Math Dungeon',
                    startGame: 'Start Game!',
                    stats: 'Statistics',
                    dictionary: 'Monster Guide',
                    selectGrade: 'Choose Your Grade!',
                    grade2Mode: 'Grade 2 Mode',
                    grade3Mode: 'Grade 3 Mode',
                    studyContent: 'What to Study:',
                    addition: 'Addition',
                    subtraction: 'Subtraction',
                    comparison: 'Number Comparison',
                    multiplication: 'Multiplication',
                    division: 'Division',
                    back: 'Back',
                    level: 'Level',
                    defeated: 'Defeated',
                    timeLeft: 'Time Left',
                    seconds: 'sec',
                    correct: 'Correct! Great job!',
                    incorrect: 'Try again!',
                    timeUp: "Time's up! Try again!",
                    wall: "It's a wall! Find another way!",
                    gateBlocked: 'Defeat the boss to pass!',
                    gateOpened: 'Gate opened!',
                    bossDefeated: 'Boss defeated! Gate will open!',
                    monsterDefeated: ' defeated!',
                    levelClear: 'Level',
                    clearMessage: 'Clear!',
                    nextLevel: 'Next Level!',
                    menu: 'Menu',
                    becomeHero: 'Become a Math Hero',
                    conquerDungeon: 'Conquer the Dungeon!',
                    dungeonExploring: 'Exploring Dungeon',
                    bossBattle: 'Boss Battle!',
                    appeared: ' appeared!',
                    bossWarning: 'Defeat this boss to reach the goal!',
                    defeatedBoss: 'Boss defeated! Head to the goal!',
                    needDefeatBoss: 'Defeat the boss to reach the goal!',
                    you: 'You',
                    monster: 'Monster',
                    boss: 'Boss',
                    gate: 'Gate',
                    goal: 'Goal',
                    totalDefeated: 'Total Monsters Defeated',
                    totalQuestions: 'Questions Answered',
                    correctAnswers: 'Correct Answers',
                    accuracy: 'Accuracy',
                    congratulations: 'Congratulations!',
                    yourStats: 'Your Statistics',
                    found: 'Found',
                    notFound: 'Not discovered yet',
                    hp: 'HP',
                    whichBigger: 'Which is bigger?',
                    body: ' monsters',
                    question: ' questions',
                    badges: 'Badges',
                    firstClear: 'First Clear',
                    perfectClear: 'Perfect',
                    multiplicationMaster: 'Times Table Master',
                    typesOfMonsters: 'types of monsters',
                    hint: 'Hint: Choose the mode for your grade level!',
                    viewHint: 'Show Hint',
                    hideHint: 'Hide Hint',
                    insectMission: 'Insect Mission',
                    selectArea: 'Select Area',
                    urawa: 'Urawa',
                    omiya: 'Omiya',
                    iwatsuki: 'Iwatsuki',
                    cicada: 'Cicada',
                    cicadaFact: 'Many cicadas sing in Omiya Park.',
                    beetle: 'Beetle',
                    beetleFact: 'Beetles are popular in Urawa.',
                    dragonfly: 'Dragonfly',
                    dragonflyFact: 'Dragonflies fly around Minuma Tambo.',
                    attemptCapture: 'Attempt Capture',
                    captureInsect: 'Catch the insect',
                    captureSuccess: 'Captured!',
                    captureFail: 'It escaped!'
                },
                fr: {
                    gameTitle: 'Donjon des Maths',
                    startGame: 'Commencer!',
                    stats: 'Statistiques',
                    dictionary: 'Guide des Monstres',
                    selectGrade: 'Choisissez votre niveau!',
                    grade2Mode: 'Mode 2e annÃ©e',
                    grade3Mode: 'Mode 3e annÃ©e',
                    studyContent: 'Ã€ Ã©tudier:',
                    addition: 'Addition',
                    subtraction: 'Soustraction',
                    comparison: 'Comparaison',
                    multiplication: 'Multiplication',
                    division: 'Division',
                    back: 'Retour',
                    level: 'Niveau',
                    defeated: 'Vaincus',
                    timeLeft: 'Temps restant',
                    seconds: 'sec',
                    correct: 'Correct! Bravo!',
                    incorrect: 'Essaie encore!',
                    timeUp: 'Temps Ã©coulÃ©!',
                    wall: "C'est un mur!",
                    gateBlocked: 'Vaincs le boss pour passer!',
                    gateOpened: 'Porte ouverte!',
                    bossDefeated: 'Boss vaincu!',
                    monsterDefeated: ' vaincu!',
                    levelClear: 'Niveau',
                    clearMessage: 'RÃ©ussi!',
                    nextLevel: 'Niveau suivant!',
                    menu: 'Menu',
                    becomeHero: 'Deviens un hÃ©ros des maths',
                    conquerDungeon: 'Conquiers le donjon!',
                    dungeonExploring: 'Exploration du donjon',
                    bossBattle: 'Combat de boss!',
                    appeared: ' est apparu!',
                    bossWarning: 'Vaincs ce boss pour atteindre le but!',
                    defeatedBoss: 'Boss vaincu! Dirige-toi vers le but!',
                    needDefeatBoss: 'Vaincs le boss pour atteindre le but!',
                    you: 'Toi',
                    monster: 'Monstre',
                    boss: 'Boss',
                    gate: 'Porte',
                    goal: 'But',
                    totalDefeated: 'Total de monstres vaincus',
                    totalQuestions: 'Questions rÃ©pondues',
                    correctAnswers: 'Bonnes rÃ©ponses',
                    accuracy: 'PrÃ©cision',
                    congratulations: 'FÃ©licitations!',
                    yourStats: 'Tes Statistiques',
                    found: 'TrouvÃ©',
                    notFound: 'Pas encore dÃ©couvert',
                    hp: 'PV',
                    whichBigger: 'Lequel est plus grand?',
                    body: ' monstres',
                    question: ' questions',
                    badges: 'Badges',
                    firstClear: 'PremiÃ¨re victoire',
                    perfectClear: 'Parfait',
                    multiplicationMaster: 'MaÃ®tre des tables',
                    typesOfMonsters: 'types de monstres',
                    hint: 'Astuce: Choisis le mode pour ton niveau!',
                    viewHint: "Voir l'indice",
                    hideHint: "Cacher l'indice",
                    insectMission: 'Mission Insecte',
                    selectArea: 'Choisir une zone',
                    urawa: 'Urawa',
                    omiya: 'Omiya',
                    iwatsuki: 'Iwatsuki',
                    cicada: 'Cigale',
                    cicadaFact: 'Beaucoup de cigales chantent au parc Omiya.',
                    beetle: 'ScarabÃ©e',
                    beetleFact: 'Les scarabÃ©es sont populaires Ã  Urawa.',
                    dragonfly: 'Libellule',
                    dragonflyFact: 'Les libellules volent autour de Minuma Tambo.',
                    attemptCapture: 'Tenter la capture',
                    captureInsect: "Attrape l'insecte",
                    captureSuccess: 'CapturÃ©!',
                    captureFail: 'S\'est Ã©chappÃ©!'
                },
                zh: {
                    gameTitle: 'æ•°å­¦åœ°ç‰¢',
                    startGame: 'å¼€å§‹æ¸¸æˆï¼',
                    stats: 'ç»Ÿè®¡',
                    dictionary: 'æ€ªç‰©å›¾é‰´',
                    selectGrade: 'é€‰æ‹©å¹´çº§ï¼',
                    grade2Mode: 'äºŒå¹´çº§æ¨¡å¼',
                    grade3Mode: 'ä¸‰å¹´çº§æ¨¡å¼',
                    studyContent: 'å­¦ä¹ å†…å®¹ï¼š',
                    addition: 'åŠ æ³•',
                    subtraction: 'å‡æ³•',
                    comparison: 'æ•°å­—æ¯”è¾ƒ',
                    multiplication: 'ä¹˜æ³•',
                    division: 'é™¤æ³•',
                    back: 'è¿”å›ž',
                    level: 'å…³å¡',
                    defeated: 'å‡»è´¥',
                    timeLeft: 'å‰©ä½™æ—¶é—´',
                    seconds: 'ç§’',
                    correct: 'æ­£ç¡®ï¼å¤ªæ£’äº†ï¼',
                    incorrect: 'å†è¯•ä¸€æ¬¡ï¼',
                    timeUp: 'æ—¶é—´åˆ°ï¼',
                    wall: 'æ˜¯å¢™ï¼',
                    gateBlocked: 'å‡»è´¥bossæ‰èƒ½é€šè¿‡ï¼',
                    gateOpened: 'å¤§é—¨æ‰“å¼€äº†ï¼',
                    bossDefeated: 'Bossè¢«å‡»è´¥ï¼',
                    monsterDefeated: 'è¢«å‡»è´¥ï¼',
                    levelClear: 'å…³å¡',
                    clearMessage: 'é€šå…³ï¼',
                    nextLevel: 'ä¸‹ä¸€å…³ï¼',
                    menu: 'èœå•',
                    becomeHero: 'æˆä¸ºæ•°å­¦è‹±é›„',
                    conquerDungeon: 'å¾æœåœ°ç‰¢ï¼',
                    dungeonExploring: 'æŽ¢ç´¢åœ°ç‰¢ä¸­',
                    bossBattle: 'Bossæˆ˜ï¼',
                    appeared: 'å‡ºçŽ°äº†ï¼',
                    bossWarning: 'å‡»è´¥è¿™ä¸ªbossæ‰èƒ½åˆ°è¾¾ç»ˆç‚¹ï¼',
                    defeatedBoss: 'Bossè¢«å‡»è´¥ï¼å‰å¾€ç»ˆç‚¹ï¼',
                    needDefeatBoss: 'å‡»è´¥bossæ‰èƒ½åˆ°è¾¾ç»ˆç‚¹ï¼',
                    you: 'ä½ ',
                    monster: 'æ€ªç‰©',
                    boss: 'Boss',
                    gate: 'å¤§é—¨',
                    goal: 'ç»ˆç‚¹',
                    totalDefeated: 'å‡»è´¥æ€ªç‰©æ€»æ•°',
                    totalQuestions: 'å›žç­”é—®é¢˜æ•°',
                    correctAnswers: 'æ­£ç¡®ç­”æ¡ˆæ•°',
                    accuracy: 'æ­£ç¡®çŽ‡',
                    congratulations: 'æ­å–œï¼',
                    yourStats: 'ä½ çš„ç»Ÿè®¡',
                    found: 'å·²å‘çŽ°',
                    notFound: 'å°šæœªå‘çŽ°',
                    hp: 'ç”Ÿå‘½å€¼',
                    whichBigger: 'å“ªä¸ªæ›´å¤§ï¼Ÿ',
                    body: 'åª',
                    question: 'é¢˜',
                    badges: 'å¾½ç« ',
                    firstClear: 'é¦–æ¬¡é€šå…³',
                    perfectClear: 'å®Œç¾Ž',
                    multiplicationMaster: 'ä¹ä¹è¡¨å¤§å¸ˆ',
                    typesOfMonsters: 'ç§æ€ªç‰©',
                    hint: 'æç¤ºï¼šé€‰æ‹©é€‚åˆä½ å¹´çº§çš„æ¨¡å¼ï¼',
                    viewHint: 'æŸ¥çœ‹æç¤º',
                    hideHint: 'éšè—æç¤º',
                    insectMission: 'æ•è™«ä»»åŠ¡',
                    selectArea: 'é€‰æ‹©åœ°åŒº',
                    urawa: 'æµ¦å’Œ',
                    omiya: 'å¤§å®«',
                    iwatsuki: 'å²©æ§»',
                    cicada: 'è‰',
                    cicadaFact: 'åœ¨å¤§å®«å…¬å›­æœ‰å¾ˆå¤šè‰åœ¨å«ã€‚',
                    beetle: 'ç”²è™«',
                    beetleFact: 'ç”²è™«åœ¨æµ¦å’Œå¾ˆå—æ¬¢è¿Žã€‚',
                    dragonfly: 'èœ»èœ“',
                    dragonflyFact: 'èœ»èœ“åœ¨è§æ²¼ç”°åœƒé£žæ¥é£žåŽ»ã€‚',
                    attemptCapture: 'å°è¯•æ•æ‰',
                    captureInsect: 'æ¥æ•æ‰è™«å­',
                    captureSuccess: 'æ•æ‰æˆåŠŸï¼',
                    captureFail: 'é€ƒèµ°äº†ï¼'
                }
            };

            const startCapture = (insectKey) => {
                setCurrentInsect(insectKey);
                setCaptureQuestion(generateProblem('addition'));
                setCaptureResult(null);
                setGameState('insectQuiz');
            };

            const checkCaptureAnswer = (answer) => {
                if (!captureQuestion) return;
                if (answer === captureQuestion.answer) {
                    setCaptureResult('success');
                    if (!capturedInsects.includes(currentInsect)) {
                        setCapturedInsects(prev => [...prev, currentInsect]);
                    }
                } else {
                    setCaptureResult('fail');
                }
            };
            
            const t = translations[language];
            
            // Monster types with multilingual names
            const getMonsterTypes = () => {
                const monsterNames = {
                    ja: {
                        denkiryu: { name: 'ãƒ‡ãƒ³ã‚­ãƒªãƒ¥ã‚¦', desc: 'ã§ã‚“ãã‚¿ã‚¤ãƒ—ï¼ãŸã—ç®—ã§ ã“ã†ã’ãã ï¼' },
                        mizugame: { name: 'ãƒŸã‚ºã‚¬ãƒ¡', desc: 'ã¿ãšã‚¿ã‚¤ãƒ—ï¼ã²ãç®—ã® ã‚ã–ã‚’ ã¯ã¤ï¼' },
                        happamon: { name: 'ãƒãƒƒãƒ‘ãƒ¢ãƒ³', desc: 'ãã•ã‚¿ã‚¤ãƒ—ï¼ã‹ãšã® ã¡ã‹ã‚‰ã‚’ ãã‚‰ã¹ã‚‹ï¼' },
                        honoodon: { name: 'ãƒ›ãƒŽã‚ªãƒ‰ãƒ³', desc: 'ã»ã®ãŠã‚¿ã‚¤ãƒ—ï¼ã‚ã¤ã„ ãŸã—ç®—ã‚’ ã ã™ï¼' },
                        starion: { name: 'ã‚¹ã‚¿ãƒªã‚ªãƒ³', desc: 'ã»ã—ã‚¿ã‚¤ãƒ—ï¼ã‹ã‘ç®—ã® ã»ã—ã‚’ ãµã‚‰ã›ã‚‹ï¼' },
                        crystalos: { name: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ­ã‚¹', desc: 'ã‚¯ãƒªã‚¹ã‚¿ãƒ«ã‚¿ã‚¤ãƒ—ï¼ã‚ã‚Šç®—ã§ ã“ã†ã’ãï¼' },
                        raidenking: { name: 'ãƒ©ã‚¤ãƒ‡ãƒ³ã‚­ãƒ³ã‚°', desc: 'ã§ã‚“ã›ã¤ã® ãƒœã‚¹ï¼ãŸãŠã•ãªã„ã¨ ã•ãã« ã™ã™ã‚ãªã„ï¼' },
                        mathemperor: { name: 'ãƒžã‚¹ã‚¨ãƒ³ãƒšãƒ©ãƒ¼', desc: 'ã•ã‚“ã™ã†ã® ã¦ã„ãŠã†ï¼ä¹ä¹ã‚’ ãƒžã‚¹ã‚¿ãƒ¼ã—ã¦ã„ã‚‹ï¼' }
                    },
                    en: {
                        denkiryu: { name: 'Electrox', desc: 'Electric type! Attacks with addition!' },
                        mizugame: { name: 'Aquaturtle', desc: 'Water type! Uses subtraction skills!' },
                        happamon: { name: 'Leafmon', desc: 'Grass type! Compares number powers!' },
                        honoodon: { name: 'Blazedon', desc: 'Fire type! Throws hot additions!' },
                        starion: { name: 'Starion', desc: 'Star type! Rains multiplication stars!' },
                        crystalos: { name: 'Crystalos', desc: 'Crystal type! Attacks with division!' },
                        raidenking: { name: 'Thunder King', desc: 'Legendary boss! Must defeat to proceed!' },
                        mathemperor: { name: 'Math Emperor', desc: 'Emperor of math! Master of times tables!' }
                    },
                    fr: {
                        denkiryu: { name: 'Ã‰lectryx', desc: 'Type Ã©lectrique! Attaque avec addition!' },
                        mizugame: { name: 'Aquatortue', desc: 'Type eau! Utilise la soustraction!' },
                        happamon: { name: 'Feuilmon', desc: 'Type plante! Compare les nombres!' },
                        honoodon: { name: 'Flammedon', desc: 'Type feu! Lance des additions brÃ»lantes!' },
                        starion: { name: 'Ã‰toilon', desc: 'Type Ã©toile! Pleut des multiplications!' },
                        crystalos: { name: 'Crystalos', desc: 'Type cristal! Attaque avec division!' },
                        raidenking: { name: 'Roi Tonnerre', desc: 'Boss lÃ©gendaire! Ã€ vaincre pour continuer!' },
                        mathemperor: { name: 'Empereur Math', desc: 'Empereur des maths! MaÃ®tre des tables!' }
                    },
                    zh: {
                        denkiryu: { name: 'ç”µé¾™', desc: 'ç”µç³»ï¼ç”¨åŠ æ³•æ”»å‡»ï¼' },
                        mizugame: { name: 'æ°´é¾Ÿ', desc: 'æ°´ç³»ï¼ä½¿ç”¨å‡æ³•æŠ€èƒ½ï¼' },
                        happamon: { name: 'å¶å…½', desc: 'è‰ç³»ï¼æ¯”è¾ƒæ•°å­—åŠ›é‡ï¼' },
                        honoodon: { name: 'ç«ç„°å…½', desc: 'ç«ç³»ï¼å‘å‡ºç‚½çƒ­çš„åŠ æ³•ï¼' },
                        starion: { name: 'æ˜Ÿå…½', desc: 'æ˜Ÿç³»ï¼é™ä¸‹ä¹˜æ³•ä¹‹æ˜Ÿï¼' },
                        crystalos: { name: 'æ°´æ™¶å…½', desc: 'æ°´æ™¶ç³»ï¼ç”¨é™¤æ³•æ”»å‡»ï¼' },
                        raidenking: { name: 'é›·çŽ‹', desc: 'ä¼ è¯´ä¸­çš„Bossï¼å¿…é¡»å‡»è´¥æ‰èƒ½å‰è¿›ï¼' },
                        mathemperor: { name: 'æ•°å­¦çš‡å¸', desc: 'æ•°å­¦çš„å¸çŽ‹ï¼æŽŒæ¡ä¹ä¹è¡¨ï¼' }
                    }
                };

                return [
                    // Grade 2 monsters
                    {
                        id: 'denkiryu',
                        name: monsterNames[language].denkiryu.name,
                        emoji: 'âš¡',
                        problemType: 'addition',
                        description: monsterNames[language].denkiryu.desc,
                        isBoss: false,
                        grade: 2,
                        health: 3
                    },
                    {
                        id: 'mizugame',
                        name: monsterNames[language].mizugame.name,
                        emoji: 'ðŸ¢',
                        problemType: 'subtraction',
                        description: monsterNames[language].mizugame.desc,
                        isBoss: false,
                        grade: 2,
                        health: 3
                    },
                    {
                        id: 'happamon',
                        name: monsterNames[language].happamon.name,
                        emoji: 'ðŸƒ',
                        problemType: 'comparison',
                        description: monsterNames[language].happamon.desc,
                        isBoss: false,
                        grade: 2,
                        health: 3
                    },
                    {
                        id: 'honoodon',
                        name: monsterNames[language].honoodon.name,
                        emoji: 'ðŸ”¥',
                        problemType: 'addition',
                        description: monsterNames[language].honoodon.desc,
                        isBoss: false,
                        grade: 2,
                        health: 3
                    },
                    // Grade 3 monsters
                    {
                        id: 'starion',
                        name: monsterNames[language].starion.name,
                        emoji: 'â­',
                        problemType: 'multiplication',
                        description: monsterNames[language].starion.desc,
                        isBoss: false,
                        grade: 3,
                        health: 3
                    },
                    {
                        id: 'crystalos',
                        name: monsterNames[language].crystalos.name,
                        emoji: 'ðŸ’Ž',
                        problemType: 'division',
                        description: monsterNames[language].crystalos.desc,
                        isBoss: false,
                        grade: 3,
                        health: 3
                    },
                    // Boss monsters
                    {
                        id: 'raidenking',
                        name: monsterNames[language].raidenking.name,
                        emoji: 'ðŸ‘‘',
                        problemType: 'addition',
                        description: monsterNames[language].raidenking.desc,
                        isBoss: true,
                        grade: 2,
                        health: 5
                    },
                    {
                        id: 'mathemperor',
                        name: monsterNames[language].mathemperor.name,
                        emoji: 'ðŸ°',
                        problemType: 'multiplication',
                        description: monsterNames[language].mathemperor.desc,
                        isBoss: true,
                        grade: 3,
                        health: 7
                    }
                ];
            };
            
            // Game state
            const [gameState, setGameState] = useState('menu');
            const [currentLevel, setCurrentLevel] = useState(1);
            const [selectedGrade, setSelectedGrade] = useState(2);
            const [playerPosition, setPlayerPosition] = useState({ x: 0, y: 0 });
            const [maze, setMaze] = useState([]);
            const [mazeSize, setMazeSize] = useState(5);
            const [monsterPositions, setMonsterPositions] = useState([]);
            const [defeatedMonsters, setDefeatedMonsters] = useState([]);
            const [currentMonster, setCurrentMonster] = useState(null);
            const [battleState, setBattleState] = useState(null);
            const [bossGates, setBossGates] = useState([]);
            const [requiredBosses, setRequiredBosses] = useState([]);
            const [timeLeft, setTimeLeft] = useState(30);
            const [message, setMessage] = useState('');
            const [showHint, setShowHint] = useState(false);
            const [selectedArea, setSelectedArea] = useState(null);
            const [currentInsect, setCurrentInsect] = useState(null);
            const [captureQuestion, setCaptureQuestion] = useState(null);
            const [captureResult, setCaptureResult] = useState(null);
            const [capturedInsects, setCapturedInsects] = useState([]);
            const [playerStats, setPlayerStats] = useState({
                totalMonstersDefeated: 0,
                totalQuestionsAnswered: 0,
                correctAnswers: 0,
                unlockedMonsters: [],
                badges: []
            });

            const areaInsects = {
                urawa: { insect: 'beetle' },
                omiya: { insect: 'cicada' },
                iwatsuki: { insect: 'dragonfly' }
            };

            // Language selector component
            const LanguageSelector = () => (
                <div className="flex justify-center gap-2 mb-4">
                    <button 
                        onClick={() => setLanguage('ja')} 
                        className={`px-3 py-1 rounded text-sm font-bold transition-all ${
                            language === 'ja' 
                                ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' 
                                : 'bg-gray-300 hover:bg-gray-400'
                        }`}
                    >
                        æ—¥æœ¬èªž
                    </button>
                    <button 
                        onClick={() => setLanguage('en')} 
                        className={`px-3 py-1 rounded text-sm font-bold transition-all ${
                            language === 'en' 
                                ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' 
                                : 'bg-gray-300 hover:bg-gray-400'
                        }`}
                    >
                        EN
                    </button>
                    <button 
                        onClick={() => setLanguage('fr')} 
                        className={`px-3 py-1 rounded text-sm font-bold transition-all ${
                            language === 'fr' 
                                ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' 
                                : 'bg-gray-300 hover:bg-gray-400'
                        }`}
                    >
                        FR
                    </button>
                    <button 
                        onClick={() => setLanguage('zh')} 
                        className={`px-3 py-1 rounded text-sm font-bold transition-all ${
                            language === 'zh' 
                                ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' 
                                : 'bg-gray-300 hover:bg-gray-400'
                        }`}
                    >
                        ä¸­æ–‡
                    </button>
                </div>
            );

            // Save language preference
            useEffect(() => {
                const saved = localStorage.getItem('gameLanguage');
                if (saved && translations[saved]) setLanguage(saved);
            }, []);

            useEffect(() => {
                localStorage.setItem('gameLanguage', language);
            }, [language]);

            // Generate maze (fixed version)
            const generateMaze = useCallback((size) => {
                const newMaze = Array(size).fill().map(() => Array(size).fill(0));
                
                // Add walls more strategically
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (Math.random() < 0.2 && !(i === 0 && j === 0) && !(i === size-1 && j === size-1)) {
                            newMaze[i][j] = 1; // Wall
                        }
                    }
                }
                
                // Ensure path exists from start to goal
                newMaze[0][0] = 0; // Start
                newMaze[size-1][size-1] = 2; // Goal
                
                // Clear a basic path
                for (let i = 0; i < size - 1; i++) {
                    if (Math.random() < 0.5) {
                        newMaze[i][i] = 0;
                        newMaze[i][i+1] = 0;
                    } else {
                        newMaze[i][i] = 0;
                        newMaze[i+1][i] = 0;
                    }
                }
                
                // Add gate if level > 3
                const gates = [];
                const bosses = [];
                if (currentLevel > 3 && size >= 7) {
                    const gateY = size - 2;
                    const gateX = size - 1;
                    if (newMaze[gateY][gateX] === 0) {
                        newMaze[gateY][gateX] = 3; // Gate
                        gates.push({ x: gateX, y: gateY, id: 'gate-1' });
                    }
                }
                
                // Get grade-appropriate monsters
                const monsterTypes = getMonsterTypes();
                const gradeMonsters = monsterTypes.filter(m => m.grade === selectedGrade);
                const normalMonsters = gradeMonsters.filter(m => !m.isBoss);
                const bossMonsters = gradeMonsters.filter(m => m.isBoss);
                
                // Add monsters
                const monsters = [];
                
                // Add boss if there's a gate
                if (gates.length > 0 && bossMonsters.length > 0) {
                    let bossPlaced = false;
                    for (let attempts = 0; attempts < 50 && !bossPlaced; attempts++) {
                        const x = Math.floor(Math.random() * (size - 2)) + 1;
                        const y = Math.floor(Math.random() * (size - 2)) + 1;
                        
                        if (newMaze[y][x] === 0 && 
                            !(x === 0 && y === 0) && 
                            !(x === size-1 && y === size-1)) {
                            const bossType = bossMonsters[Math.floor(Math.random() * bossMonsters.length)];
                            const bossMonster = { 
                                x, 
                                y, 
                                type: bossType,
                                id: `boss-${gates[0].id}`,
                                isBoss: true
                            };
                            monsters.push(bossMonster);
                            bosses.push(bossMonster.id);
                            bossPlaced = true;
                        }
                    }
                }
                
                // Add normal monsters
                const monsterCount = Math.min(Math.floor(size / 2), 4);
                for (let i = 0; i < monsterCount; i++) {
                    let placed = false;
                    let attempts = 0;
                    while (!placed && attempts < 50) {
                        const x = Math.floor(Math.random() * size);
                        const y = Math.floor(Math.random() * size);
                        if (newMaze[y][x] === 0 && 
                            !(x === 0 && y === 0) && 
                            !(x === size-1 && y === size-1) &&
                            !monsters.some(m => m.x === x && m.y === y)) {
                            const monsterType = normalMonsters[Math.floor(Math.random() * normalMonsters.length)];
                            monsters.push({ 
                                x, 
                                y, 
                                type: monsterType,
                                id: `monster-${i}`,
                                isBoss: false
                            });
                            placed = true;
                        }
                        attempts++;
                    }
                }
                
                setMaze(newMaze);
                setMonsterPositions(monsters);
                setBossGates(gates);
                setRequiredBosses(bosses);
                setPlayerPosition({ x: 0, y: 0 });
                setDefeatedMonsters([]);
            }, [currentLevel, selectedGrade, language]);

            // Generate problem (fixed comparison)
            const generateProblem = (type) => {
                let problem = {};

                switch (type) {
                    case 'addition':
                        const add_a = Math.floor(Math.random() * 20) + 1;
                        const add_b = Math.floor(Math.random() * 20) + 1;
                        problem = {
                            question: `${add_a} + ${add_b} = ?`,
                            answer: add_a + add_b,
                            options: generateOptions(add_a + add_b, 2, 40),
                            hint: `${add_a} + ${add_b} = ?`
                        };
                        break;

                    case 'subtraction':
                        const sub_a = Math.floor(Math.random() * 20) + 10;
                        const sub_b = Math.floor(Math.random() * sub_a) + 1;
                        problem = {
                            question: `${sub_a} - ${sub_b} = ?`,
                            answer: sub_a - sub_b,
                            options: generateOptions(sub_a - sub_b, 0, 20),
                            hint: `${sub_a} - ${sub_b} = ?`
                        };
                        break;

                    case 'comparison':
                        let num1 = Math.floor(Math.random() * 50) + 10;
                        let num2 = Math.floor(Math.random() * 50) + 10;
                        while (num1 === num2) {
                            num2 = Math.floor(Math.random() * 50) + 10;
                        }
                        const bigger = num1 > num2 ? num1 : num2;
                        problem = {
                            question: `${t.whichBigger} ${num1} vs ${num2}`,
                            answer: bigger,
                            options: [num1, num2],
                            comparisonType: true,
                            hint: `${t.whichBigger}`
                        };
                        break;

                    case 'multiplication':
                        const mult_a = Math.floor(Math.random() * 9) + 1;
                        const mult_b = Math.floor(Math.random() * 9) + 1;
                        problem = {
                            question: `${mult_a} Ã— ${mult_b} = ?`,
                            answer: mult_a * mult_b,
                            options: generateOptions(mult_a * mult_b, 1, 81),
                            hint: `${mult_a} Ã— ${mult_b} = ?`
                        };
                        break;

                    case 'division':
                        const divisor = Math.floor(Math.random() * 9) + 1;
                        const quotient = Math.floor(Math.random() * 9) + 1;
                        const dividend = divisor * quotient;
                        problem = {
                            question: `${dividend} Ã· ${divisor} = ?`,
                            answer: quotient,
                            options: generateOptions(quotient, 1, 9),
                            hint: `${dividend} Ã· ${divisor} = ?`
                        };
                        break;
                }

                return problem;
            };

            // Generate options helper
            const generateOptions = (correctAnswer, min, max) => {
                const options = [correctAnswer];
                while (options.length < 4) {
                    const option = Math.floor(Math.random() * (max - min + 1)) + min;
                    if (!options.includes(option)) {
                        options.push(option);
                    }
                }
                return options.sort(() => Math.random() - 0.5);
            };

            // Move player (fixed gate logic)
            const movePlayer = useCallback((direction) => {
                if (gameState !== 'maze') return;
                
                const newPos = { ...playerPosition };
                if (direction === 'up' && newPos.y > 0) newPos.y--;
                if (direction === 'down' && newPos.y < mazeSize - 1) newPos.y++;
                if (direction === 'left' && newPos.x > 0) newPos.x--;
                if (direction === 'right' && newPos.x < mazeSize - 1) newPos.x++;
                
                // Check wall
                if (maze[newPos.y] && maze[newPos.y][newPos.x] === 1) {
                    setMessage(t.wall);
                    setTimeout(() => setMessage(''), 2000);
                    return;
                }
                
                // Check gate
                if (maze[newPos.y] && maze[newPos.y][newPos.x] === 3) {
                    const gate = bossGates.find(g => g.x === newPos.x && g.y === newPos.y);
                    if (gate) {
                        const requiredBossDefeated = requiredBosses.every(bossId => 
                            defeatedMonsters.includes(bossId)
                        );
                        
                        if (!requiredBossDefeated) {
                            setMessage('âš ï¸ ' + t.gateBlocked);
                            setTimeout(() => setMessage(''), 3000);
                            return;
                        } else {
                            const newMaze = [...maze];
                            newMaze[newPos.y][newPos.x] = 0;
                            setMaze(newMaze);
                            setMessage('âœ¨ ' + t.gateOpened);
                            setTimeout(() => setMessage(''), 2000);
                        }
                    }
                }
                
                setPlayerPosition(newPos);
                
                // Check goal
                if (newPos.x === mazeSize - 1 && newPos.y === mazeSize - 1) {
                    handleLevelClear();
                    return;
                }
                
                // Check monster
                const monster = monsterPositions.find(
                    m => m.x === newPos.x && m.y === newPos.y && !defeatedMonsters.includes(m.id)
                );
                if (monster) {
                    startBattle(monster);
                }
            }, [playerPosition, maze, mazeSize, gameState, monsterPositions, defeatedMonsters, bossGates, requiredBosses, t]);

            // Start battle
            const startBattle = (monster) => {
                setCurrentMonster(monster);
                const monsterHealth = monster.type.health || (monster.isBoss ? 5 : 3);
                setBattleState({
                    monsterHealth: monsterHealth,
                    maxHealth: monsterHealth,
                    currentProblem: generateProblem(monster.type.problemType)
                });
                setShowHint(false);
                setTimeLeft(monster.isBoss ? 45 : 30);
                setGameState('battle');
            };

            // Handle level clear
            const handleLevelClear = () => {
                setGameState('victory');
                setMessage(`${t.congratulations} ${t.level} ${currentLevel} ${t.clearMessage}`);
                
                // Add badges
                const newBadges = [];
                if (currentLevel === 1 && !playerStats.badges.includes('first_clear')) {
                    newBadges.push('first_clear');
                }
                if (defeatedMonsters.length === monsterPositions.length && !playerStats.badges.includes('perfect_clear')) {
                    newBadges.push('perfect_clear');
                }
                if (selectedGrade === 3 && !playerStats.badges.includes('multiplication_master')) {
                    newBadges.push('multiplication_master');
                }
                
                if (newBadges.length > 0) {
                    setPlayerStats(prev => ({
                        ...prev,
                        badges: [...prev.badges, ...newBadges]
                    }));
                }
            };

            // Check answer (fixed)
            const checkAnswer = (answer) => {
                if (!battleState || !battleState.currentProblem) return;
                setShowHint(false);

                const isCorrect = answer === battleState.currentProblem.answer;
                
                if (isCorrect) {
                    setMessage(t.correct);
                    setPlayerStats(prev => ({
                        ...prev,
                        correctAnswers: prev.correctAnswers + 1,
                        totalQuestionsAnswered: prev.totalQuestionsAnswered + 1
                    }));
                    
                    const newHealth = battleState.monsterHealth - 1;
                    if (newHealth <= 0) {
                        // Monster defeated
                        setDefeatedMonsters(prev => [...prev, currentMonster.id]);
                        setPlayerStats(prev => ({
                            ...prev,
                            totalMonstersDefeated: prev.totalMonstersDefeated + 1,
                            unlockedMonsters: prev.unlockedMonsters.includes(currentMonster.type.id)
                                ? prev.unlockedMonsters
                                : [...prev.unlockedMonsters, currentMonster.type.id]
                        }));
                        
                        if (currentMonster.isBoss) {
                            setMessage(`ðŸŽ‰ ${t.boss} ${currentMonster.type.name}${t.monsterDefeated}${t.bossDefeated}`);
                        } else {
                            setMessage(`${currentMonster.type.name}${t.monsterDefeated}`);
                        }
                        
                        setTimeout(() => {
                            setGameState('maze');
                            setMessage('');
                        }, 3000);
                    } else {
                        setBattleState({
                            monsterHealth: newHealth,
                            maxHealth: battleState.maxHealth,
                            currentProblem: generateProblem(currentMonster.type.problemType)
                        });
                        setTimeLeft(currentMonster.isBoss ? 45 : 30);
                        setTimeout(() => setMessage(''), 1500);
                    }
                } else {
                    setMessage(t.incorrect);
                    setPlayerStats(prev => ({
                        ...prev,
                        totalQuestionsAnswered: prev.totalQuestionsAnswered + 1
                    }));
                    setTimeout(() => {
                        setMessage('');
                        setBattleState({
                            ...battleState,
                            currentProblem: generateProblem(currentMonster.type.problemType)
                        });
                        setTimeLeft(currentMonster.isBoss ? 45 : 30);
                    }, 1500);
                }
            };

            // Timer
            useEffect(() => {
                if (gameState === 'battle' && timeLeft > 0) {
                    const timer = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);
                    return () => clearTimeout(timer);
                } else if (gameState === 'battle' && timeLeft === 0) {
                    setMessage(t.timeUp);
                    setTimeout(() => {
                        if (currentMonster && battleState) {
                            setBattleState({
                                ...battleState,
                                currentProblem: generateProblem(currentMonster.type.problemType)
                            });
                            setTimeLeft(currentMonster.isBoss ? 45 : 30);
                            setShowHint(false);
                        }
                        setMessage('');
                    }, 2000);
                }
            }, [timeLeft, gameState, battleState, currentMonster, t]);

            // Keyboard controls
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (gameState !== 'maze') return;
                    if (e.key === 'ArrowUp') movePlayer('up');
                    if (e.key === 'ArrowDown') movePlayer('down');
                    if (e.key === 'ArrowLeft') movePlayer('left');
                    if (e.key === 'ArrowRight') movePlayer('right');
                };
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [movePlayer, gameState]);

            // Start game
            const startGameWithGrade = (grade) => {
                setSelectedGrade(grade);
                setCurrentLevel(1);
                setMazeSize(5);
                setTimeout(() => generateMaze(5), 100); // Delay to ensure state is updated
                setGameState('maze');
            };

            // Next level
            const nextLevel = () => {
                const newLevel = currentLevel + 1;
                const newSize = Math.min(5 + Math.floor(newLevel / 2), 9);
                setCurrentLevel(newLevel);
                setMazeSize(newSize);
                setTimeout(() => generateMaze(newSize), 100); // Delay to ensure state is updated
                setGameState('maze');
            };

            // Render based on game state
            if (gameState === 'menu') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-900 to-pink-900 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <LanguageSelector />
                            <h1 className="text-5xl font-bold text-center mb-6 text-purple-600">
                                ðŸŽ® {t.gameTitle} ðŸŽ®
                            </h1>
                            <div className="text-center mb-8">
                                <p className="text-2xl mb-4 text-purple-700">{t.becomeHero}</p>
                                <p className="text-2xl text-pink-700">{t.conquerDungeon}</p>
                            </div>
                            <div className="flex flex-col gap-4">
                                <button
                                    onClick={() => setGameState('gradeSelect')}
                                    className="bg-gradient-to-r from-green-500 to-blue-500 text-white text-2xl font-bold py-4 rounded-2xl hover:from-green-600 hover:to-blue-600 transform hover:scale-105 transition-all"
                                >
                                    âš”ï¸ {t.startGame} âš”ï¸
                                </button>
                                <button
                                    onClick={() => setGameState('map')}
                                    className="bg-gradient-to-r from-lime-500 to-green-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-lime-600 hover:to-green-600"
                                >
                                    ðŸ—ºï¸ {t.insectMission}
                                </button>
                                <button
                                    onClick={() => setGameState('stats')}
                                    className="bg-gradient-to-r from-purple-500 to-pink-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-purple-600 hover:to-pink-600"
                                >
                                    ðŸ† {t.stats}
                                </button>
                                <button 
                                    onClick={() => setGameState('dictionary')} 
                                    className="bg-gradient-to-r from-orange-500 to-red-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-orange-600 hover:to-red-600"
                                >
                                    ðŸ“– {t.dictionary}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'gradeSelect') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-900 to-pink-900 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                            <LanguageSelector />
                            <h2 className="text-4xl font-bold text-center mb-8 text-purple-600">
                                ðŸŽ“ {t.selectGrade} ðŸŽ“
                            </h2>
                            <div className="grid md:grid-cols-2 gap-6">
                                <button 
                                    onClick={() => startGameWithGrade(2)} 
                                    className="bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl p-6 text-white hover:from-blue-600 hover:to-cyan-600 transform hover:scale-105 transition-all"
                                >
                                    <div className="text-5xl mb-4">ðŸ“˜</div>
                                    <h3 className="text-2xl font-bold mb-3">{t.grade2Mode}</h3>
                                    <p className="mb-2">{t.studyContent}</p>
                                    <ul className="mt-2 text-left">
                                        <li>âœ… {t.addition}</li>
                                        <li>âœ… {t.subtraction}</li>
                                        <li>âœ… {t.comparison}</li>
                                    </ul>
                                </button>
                                <button 
                                    onClick={() => startGameWithGrade(3)} 
                                    className="bg-gradient-to-br from-purple-500 to-pink-500 rounded-2xl p-6 text-white hover:from-purple-600 hover:to-pink-600 transform hover:scale-105 transition-all"
                                >
                                    <div className="text-5xl mb-4">ðŸ“•</div>
                                    <h3 className="text-2xl font-bold mb-3">{t.grade3Mode}</h3>
                                    <p className="mb-2">{t.studyContent}</p>
                                    <ul className="mt-2 text-left">
                                        <li>âœ… {t.multiplication}</li>
                                        <li>âœ… {t.division}</li>
                                    </ul>
                                </button>
                            </div>
                            <div className="mt-6 text-center">
                                <button 
                                    onClick={() => setGameState('menu')} 
                                    className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600"
                                >
                                    {t.back}
                                </button>
                            </div>
                            <div className="mt-4 text-center text-gray-600">
                                <p>ðŸ’¡ {t.hint}</p>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'map') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <LanguageSelector />
                            <h2 className="text-3xl font-bold text-center mb-6 text-green-700">ðŸ—ºï¸ {t.selectArea} ðŸ—ºï¸</h2>
                            <div className="flex flex-col gap-4">
                                {['urawa', 'omiya', 'iwatsuki'].map(area => (
                                    <button
                                        key={area}
                                        onClick={() => { setSelectedArea(area); setGameState('area'); }}
                                        className="bg-gradient-to-r from-green-500 to-lime-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-green-600 hover:to-lime-600"
                                    >
                                        {t[area]}
                                    </button>
                                ))}
                            </div>
                            <div className="mt-6 text-center">
                                <button
                                    onClick={() => setGameState('menu')}
                                    className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600"
                                >
                                    {t.back}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'area' && selectedArea) {
                const insectKey = areaInsects[selectedArea].insect;
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <LanguageSelector />
                            <h2 className="text-3xl font-bold text-center mb-6 text-green-700">{t[selectedArea]}</h2>
                            <div className="text-center mb-6">
                                <p className="text-2xl">{t[insectKey]}</p>
                                <p className="mt-2">{t[`${insectKey}Fact`]}</p>
                            </div>
                            <div className="flex flex-col gap-4 items-center">
                                <button
                                    onClick={() => startCapture(insectKey)}
                                    className="bg-green-500 text-white px-6 py-3 rounded-xl hover:bg-green-600"
                                >
                                    {t.attemptCapture}
                                </button>
                                <button
                                    onClick={() => setGameState('map')}
                                    className="bg-gray-500 text-white px-6 py-2 rounded-xl hover:bg-gray-600"
                                >
                                    {t.back}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'insectQuiz' && captureQuestion) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <LanguageSelector />
                            <h2 className="text-3xl font-bold text-center mb-6 text-green-700">{t.captureInsect}</h2>
                            <div className="text-center text-2xl mb-6">{captureQuestion.question}</div>
                            {captureResult ? (
                                <div className="text-center text-2xl mb-6">
                                    {captureResult === 'success' ? t.captureSuccess : t.captureFail}
                                </div>
                            ) : (
                                <div className="grid grid-cols-2 gap-4 mb-6">
                                    {captureQuestion.options.map((opt, idx) => (
                                        <button
                                            key={idx}
                                            onClick={() => checkCaptureAnswer(opt)}
                                            className="bg-purple-500 text-white text-3xl font-bold py-4 rounded-2xl hover:scale-105 transition-all"
                                        >
                                            {opt}
                                        </button>
                                    ))}
                                </div>
                            )}
                            <div className="text-center">
                                <button
                                    onClick={() => setGameState('map')}
                                    className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600"
                                >
                                    {captureResult ? t.selectArea : t.back}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'maze') {
                return (
                    <div className="min-h-screen bg-gradient-to-b from-indigo-950 to-slate-950 p-4">
                        <div className="max-w-4xl mx-auto">
                            <div className="bg-purple-900/80 rounded-2xl p-4 mb-4">
                                <div className="flex justify-between items-center flex-wrap gap-2">
                                    <div className="text-2xl font-bold text-white">
                                        {t.level} {currentLevel}
                                    </div>
                                    <div className="text-xl text-yellow-400">
                                        âš”ï¸ {t.defeated}: {defeatedMonsters.length}/{monsterPositions.length}
                                    </div>
                                    <button 
                                        onClick={() => setGameState('menu')} 
                                        className="bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                                    >
                                        {t.menu}
                                    </button>
                                </div>
                                {requiredBosses.length > 0 && (
                                    <div className="mt-2 text-center">
                                        {requiredBosses.every(id => defeatedMonsters.includes(id)) ? (
                                            <span className="text-green-400 font-bold text-lg animate-pulse">
                                                âœ¨ {t.defeatedBoss} âœ¨
                                            </span>
                                        ) : (
                                            <span className="text-orange-400 font-bold text-lg animate-pulse">
                                                âš ï¸ {t.needDefeatBoss} âš ï¸
                                            </span>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            {message && (
                                <div className="bg-yellow-500 text-white text-center text-2xl font-bold p-3 rounded-xl mb-4 animate-bounce">
                                    {message}
                                </div>
                            )}
                            
                            <div className="bg-slate-900 rounded-3xl p-8">
                                <h3 className="text-2xl font-bold text-center mb-4 text-white">
                                    âš”ï¸ {t.dungeonExploring} âš”ï¸
                                </h3>
                                
                                <div 
                                    className="grid gap-1 mx-auto" 
                                    style={{
                                        gridTemplateColumns: `repeat(${mazeSize}, minmax(0, 1fr))`,
                                        maxWidth: `${mazeSize * 60}px`
                                    }}
                                >
                                    {maze.map((row, y) => 
                                        row.map((cell, x) => {
                                            const isPlayer = playerPosition.x === x && playerPosition.y === y;
                                            const monster = monsterPositions.find(
                                                m => m.x === x && m.y === y && !defeatedMonsters.includes(m.id)
                                            );
                                            const isGoal = x === mazeSize - 1 && y === mazeSize - 1;
                                            const isGate = cell === 3;
                                            const isBossMonster = monster && monster.isBoss;
                                            
                                            return (
                                                <div 
                                                    key={`${x}-${y}`} 
                                                    className={`
                                                        aspect-square flex items-center justify-center rounded text-3xl
                                                        ${cell === 1 ? 'bg-gray-800' : 'bg-teal-900/40'}
                                                        ${isGoal && !isPlayer ? 'bg-gradient-to-br from-yellow-500 to-orange-500' : ''}
                                                        ${isGate ? 'bg-gradient-to-br from-red-900 to-orange-800' : ''}
                                                    `}
                                                >
                                                    {isPlayer && <span className="animate-hero">ðŸ¦¸</span>}
                                                    {monster && (
                                                        <span className={isBossMonster ? "animate-boss" : "animate-monster"}>
                                                            {monster.type.emoji}
                                                        </span>
                                                    )}
                                                    {isGoal && !isPlayer && <span className="animate-goal">ðŸ</span>}
                                                    {isGate && !isPlayer && <span className="text-2xl">ðŸ”’</span>}
                                                </div>
                                            );
                                        })
                                    )}
                                </div>
                                
                                <div className="mt-6 flex justify-center gap-2 text-sm">
                                    <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white">
                                        <div className="w-4 h-4 bg-blue-500 rounded"></div>
                                        <span>{t.you}</span>
                                    </div>
                                    <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white">
                                        <div className="w-4 h-4 bg-red-500 rounded"></div>
                                        <span>{t.monster}</span>
                                    </div>
                                    <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white">
                                        <div className="w-4 h-4 bg-purple-500 rounded"></div>
                                        <span>{t.boss}</span>
                                    </div>
                                </div>
                                
                                <div className="mt-6 flex flex-col items-center">
                                    <button 
                                        onClick={() => movePlayer('up')} 
                                        className="bg-blue-600 text-white p-3 rounded-xl mb-2 hover:bg-blue-700"
                                    >
                                        â¬†ï¸
                                    </button>
                                    <div className="flex gap-2">
                                        <button 
                                            onClick={() => movePlayer('left')} 
                                            className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700"
                                        >
                                            â¬…ï¸
                                        </button>
                                        <button 
                                            onClick={() => movePlayer('down')} 
                                            className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700"
                                        >
                                            â¬‡ï¸
                                        </button>
                                        <button 
                                            onClick={() => movePlayer('right')} 
                                            className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700"
                                        >
                                            âž¡ï¸
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'battle' && currentMonster && battleState) {
                return (
                    <div className={`min-h-screen ${currentMonster.isBoss ? 'bg-gradient-to-b from-purple-600 to-red-600' : 'bg-gradient-to-b from-red-400 to-orange-400'} flex items-center justify-center p-4`}>
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <div className="text-center mb-6">
                                <div className={`${currentMonster.isBoss ? 'text-8xl' : 'text-6xl'} mb-4`}>
                                    {currentMonster.type.emoji}
                                </div>
                                <h2 className="text-3xl font-bold text-purple-600">
                                    {currentMonster.isBoss && `ðŸ’€ ${t.bossBattle} ðŸ’€`}
                                    {!currentMonster.isBoss && `${currentMonster.type.name}${t.appeared}`}
                                    {currentMonster.isBoss && <div className="text-2xl mt-2">{currentMonster.type.name}</div>}
                                </h2>
                                <p className="text-xl mt-2">{currentMonster.type.description}</p>
                            </div>
                            
                            <div className="flex justify-center gap-2 mb-6">
                                {[...Array(battleState.maxHealth)].map((_, i) => (
                                    <span 
                                        key={i} 
                                        className={`heart ${i < battleState.monsterHealth ? 'filled' : 'empty'}`}
                                    >
                                        â¤ï¸
                                    </span>
                                ))}
                            </div>
                            
                            <div className={`text-center text-3xl font-bold mb-6 ${timeLeft <= 10 ? 'text-red-600 animate-pulse' : 'text-blue-600'}`}>
                                {t.timeLeft}: {timeLeft}{t.seconds}
                            </div>
                            
                            <div className="bg-blue-100 rounded-2xl p-6 mb-6">
                                <div className="text-4xl font-bold text-center text-blue-800">
                                    {battleState.currentProblem.question}
                                </div>
                            </div>
                            
                            {message && (
                                <div className={`text-center text-2xl font-bold mb-4 ${message.includes(t.correct) ? 'text-green-600' : 'text-orange-600'}`}>
                                    {message}
                                </div>
                            )}

                            {battleState.currentProblem.hint && (
                                <div className="text-center mb-4">
                                    <button
                                        onClick={() => setShowHint(!showHint)}
                                        className="bg-yellow-300 text-yellow-800 font-bold px-4 py-2 rounded-lg hover:bg-yellow-400"
                                    >
                                        {showHint ? t.hideHint : t.viewHint}
                                    </button>
                                </div>
                            )}

                            {showHint && battleState.currentProblem.hint && (
                                <div className="text-center text-xl text-yellow-800 mb-4">
                                    {battleState.currentProblem.hint}
                                </div>
                            )}

                            <div className={`grid ${battleState.currentProblem.comparisonType ? 'grid-cols-2' : 'grid-cols-2'} gap-4`}>
                                {battleState.currentProblem.options.map((option, index) => (
                                    <button
                                        key={index}
                                        onClick={() => checkAnswer(option)}
                                        className={`${currentMonster.isBoss 
                                            ? 'bg-gradient-to-r from-purple-600 to-red-600' 
                                            : 'bg-gradient-to-r from-purple-500 to-pink-500'} 
                                            text-white text-3xl font-bold py-6 rounded-2xl 
                                            hover:scale-105 transition-all`}
                                        disabled={message !== ''}
                                    >
                                        {option}
                                    </button>
                                ))}
                            </div>
                            
                            {currentMonster.isBoss && (
                                <div className="mt-4 text-center text-red-600 font-bold animate-pulse">
                                    âš ï¸ {t.bossWarning} âš ï¸
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (gameState === 'victory') {
                return (
                    <div className="min-h-screen bg-gradient-to-b from-yellow-400 to-orange-400 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full text-center">
                            <div className="text-6xl mb-4">ðŸŽ‰ðŸ†ðŸŽ‰</div>
                            <h1 className="text-5xl font-bold text-purple-600 mb-6">
                                {t.level} {currentLevel} {t.clearMessage}
                            </h1>
                            <div className="bg-blue-100 rounded-2xl p-6 mb-6">
                                <p className="text-2xl mb-2">{t.defeated}: {defeatedMonsters.length}{t.body}</p>
                                <p className="text-2xl">
                                    {t.accuracy}: {playerStats.totalQuestionsAnswered > 0 
                                        ? Math.round((playerStats.correctAnswers / playerStats.totalQuestionsAnswered) * 100) 
                                        : 0}%
                                </p>
                            </div>
                            
                            {playerStats.badges.length > 0 && (
                                <div className="mb-6">
                                    <h3 className="text-2xl font-bold mb-3">{t.badges}</h3>
                                    <div className="flex justify-center gap-3">
                                        {playerStats.badges.includes('first_clear') && (
                                            <div className="text-center">
                                                <div className="text-5xl">â­</div>
                                                <p className="text-sm mt-1">{t.firstClear}</p>
                                            </div>
                                        )}
                                        {playerStats.badges.includes('perfect_clear') && (
                                            <div className="text-center">
                                                <div className="text-5xl">ðŸ†</div>
                                                <p className="text-sm mt-1">{t.perfectClear}</p>
                                            </div>
                                        )}
                                        {playerStats.badges.includes('multiplication_master') && (
                                            <div className="text-center">
                                                <div className="text-5xl">ðŸŒŸ</div>
                                                <p className="text-sm mt-1">{t.multiplicationMaster}</p>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            <div className="flex flex-col gap-4">
                                <button 
                                    onClick={nextLevel} 
                                    className="bg-gradient-to-r from-green-500 to-blue-500 text-white text-3xl font-bold py-6 rounded-2xl hover:from-green-600 hover:to-blue-600"
                                >
                                    {t.nextLevel}
                                </button>
                                <button 
                                    onClick={() => setGameState('menu')} 
                                    className="bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600"
                                >
                                    {t.menu}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'stats') {
                return (
                    <div className="min-h-screen bg-gradient-to-b from-purple-400 to-blue-400 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <LanguageSelector />
                            <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">
                                ðŸ† {t.yourStats}
                            </h2>
                            <div className="space-y-4">
                                <div className="bg-blue-100 rounded-xl p-4">
                                    <p className="text-2xl">ðŸŽ¯ {t.totalDefeated}: {playerStats.totalMonstersDefeated}{t.body}</p>
                                </div>
                                <div className="bg-green-100 rounded-xl p-4">
                                    <p className="text-2xl">ðŸ“ {t.totalQuestions}: {playerStats.totalQuestionsAnswered}{t.question}</p>
                                </div>
                                <div className="bg-yellow-100 rounded-xl p-4">
                                    <p className="text-2xl">âœ… {t.correctAnswers}: {playerStats.correctAnswers}{t.question}</p>
                                </div>
                                <div className="bg-purple-100 rounded-xl p-4">
                                    <p className="text-2xl">
                                        ðŸ“Š {t.accuracy}: {playerStats.totalQuestionsAnswered > 0 
                                            ? Math.round((playerStats.correctAnswers / playerStats.totalQuestionsAnswered) * 100) 
                                            : 0}%
                                    </p>
                                </div>
                            </div>
                            
                            {playerStats.badges.length > 0 && (
                                <div className="mt-6">
                                    <h3 className="text-2xl font-bold mb-3 text-center">{t.badges}</h3>
                                    <div className="flex justify-center gap-4 flex-wrap">
                                        {playerStats.badges.includes('first_clear') && (
                                            <div className="text-center">
                                                <div className="text-6xl">â­</div>
                                                <p className="text-sm mt-1">{t.firstClear}</p>
                                            </div>
                                        )}
                                        {playerStats.badges.includes('perfect_clear') && (
                                            <div className="text-center">
                                                <div className="text-6xl">ðŸ†</div>
                                                <p className="text-sm mt-1">{t.perfectClear}</p>
                                            </div>
                                        )}
                                        {playerStats.badges.includes('multiplication_master') && (
                                            <div className="text-center">
                                                <div className="text-6xl">ðŸŒŸ</div>
                                                <p className="text-sm mt-1">{t.multiplicationMaster}</p>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            <button 
                                onClick={() => setGameState('menu')} 
                                className="mt-6 w-full bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600"
                            >
                                {t.back}
                            </button>
                        </div>
                    </div>
                );
            }

            if (gameState === 'dictionary') {
                const monsterTypes = getMonsterTypes();
                return (
                    <div className="min-h-screen bg-gradient-to-b from-green-400 to-blue-400 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                            <LanguageSelector />
                            <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">
                                ðŸ“– {t.dictionary}
                            </h2>
                            
                            <div className="space-y-4 max-h-96 overflow-y-auto">
                                {monsterTypes.map((monster) => {
                                    const isUnlocked = playerStats.unlockedMonsters.includes(monster.id);
                                    
                                    return (
                                        <div 
                                            key={monster.id}
                                            className={`rounded-xl p-4 ${
                                                isUnlocked 
                                                    ? monster.isBoss 
                                                        ? 'bg-gradient-to-r from-purple-200 to-red-200 border-2 border-purple-400' 
                                                        : 'bg-gradient-to-r from-purple-100 to-pink-100'
                                                    : 'bg-gray-100'
                                            }`}
                                        >
                                            <div className="flex items-center gap-4">
                                                <div className={`${monster.isBoss ? 'text-6xl' : 'text-5xl'}`}>
                                                    {isUnlocked ? monster.emoji : 'â“'}
                                                </div>
                                                <div className="flex-1">
                                                    <h3 className="text-2xl font-bold flex items-center gap-2">
                                                        {isUnlocked ? monster.name : 'ï¼Ÿï¼Ÿï¼Ÿ'}
                                                        {isUnlocked && monster.isBoss && (
                                                            <span className="text-purple-600">ðŸ‘‘ {t.boss}</span>
                                                        )}
                                                    </h3>
                                                    <p className="text-lg text-gray-600">
                                                        {isUnlocked ? monster.description : t.notFound}
                                                    </p>
                                                    {isUnlocked && monster.isBoss && (
                                                        <p className="text-sm text-purple-600 mt-1">
                                                            {t.hp}: {monster.health} â¤ï¸
                                                        </p>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                            
                            <div className="mt-6 text-center text-gray-600">
                                <p className="text-xl font-bold">
                                    {playerStats.unlockedMonsters.length} / {monsterTypes.length} {t.found}
                                </p>
                            </div>
                            
                            <button 
                                onClick={() => setGameState('menu')} 
                                className="mt-6 w-full bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600"
                            >
                                {t.back}
                            </button>
                        </div>
                    </div>
                );
            }

            return null;
        };

        // Render the app
        ReactDOM.render(<MathMazeGame />, document.getElementById('root'));
    </script>
</body>
</html>