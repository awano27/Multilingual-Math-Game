<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Math Dungeon - Complete Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes heroFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        @keyframes monsterFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-8px) scale(1.05); }
        }
        @keyframes bossFloat {
            0%, 100% { transform: translateY(0px) scale(1) rotate(0deg); }
            25% { transform: translateY(-5px) scale(1.05) rotate(-5deg); }
            50% { transform: translateY(-10px) scale(1.1) rotate(0deg); }
            75% { transform: translateY(-5px) scale(1.05) rotate(5deg); }
        }
        @keyframes goalRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .animate-hero { animation: heroFloat 2s ease-in-out infinite; }
        .animate-monster { animation: monsterFloat 3s ease-in-out infinite; }
        .animate-boss { animation: bossFloat 1.5s ease-in-out infinite; }
        .animate-goal { animation: goalRotate 3s linear infinite; }

        /* Prevent text selection and zooming on mobile */
        body {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        /* Heart icon styles */
        .heart {
            display: inline-block;
            width: 30px;
            height: 30px;
        }
        .heart.filled {
            color: #ef4444;
        }
        .heart.empty {
            color: #d1d5db;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useCallback } = React;

const MathMazeGame = () => {
    // Language settings
    const [language, setLanguage] = useState('ja');

    // Translations (all languages)
    const translations = {
        ja: {
            gameTitle: '„Åï„Çì„Åô„ÅÜ„ÉÄ„É≥„Ç∏„Éß„É≥',
            startGame: '„Ç≤„Éº„É†„Çπ„Çø„Éº„ÉàÔºÅ',
            stats: '„Åõ„ÅÑ„Åõ„Åç',
            dictionary: '„É¢„É≥„Çπ„Çø„Éº„Åö„Åã„Çì',
            selectGrade: '„Åå„Åè„Å≠„Çì„Çí „Åà„Çâ„Åº„ÅÜÔºÅ',
            grade2Mode: '2Âπ¥Áîü„É¢„Éº„Éâ',
            grade3Mode: '3Âπ¥Áîü„É¢„Éº„Éâ',
            studyContent: '„Åπ„Çì„Åç„Çá„ÅÜ„Åô„ÇãÂÜÖÂÆπÔºö',
            addition: '„Åü„ÅóÁÆó',
            subtraction: '„Å≤„ÅçÁÆó',
            comparison: 'Êï∞„ÅÆÂ§ßÂ∞è„Åè„Çâ„Åπ',
            multiplication: '„Åã„ÅëÁÆóÔºà‰πù‰πùÔºâ',
            division: '„Çè„ÇäÁÆóÔºà„ÅÇ„Åæ„Çä„Å™„ÅóÔºâ',
            back: '„ÇÇ„Å©„Çã',
            level: '„É¨„Éô„É´',
            defeated: '„Åü„Åä„Åó„Åü',
            timeLeft: '„ÅÆ„Åì„ÇäÊôÇÈñì',
            seconds: 'Áßí',
            correct: '„Åõ„ÅÑ„Åã„ÅÑÔºÅ„Åô„Åî„ÅÑ„Å≠ÔºÅ',
            incorrect: '„Åñ„Çì„Å≠„ÇìÔºÅ„ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÔºÅ',
            timeUp: '„Åò„Åã„Çì„Åé„ÇåÔºÅ„ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÔºÅ',
            wall: '„Åã„Åπ„Å†„ÇàÔºÅ„Åπ„Å§„ÅÆÈÅì„Çí„Åï„Åå„Åù„ÅÜÔºÅ',
            gateBlocked: '„Éú„Çπ„Çí„Åü„Åä„Åï„Å™„ÅÑ„Å® „Å®„Åä„Çå„Å™„ÅÑÔºÅ',
            gateOpened: '„Ç≤„Éº„Éà„Åå„Å≤„Çâ„ÅÑ„ÅüÔºÅ',
            bossDefeated: '„Éú„Çπ„Çí„Åü„Åä„Åó„ÅüÔºÅ„Ç≤„Éº„Éà„Åå„Å≤„Çâ„Åè„ÇàÔºÅ',
            monsterDefeated: '„Çí„Åü„Åä„Åó„ÅüÔºÅ',
            levelClear: '„É¨„Éô„É´',
            clearMessage: '„ÇØ„É™„Ç¢ÔºÅ',
            nextLevel: '„Å§„Åé„ÅÆ„É¨„Éô„É´„Å∏ÔºÅ',
            menu: '„É°„Éã„É•„Éº„Å∏',
            becomeHero: '„Åï„Çì„Åô„ÅÜÂãáËÄÖ„Å´„Å™„Å£„Å¶',
            conquerDungeon: '„ÉÄ„É≥„Ç∏„Éß„É≥„ÇíÂà∂Ë¶á„Åó„Çà„ÅÜÔºÅ',
            dungeonExploring: '„ÉÄ„É≥„Ç∏„Éß„É≥Êé¢Á¥¢‰∏≠',
            bossBattle: '„Éú„Çπ„Éê„Éà„É´ÔºÅ',
            appeared: '„Åå„ÅÇ„Çâ„Çè„Çå„ÅüÔºÅ',
            bossWarning: '„Åì„ÅÆ„Éú„Çπ„Çí„Åü„Åä„Åï„Å™„ÅÑ„Å® „Ç¥„Éº„É´„Åß„Åç„Å™„ÅÑÔºÅ',
            defeatedBoss: '„Éú„Çπ„Çí„Åü„Åä„Åó„ÅüÔºÅ„Ç¥„Éº„É´„Å∏Âêë„Åã„Åä„ÅÜÔºÅ',
            needDefeatBoss: '„Éú„Çπ„Çí„Åü„Åä„Åï„Å™„ÅÑ„Å®„Ç¥„Éº„É´„Åß„Åç„Å™„ÅÑÔºÅ',
            you: '„Åò„Å∂„Çì',
            monster: '„É¢„É≥„Çπ„Çø„Éº',
            boss: '„Éú„Çπ',
            gate: '„Ç≤„Éº„Éà',
            goal: '„Ç¥„Éº„É´',
            totalDefeated: '„Åú„Çì„Å∂„Åß„Åü„Åä„Åó„Åü„É¢„É≥„Çπ„Çø„Éº',
            totalQuestions: '„Å®„ÅÑ„Åü„ÇÇ„Çì„Å†„ÅÑ',
            correctAnswers: '„Åõ„ÅÑ„Åã„ÅÑ„Åó„Åü„ÇÇ„Çì„Å†„ÅÑ',
            accuracy: '„Åõ„ÅÑ„Åã„ÅÑÁéá',
            congratulations: '„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ',
            yourStats: '„Åç„Åø„ÅÆ„Åõ„ÅÑ„Åõ„Åç',
            found: '„Åø„Å§„Åë„Åü',
            notFound: '„Åæ„Å†„Åø„Å§„Åë„Å¶„ÅÑ„Å™„ÅÑ„Çà',
            hp: '„Åü„ÅÑ„Çä„Çá„Åè',
            whichBigger: '„Å©„Å°„Çâ„ÅåÂ§ß„Åç„ÅÑÔºü',
            body: '‰Ωì',
            question: 'Âïè',
            badges: '„Éê„ÉÉ„Ç∏',
            firstClear: '„ÅØ„Åò„ÇÅ„Å¶„ÅÆ„ÇØ„É™„Ç¢',
            perfectClear: '„Éë„Éº„Éï„Çß„ÇØ„Éà',
            multiplicationMaster: '‰πù‰πù„Éû„Çπ„Çø„Éº',
            typesOfMonsters: '„Åó„ÇÖ„Çã„ÅÑ„ÅÆ„É¢„É≥„Çπ„Çø„Éº',
            hint: '„Éí„É≥„Éà: „Åò„Å∂„Çì„ÅÆÂ≠¶Âπ¥„Å´„ÅÇ„Å£„Åü„É¢„Éº„Éâ„Çí„Åà„Çâ„Åº„ÅÜÔºÅ',
            viewHint: '„Éí„É≥„Éà„Çí„Åø„Çã',
            hideHint: '„Éí„É≥„Éà„ÇíÈö†„Åô',
            insectMission: 'Ëô´Âèñ„Çä„Éü„ÉÉ„Ç∑„Éß„É≥',
            selectArea: '„Ç®„É™„Ç¢„ÇíÈÅ∏„Åº„ÅÜ',
            urawa: 'Êµ¶Âíå',
            omiya: 'Â§ßÂÆÆ',
            iwatsuki: 'Â≤©Êßª',
            cicada: '„Çª„Éü',
            cicadaFact: 'Â§ßÂÆÆÂÖ¨Âúí„Åß„ÅØ„Çª„Éü„Åå„Åü„Åè„Åï„ÇìÈ≥¥„ÅÑ„Å¶„ÅÑ„Çã„Çà„ÄÇ',
            beetle: '„Ç´„Éñ„Éà„É†„Ç∑',
            beetleFact: 'Êµ¶Âíå„Åß„ÅØ„Ç´„Éñ„Éà„É†„Ç∑„Åå‰∫∫Ê∞ó„Å†„Çà„ÄÇ',
            dragonfly: '„Éà„É≥„Éú',
            dragonflyFact: 'Ë¶ãÊ≤ºÁî∞„Çì„Åº„Åß„ÅØ„Éà„É≥„Éú„ÅåÈ£õ„Å≥Âõû„Å£„Å¶„ÅÑ„Çã„Çà„ÄÇ',
            attemptCapture: 'ÊçïÁç≤„Å´ÊåëÊà¶',
            captureInsect: 'Ëô´„ÇíÊçï„Åæ„Åà„Çà„ÅÜ',
            captureSuccess: 'ÊçïÁç≤ÊàêÂäüÔºÅ',
            captureFail: 'ÈÄÉ„Åí„Çâ„Çå„ÅüÔºÅ'
        },
        en: {
            gameTitle: 'Math Dungeon',
            startGame: 'Start Game!',
            stats: 'Statistics',
            dictionary: 'Monster Guide',
            selectGrade: 'Choose Your Grade!',
            grade2Mode: 'Grade 2 Mode',
            grade3Mode: 'Grade 3 Mode',
            studyContent: 'What to Study:',
            addition: 'Addition',
            subtraction: 'Subtraction',
            comparison: 'Number Comparison',
            multiplication: 'Multiplication',
            division: 'Division',
            back: 'Back',
            level: 'Level',
            defeated: 'Defeated',
            timeLeft: 'Time Left',
            seconds: 'sec',
            correct: 'Correct! Great job!',
            incorrect: 'Try again!',
            timeUp: "Time's up! Try again!",
            wall: "It's a wall! Find another way!",
            gateBlocked: 'Defeat the boss to pass!',
            gateOpened: 'Gate opened!',
            bossDefeated: 'Boss defeated! Gate will open!',
            monsterDefeated: ' defeated!',
            levelClear: 'Level',
            clearMessage: 'Clear!',
            nextLevel: 'Next Level!',
            menu: 'Menu',
            becomeHero: 'Become a Math Hero',
            conquerDungeon: 'Conquer the Dungeon!',
            dungeonExploring: 'Exploring Dungeon',
            bossBattle: 'Boss Battle!',
            appeared: ' appeared!',
            bossWarning: 'Defeat this boss to reach the goal!',
            defeatedBoss: 'Boss defeated! Head to the goal!',
            needDefeatBoss: 'Defeat the boss to reach the goal!',
            you: 'You',
            monster: 'Monster',
            boss: 'Boss',
            gate: 'Gate',
            goal: 'Goal',
            totalDefeated: 'Total Monsters Defeated',
            totalQuestions: 'Questions Answered',
            correctAnswers: 'Correct Answers',
            accuracy: 'Accuracy',
            congratulations: 'Congratulations!',
            yourStats: 'Your Statistics',
            found: 'Found',
            notFound: 'Not discovered yet',
            hp: 'HP',
            whichBigger: 'Which is bigger?',
            body: ' monsters',
            question: ' questions',
            badges: 'Badges',
            firstClear: 'First Clear',
            perfectClear: 'Perfect',
            multiplicationMaster: 'Times Table Master',
            typesOfMonsters: 'types of monsters',
            hint: 'Hint: Choose the mode for your grade level!',
            viewHint: 'Show Hint',
            hideHint: 'Hide Hint',
            insectMission: 'Insect Mission',
            selectArea: 'Select Area',
            urawa: 'Urawa',
            omiya: 'Omiya',
            iwatsuki: 'Iwatsuki',
            cicada: 'Cicada',
            cicadaFact: 'Many cicadas sing in Omiya Park.',
            beetle: 'Beetle',
            beetleFact: 'Beetles are popular in Urawa.',
            dragonfly: 'Dragonfly',
            dragonflyFact: 'Dragonflies fly around Minuma Tambo.',
            attemptCapture: 'Attempt Capture',
            captureInsect: 'Catch the insect',
            captureSuccess: 'Captured!',
            captureFail: 'It escaped!'
        },
        fr: {
            gameTitle: 'Donjon des Maths',
            startGame: 'Commencer!',
            stats: 'Statistiques',
            dictionary: 'Guide des Monstres',
            selectGrade: 'Choisissez votre niveau!',
            grade2Mode: 'Mode 2e ann√©e',
            grade3Mode: 'Mode 3e ann√©e',
            studyContent: '√Ä √©tudier:',
            addition: 'Addition',
            subtraction: 'Soustraction',
            comparison: 'Comparaison',
            multiplication: 'Multiplication',
            division: 'Division',
            back: 'Retour',
            level: 'Niveau',
            defeated: 'Vaincus',
            timeLeft: 'Temps restant',
            seconds: 'sec',
            correct: 'Correct! Bravo!',
            incorrect: 'Essaie encore!',
            timeUp: 'Temps √©coul√©!',
            wall: "C'est un mur!",
            gateBlocked: 'Vaincs le boss pour passer!',
            gateOpened: 'Porte ouverte!',
            bossDefeated: 'Boss vaincu!',
            monsterDefeated: ' vaincu!',
            levelClear: 'Niveau',
            clearMessage: 'R√©ussi!',
            nextLevel: 'Niveau suivant!',
            menu: 'Menu',
            becomeHero: 'Deviens un h√©ros des maths',
            conquerDungeon: 'Conquiers le donjon!',
            dungeonExploring: 'Exploration du donjon',
            bossBattle: 'Combat de boss!',
            appeared: ' est apparu!',
            bossWarning: 'Vaincs ce boss pour atteindre le but!',
            defeatedBoss: 'Boss vaincu! Dirige-toi vers le but!',
            needDefeatBoss: 'Vaincs le boss pour atteindre le but!',
            you: 'Toi',
            monster: 'Monstre',
            boss: 'Boss',
            gate: 'Porte',
            goal: 'But',
            totalDefeated: 'Total de monstres vaincus',
            totalQuestions: 'Questions r√©pondues',
            correctAnswers: 'Bonnes r√©ponses',
            accuracy: 'Pr√©cision',
            congratulations: 'F√©licitations!',
            yourStats: 'Tes Statistiques',
            found: 'Trouv√©',
            notFound: 'Pas encore d√©couvert',
            hp: 'PV',
            whichBigger: 'Lequel est plus grand?',
            body: ' monstres',
            question: ' questions',
            badges: 'Badges',
            firstClear: 'Premi√®re victoire',
            perfectClear: 'Parfait',
            multiplicationMaster: 'Ma√Ætre des tables',
            typesOfMonsters: 'types de monstres',
            hint: 'Astuce: Choisis le mode pour ton niveau!',
            viewHint: "Voir l'indice",
            hideHint: "Cacher l'indice",
            insectMission: 'Mission Insecte',
            selectArea: 'Choisir une zone',
            urawa: 'Urawa',
            omiya: 'Omiya',
            iwatsuki: 'Iwatsuki',
            cicada: 'Cigale',
            cicadaFact: 'Beaucoup de cigales chantent au parc Omiya.',
            beetle: 'Scarab√©e',
            beetleFact: 'Les scarab√©es sont populaires √† Urawa.',
            dragonfly: 'Libellule',
            dragonflyFact: 'Les libellules volent autour de Minuma Tambo.',
            attemptCapture: 'Tenter la capture',
            captureInsect: "Attrape l'insecte",
            captureSuccess: 'Captur√©!',
            captureFail: 'S\'est √©chapp√©!'
        },
        zh: {
            gameTitle: 'Êï∞Â≠¶Âú∞Áâ¢',
            startGame: 'ÂºÄÂßãÊ∏∏ÊàèÔºÅ',
            stats: 'ÁªüËÆ°',
            dictionary: 'ÊÄ™Áâ©ÂõæÈâ¥',
            selectGrade: 'ÈÄâÊã©Âπ¥Á∫ßÔºÅ',
            grade2Mode: '‰∫åÂπ¥Á∫ßÊ®°Âºè',
            grade3Mode: '‰∏âÂπ¥Á∫ßÊ®°Âºè',
            studyContent: 'Â≠¶‰π†ÂÜÖÂÆπÔºö',
            addition: 'Âä†Ê≥ï',
            subtraction: 'ÂáèÊ≥ï',
            comparison: 'Êï∞Â≠óÊØîËæÉ',
            multiplication: '‰πòÊ≥ï',
            division: 'Èô§Ê≥ï',
            back: 'ËøîÂõû',
            level: 'ÂÖ≥Âç°',
            defeated: 'ÂáªË¥•',
            timeLeft: 'Ââ©‰ΩôÊó∂Èó¥',
            seconds: 'Áßí',
            correct: 'Ê≠£Á°ÆÔºÅÂ§™Ê£í‰∫ÜÔºÅ',
            incorrect: 'ÂÜçËØï‰∏ÄÊ¨°ÔºÅ',
            timeUp: 'Êó∂Èó¥Âà∞ÔºÅ',
            wall: 'ÊòØÂ¢ôÔºÅ',
            gateBlocked: 'ÂáªË¥•bossÊâçËÉΩÈÄöËøáÔºÅ',
            gateOpened: 'Â§ßÈó®ÊâìÂºÄ‰∫ÜÔºÅ',
            bossDefeated: 'BossË¢´ÂáªË¥•ÔºÅ',
            monsterDefeated: 'Ë¢´ÂáªË¥•ÔºÅ',
            levelClear: 'ÂÖ≥Âç°',
            clearMessage: 'ÈÄöÂÖ≥ÔºÅ',
            nextLevel: '‰∏ã‰∏ÄÂÖ≥ÔºÅ',
            menu: 'ËèúÂçï',
            becomeHero: 'Êàê‰∏∫Êï∞Â≠¶Ëã±ÈõÑ',
            conquerDungeon: 'ÂæÅÊúçÂú∞Áâ¢ÔºÅ',
            dungeonExploring: 'Êé¢Á¥¢Âú∞Áâ¢‰∏≠',
            bossBattle: 'BossÊàòÔºÅ',
            appeared: 'Âá∫Áé∞‰∫ÜÔºÅ',
            bossWarning: 'ÂáªË¥•Ëøô‰∏™bossÊâçËÉΩÂà∞ËææÁªàÁÇπÔºÅ',
            defeatedBoss: 'BossË¢´ÂáªË¥•ÔºÅÂâçÂæÄÁªàÁÇπÔºÅ',
            needDefeatBoss: 'ÂáªË¥•bossÊâçËÉΩÂà∞ËææÁªàÁÇπÔºÅ',
            you: '‰Ω†',
            monster: 'ÊÄ™Áâ©',
            boss: 'Boss',
            gate: 'Â§ßÈó®',
            goal: 'ÁªàÁÇπ',
            totalDefeated: 'ÂáªË¥•ÊÄ™Áâ©ÊÄªÊï∞',
            totalQuestions: 'ÂõûÁ≠îÈóÆÈ¢òÊï∞',
            correctAnswers: 'Ê≠£Á°ÆÁ≠îÊ°àÊï∞',
            accuracy: 'Ê≠£Á°ÆÁéá',
            congratulations: 'ÊÅ≠ÂñúÔºÅ',
            yourStats: '‰Ω†ÁöÑÁªüËÆ°',
            found: 'Â∑≤ÂèëÁé∞',
            notFound: 'Â∞öÊú™ÂèëÁé∞',
            hp: 'ÁîüÂëΩÂÄº',
            whichBigger: 'Âì™‰∏™Êõ¥Â§ßÔºü',
            body: 'Âè™',
            question: 'È¢ò',
            badges: 'ÂæΩÁ´†',
            firstClear: 'È¶ñÊ¨°ÈÄöÂÖ≥',
            perfectClear: 'ÂÆåÁæé',
            multiplicationMaster: '‰πù‰πùË°®Â§ßÂ∏à',
            typesOfMonsters: 'ÁßçÊÄ™Áâ©',
            hint: 'ÊèêÁ§∫ÔºöÈÄâÊã©ÈÄÇÂêà‰Ω†Âπ¥Á∫ßÁöÑÊ®°ÂºèÔºÅ',
            viewHint: 'Êü•ÁúãÊèêÁ§∫',
            hideHint: 'ÈöêËóèÊèêÁ§∫',
            insectMission: 'ÊçïËô´‰ªªÂä°',
            selectArea: 'ÈÄâÊã©Âú∞Âå∫',
            urawa: 'Êµ¶Âíå',
            omiya: 'Â§ßÂÆ´',
            iwatsuki: 'Â≤©Êßª',
            cicada: 'Ëùâ',
            cicadaFact: 'Âú®Â§ßÂÆ´ÂÖ¨Âõ≠ÊúâÂæàÂ§öËùâÂú®Âè´„ÄÇ',
            beetle: 'Áî≤Ëô´',
            beetleFact: 'Áî≤Ëô´Âú®Êµ¶ÂíåÂæàÂèóÊ¨¢Ëøé„ÄÇ',
            dragonfly: 'ËúªËúì',
            dragonflyFact: 'ËúªËúìÂú®ËßÅÊ≤ºÁî∞ÂúÉÈ£ûÊù•È£ûÂéª„ÄÇ',
            attemptCapture: 'Â∞ùËØïÊçïÊçâ',
            captureInsect: 'Êù•ÊçïÊçâËô´Â≠ê',
            captureSuccess: 'ÊçïÊçâÊàêÂäüÔºÅ',
            captureFail: 'ÈÄÉËµ∞‰∫ÜÔºÅ'
        }
    };

    const t = translations[language];

    // Monster types with multilingual names
    const getMonsterTypes = useCallback(() => {
        const monsterNames = {
            ja: {
                denkiryu: { name: '„Éá„É≥„Ç≠„É™„É•„Ç¶', desc: '„Åß„Çì„Åç„Çø„Ç§„ÉóÔºÅ„Åü„ÅóÁÆó„Åß „Åì„ÅÜ„Åí„Åç„Å†ÔºÅ' },
                mizugame: { name: '„Éü„Ç∫„Ç¨„É°', desc: '„Åø„Åö„Çø„Ç§„ÉóÔºÅ„Å≤„ÅçÁÆó„ÅÆ „Çè„Åñ„Çí „ÅØ„Å§ÔºÅ' },
                happamon: { name: '„Éè„ÉÉ„Éë„É¢„É≥', desc: '„Åè„Åï„Çø„Ç§„ÉóÔºÅ„Åã„Åö„ÅÆ „Å°„Åã„Çâ„Çí „Åè„Çâ„Åπ„ÇãÔºÅ' },
                honoodon: { name: '„Éõ„Éé„Ç™„Éâ„É≥', desc: '„Åª„ÅÆ„Åä„Çø„Ç§„ÉóÔºÅ„ÅÇ„Å§„ÅÑ „Åü„ÅóÁÆó„Çí „Å†„ÅôÔºÅ' },
                starion: { name: '„Çπ„Çø„É™„Ç™„É≥', desc: '„Åª„Åó„Çø„Ç§„ÉóÔºÅ„Åã„ÅëÁÆó„ÅÆ „Åª„Åó„Çí „Åµ„Çâ„Åõ„ÇãÔºÅ' },
                crystalos: { name: '„ÇØ„É™„Çπ„Çø„É≠„Çπ', desc: '„ÇØ„É™„Çπ„Çø„É´„Çø„Ç§„ÉóÔºÅ„Çè„ÇäÁÆó„Åß „Åì„ÅÜ„Åí„ÅçÔºÅ' },
                raidenking: { name: '„É©„Ç§„Éá„É≥„Ç≠„É≥„Ç∞', desc: '„Åß„Çì„Åõ„Å§„ÅÆ „Éú„ÇπÔºÅ„Åü„Åä„Åï„Å™„ÅÑ„Å® „Åï„Åç„Å´ „Åô„Åô„ÇÅ„Å™„ÅÑÔºÅ' },
                mathemperor: { name: '„Éû„Çπ„Ç®„É≥„Éö„É©„Éº', desc: '„Åï„Çì„Åô„ÅÜ„ÅÆ „Å¶„ÅÑ„Åä„ÅÜÔºÅ‰πù‰πù„Çí „Éû„Çπ„Çø„Éº„Åó„Å¶„ÅÑ„ÇãÔºÅ' }
            },
            en: {
                denkiryu: { name: 'Electrox', desc: 'Electric type! Attacks with addition!' },
                mizugame: { name: 'Aquaturtle', desc: 'Water type! Uses subtraction skills!' },
                happamon: { name: 'Leafmon', desc: 'Grass type! Compares number powers!' },
                honoodon: { name: 'Blazedon', desc: 'Fire type! Throws hot additions!' },
                starion: { name: 'Starion', desc: 'Star type! Rains multiplication stars!' },
                crystalos: { name: 'Crystalos', desc: 'Crystal type! Attacks with division!' },
                raidenking: { name: 'Thunder King', desc: 'Legendary boss! Must defeat to proceed!' },
                mathemperor: { name: 'Math Emperor', desc: 'Emperor of math! Master of times tables!' }
            },
            fr: {
                denkiryu: { name: '√âlectryx', desc: 'Type √©lectrique! Attaque avec addition!' },
                mizugame: { name: 'Aquatortue', desc: 'Type eau! Utilise la soustraction!' },
                happamon: { name: 'Feuilmon', desc: 'Type plante! Compare les nombres!' },
                honoodon: { name: 'Flammedon', desc: 'Type feu! Lance des additions br√ªlantes!' },
                starion: { name: '√âtoilon', desc: 'Type √©toile! Pleut des multiplications!' },
                crystalos: { name: 'Crystalos', desc: 'Type cristal! Attaque avec division!' },
                raidenking: { name: 'Roi Tonnerre', desc: 'Boss l√©gendaire! √Ä vaincre pour continuer!' },
                mathemperor: { name: 'Empereur Math', desc: 'Empereur des maths! Ma√Ætre des tables!' }
            },
            zh: {
                denkiryu: { name: 'ÁîµÈæô', desc: 'ÁîµÁ≥ªÔºÅÁî®Âä†Ê≥ïÊîªÂáªÔºÅ' },
                mizugame: { name: 'Ê∞¥Èæü', desc: 'Ê∞¥Á≥ªÔºÅ‰ΩøÁî®ÂáèÊ≥ïÊäÄËÉΩÔºÅ' },
                happamon: { name: 'Âè∂ÂÖΩ', desc: 'ËçâÁ≥ªÔºÅÊØîËæÉÊï∞Â≠óÂäõÈáèÔºÅ' },
                honoodon: { name: 'ÁÅ´ÁÑ∞ÂÖΩ', desc: 'ÁÅ´Á≥ªÔºÅÂèëÂá∫ÁÇΩÁÉ≠ÁöÑÂä†Ê≥ïÔºÅ' },
                starion: { name: 'ÊòüÂÖΩ', desc: 'ÊòüÁ≥ªÔºÅÈôç‰∏ã‰πòÊ≥ï‰πãÊòüÔºÅ' },
                crystalos: { name: 'Ê∞¥Êô∂ÂÖΩ', desc: 'Ê∞¥Êô∂Á≥ªÔºÅÁî®Èô§Ê≥ïÊîªÂáªÔºÅ' },
                raidenking: { name: 'Èõ∑Áéã', desc: '‰º†ËØ¥‰∏≠ÁöÑBossÔºÅÂøÖÈ°ªÂáªË¥•ÊâçËÉΩÂâçËøõÔºÅ' },
                mathemperor: { name: 'Êï∞Â≠¶ÁöáÂ∏ù', desc: 'Êï∞Â≠¶ÁöÑÂ∏ùÁéãÔºÅÊéåÊè°‰πù‰πùË°®ÔºÅ' }
            }
        };

        return [
            // Grade 2 monsters
            {
                id: 'denkiryu',
                name: monsterNames[language].denkiryu.name,
                emoji: '‚ö°',
                problemType: 'addition',
                description: monsterNames[language].denkiryu.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            {
                id: 'mizugame',
                name: monsterNames[language].mizugame.name,
                emoji: 'üê¢',
                problemType: 'subtraction',
                description: monsterNames[language].mizugame.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            {
                id: 'happamon',
                name: monsterNames[language].happamon.name,
                emoji: 'üçÉ',
                problemType: 'comparison',
                description: monsterNames[language].happamon.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            {
                id: 'honoodon',
                name: monsterNames[language].honoodon.name,
                emoji: 'üî•',
                problemType: 'addition',
                description: monsterNames[language].honoodon.desc,
                isBoss: false,
                grade: 2,
                health: 3
            },
            // Grade 3 monsters
            {
                id: 'starion',
                name: monsterNames[language].starion.name,
                emoji: '‚≠ê',
                problemType: 'multiplication',
                description: monsterNames[language].starion.desc,
                isBoss: false,
                grade: 3,
                health: 3
            },
            {
                id: 'crystalos',
                name: monsterNames[language].crystalos.name,
                emoji: 'üíé',
                problemType: 'division',
                description: monsterNames[language].crystalos.desc,
                isBoss: false,
                grade: 3,
                health: 3
            },
            // Boss monsters
            {
                id: 'raidenking',
                name: monsterNames[language].raidenking.name,
                emoji: 'üëë',
                problemType: 'addition',
                description: monsterNames[language].raidenking.desc,
                isBoss: true,
                grade: 2,
                health: 5
            },
            {
                id: 'mathemperor',
                name: monsterNames[language].mathemperor.name,
                emoji: 'üè∞',
                problemType: 'multiplication',
                description: monsterNames[language].mathemperor.desc,
                isBoss: true,
                grade: 3,
                health: 7
            }
        ];
    }, [language]);

    // Game state
    const [gameState, setGameState] = useState('menu');
    const [currentLevel, setCurrentLevel] = useState(1);
    const [selectedGrade, setSelectedGrade] = useState(2);
    const [playerPosition, setPlayerPosition] = useState({ x: 0, y: 0 });
    const [maze, setMaze] = useState([]);
    const [mazeSize, setMazeSize] = useState(5);
    const [monsterPositions, setMonsterPositions] = useState([]);
    const [defeatedMonsters, setDefeatedMonsters] = useState([]);
    const [currentMonster, setCurrentMonster] = useState(null);
    const [battleState, setBattleState] = useState(null);
    const [bossGates, setBossGates] = useState([]);
    const [requiredBosses, setRequiredBosses] = useState([]);
    const [timeLeft, setTimeLeft] = useState(30);
    const [message, setMessage] = useState('');
    const [showHint, setShowHint] = useState(false);

    // Insect capture state
    const [selectedArea, setSelectedArea] = useState(null);
    const [currentInsect, setCurrentInsect] = useState(null);
    const [captureQuestion, setCaptureQuestion] = useState(null);
    const [captureResult, setCaptureResult] = useState(null);
    const [capturedInsects, setCapturedInsects] = useState([]);

    const [playerStats, setPlayerStats] = useState({
        totalMonstersDefeated: 0,
        totalQuestionsAnswered: 0,
        correctAnswers: 0,
        unlockedMonsters: [],
        badges: []
    });

    const areaInsects = {
        urawa: { insect: 'beetle' },
        omiya: { insect: 'cicada' },
        iwatsuki: { insect: 'dragonfly' }
    };

    // Language selector component
    const LanguageSelector = () => (
        <div className="flex justify-center gap-2 mb-4">
            <button
                onClick={() => setLanguage('ja')}
                className={`px-3 py-1 rounded text-sm font-bold transition-all ${language === 'ja' ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' : 'bg-gray-300 hover:bg-gray-400'}`}
            >
                Êó•Êú¨Ë™û
            </button>
            <button
                onClick={() => setLanguage('en')}
                className={`px-3 py-1 rounded text-sm font-bold transition-all ${language === 'en' ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' : 'bg-gray-300 hover:bg-gray-400'}`}
            >
                EN
            </button>
            <button
                onClick={() => setLanguage('fr')}
                className={`px-3 py-1 rounded text-sm font-bold transition-all ${language === 'fr' ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' : 'bg-gray-300 hover:bg-gray-400'}`}
            >
                FR
            </button>
            <button
                onClick={() => setLanguage('zh')}
                className={`px-3 py-1 rounded text-sm font-bold transition-all ${language === 'zh' ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' : 'bg-gray-300 hover:bg-gray-400'}`}
            >
                ‰∏≠Êñá
            </button>
        </div>
    );

    // Save language preference
    useEffect(() => {
        const saved = localStorage.getItem('gameLanguage');
        if (saved && translations[saved]) setLanguage(saved);
    }, []);

    useEffect(() => {
        localStorage.setItem('gameLanguage', language);
    }, [language]);

    // Generate maze
    const generateMaze = useCallback((size) => {
        const newMaze = Array(size).fill().map(() => Array(size).fill(0));

        // Add walls (random but avoid start/goal)
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if (Math.random() < 0.2 && !(x === 0 && y === 0) && !(x === size - 1 && y === size - 1)) {
                    newMaze[y][x] = 1;
                }
            }
        }

        // Ensure start and goal
        newMaze[0][0] = 0;
        newMaze[size - 1][size - 1] = 2;

        // Carve a simple path
        for (let i = 0; i < size - 1; i++) {
            if (Math.random() < 0.5) {
                newMaze[i][i] = 0;
                newMaze[i][i + 1] = 0;
            } else {
                newMaze[i][i] = 0;
                newMaze[i + 1][i] = 0;
            }
        }

        const gates = [];
        const bosses = [];
        if (currentLevel > 3 && size >= 7) {
            const gateY = size - 2;
            const gateX = size - 1;
            if (newMaze[gateY][gateX] === 0) {
                newMaze[gateY][gateX] = 3; // gate
                gates.push({ x: gateX, y: gateY, id: 'gate-1' });
            }
        }

        // Place monsters by grade
        const monsterTypes = getMonsterTypes();
        const gradeMonsters = monsterTypes.filter(m => m.grade === selectedGrade);
        const normalMonsters = gradeMonsters.filter(m => !m.isBoss);
        const bossMonsters = gradeMonsters.filter(m => m.isBoss);

        const monsters = [];

        // Boss placement (if gate present)
        if (gates.length > 0 && bossMonsters.length > 0) {
            let bossPlaced = false;
            for (let attempts = 0; attempts < 50 && !bossPlaced; attempts++) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const y = Math.floor(Math.random() * (size - 2)) + 1;
                if (newMaze[y][x] === 0 && !(x === 0 && y === 0) && !(x === size - 1 && y === size - 1)) {
                    const bossType = bossMonsters[Math.floor(Math.random() * bossMonsters.length)];
                    monsters.push({ x, y, type: bossType, id: `boss-${gates[0].id}`, isBoss: true });
                    bosses.push(`boss-${gates[0].id}`);
                    bossPlaced = true;
                }
            }
        }

        // Normal monsters
        const monsterCount = Math.min(Math.floor(size / 2), 4);
        for (let i = 0; i < monsterCount; i++) {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 50) {
                const x = Math.floor(Math.random() * size);
                const y = Math.floor(Math.random() * size);
                if (newMaze[y][x] === 0 && !(x === 0 && y === 0) && !(x === size - 1 && y === size - 1) &&
                    !monsters.some(m => m.x === x && m.y === y)) {
                    const monsterType = normalMonsters[Math.floor(Math.random() * normalMonsters.length)];
                    monsters.push({ x, y, type: monsterType, id: `monster-${i}`, isBoss: false });
                    placed = true;
                }
                attempts++;
            }
        }

        setMaze(newMaze);
        setMonsterPositions(monsters);
        setBossGates(gates);
        setRequiredBosses(bosses);
        setPlayerPosition({ x: 0, y: 0 });
        setDefeatedMonsters([]);
    }, [currentLevel, selectedGrade, getMonsterTypes]);

    // Problem generator
    const generateProblem = useCallback((type) => {
        let problem = {};
        switch (type) {
            case 'addition': {
                const a = Math.floor(Math.random() * 20) + 1;
                const b = Math.floor(Math.random() * 20) + 1;
                problem = {
                    question: `${a} + ${b} = ?`,
                    answer: a + b,
                    options: generateOptions(a + b, 2, 40),
                    hint: `${a} + ${b} = ?`
                };
                break;
            }
            case 'subtraction': {
                const a = Math.floor(Math.random() * 20) + 10;
                const b = Math.floor(Math.random() * a) + 1;
                problem = {
                    question: `${a} - ${b} = ?`,
                    answer: a - b,
                    options: generateOptions(a - b, 0, 20),
                    hint: `${a} - ${b} = ?`
                };
                break;
            }
            case 'comparison': {
                let num1 = Math.floor(Math.random() * 50) + 10;
                let num2 = Math.floor(Math.random() * 50) + 10;
                while (num1 === num2) num2 = Math.floor(Math.random() * 50) + 10;
                const bigger = num1 > num2 ? num1 : num2;
                problem = {
                    question: `${t.whichBigger} ${num1} vs ${num2}`,
                    answer: bigger,
                    options: [num1, num2],
                    comparisonType: true,
                    hint: `${t.whichBigger}`
                };
                break;
            }
            case 'multiplication': {
                const a = Math.floor(Math.random() * 9) + 1;
                const b = Math.floor(Math.random() * 9) + 1;
                problem = {
                    question: `${a} √ó ${b} = ?`,
                    answer: a * b,
                    options: generateOptions(a * b, 1, 81),
                    hint: `${a} √ó ${b} = ?`
                };
                break;
            }
            case 'division': {
                const divisor = Math.floor(Math.random() * 9) + 1;
                const quotient = Math.floor(Math.random() * 9) + 1;
                const dividend = divisor * quotient;
                problem = {
                    question: `${dividend} √∑ ${divisor} = ?`,
                    answer: quotient,
                    options: generateOptions(quotient, 1, 9),
                    hint: `${dividend} √∑ ${divisor} = ?`
                };
                break;
            }
            default:
                problem = { question: '0 + 0 = ?', answer: 0, options: [0,1,2,3], hint: '' };
        }
        return problem;
    }, [t.whichBigger]);

    // Options helper
    const generateOptions = (correctAnswer, min, max) => {
        const options = [correctAnswer];
        while (options.length < 4) {
            const option = Math.floor(Math.random() * (max - min + 1)) + min;
            if (!options.includes(option)) options.push(option);
        }
        return options.sort(() => Math.random() - 0.5);
    };

    // Move player
    const movePlayer = useCallback((direction) => {
        if (gameState !== 'maze') return;

        const newPos = { ...playerPosition };
        if (direction === 'up' && newPos.y > 0) newPos.y--;
        if (direction === 'down' && newPos.y < mazeSize - 1) newPos.y++;
        if (direction === 'left' && newPos.x > 0) newPos.x--;
        if (direction === 'right' && newPos.x < mazeSize - 1) newPos.x++;

        // Wall
        if (maze[newPos.y] && maze[newPos.y][newPos.x] === 1) {
            setMessage(t.wall);
            setTimeout(() => setMessage(''), 2000);
            return;
        }

        // Gate
        if (maze[newPos.y] && maze[newPos.y][newPos.x] === 3) {
            const gate = bossGates.find(g => g.x === newPos.x && g.y === newPos.y);
            if (gate) {
                const requiredBossDefeated = requiredBosses.every(bossId => defeatedMonsters.includes(bossId));
                if (!requiredBossDefeated) {
                    setMessage('‚ö†Ô∏è ' + t.gateBlocked);
                    setTimeout(() => setMessage(''), 3000);
                    return;
                } else {
                    const newMaze = maze.map(row => row.slice());
                    newMaze[newPos.y][newPos.x] = 0;
                    setMaze(newMaze);
                    setMessage('‚ú® ' + t.gateOpened);
                    setTimeout(() => setMessage(''), 2000);
                }
            }
        }

        setPlayerPosition(newPos);

        // Goal
        if (newPos.x === mazeSize - 1 && newPos.y === mazeSize - 1) {
            handleLevelClear();
            return;
        }

        // Monster encounter
        const monster = monsterPositions.find(m => m.x === newPos.x && m.y === newPos.y && !defeatedMonsters.includes(m.id));
        if (monster) startBattle(monster);
    }, [gameState, playerPosition, maze, mazeSize, bossGates, requiredBosses, defeatedMonsters, monsterPositions, t]);

    // Start battle
    const startBattle = (monster) => {
        setCurrentMonster(monster);
        const monsterHealth = monster.type.health || (monster.isBoss ? 5 : 3);
        setBattleState({
            monsterHealth,
            maxHealth: monsterHealth,
            currentProblem: generateProblem(monster.type.problemType)
        });
        setShowHint(false);
        setTimeLeft(monster.isBoss ? 45 : 30);
        setGameState('battle');
    };

    // Handle level clear
    const handleLevelClear = () => {
        setGameState('victory');
        setMessage(`${t.congratulations} ${t.level} ${currentLevel} ${t.clearMessage}`);

        const newBadges = [];
        if (currentLevel === 1 && !playerStats.badges.includes('first_clear')) newBadges.push('first_clear');
        if (defeatedMonsters.length === monsterPositions.length && !playerStats.badges.includes('perfect_clear')) newBadges.push('perfect_clear');
        if (selectedGrade === 3 && !playerStats.badges.includes('multiplication_master')) newBadges.push('multiplication_master');

        if (newBadges.length > 0) {
            setPlayerStats(prev => ({ ...prev, badges: [...prev.badges, ...newBadges] }));
        }
    };

    // Check answer in battle
    const checkAnswer = (answer) => {
        if (!battleState || !battleState.currentProblem) return;
        setShowHint(false);

        const isCorrect = answer === battleState.currentProblem.answer;

        if (isCorrect) {
            setMessage(t.correct);
            setPlayerStats(prev => ({ ...prev, correctAnswers: prev.correctAnswers + 1, totalQuestionsAnswered: prev.totalQuestionsAnswered + 1 }));

            const newHealth = battleState.monsterHealth - 1;
            if (newHealth <= 0) {
                // defeated
                setDefeatedMonsters(prev => [...prev, currentMonster.id]);
                setPlayerStats(prev => ({
                    ...prev,
                    totalMonstersDefeated: prev.totalMonstersDefeated + 1,
                    unlockedMonsters: prev.unlockedMonsters.includes(currentMonster.type.id) ? prev.unlockedMonsters : [...prev.unlockedMonsters, currentMonster.type.id]
                }));

                if (currentMonster.isBoss) {
                    setMessage(`üéâ ${t.boss} ${currentMonster.type.name}${t.monsterDefeated}${t.bossDefeated}`);
                } else {
                    setMessage(`${currentMonster.type.name}${t.monsterDefeated}`);
                }

                setTimeout(() => {
                    setGameState('maze');
                    setMessage('');
                }, 3000);
            } else {
                setBattleState({
                    monsterHealth: newHealth,
                    maxHealth: battleState.maxHealth,
                    currentProblem: generateProblem(currentMonster.type.problemType)
                });
                setTimeLeft(currentMonster.isBoss ? 45 : 30);
                setTimeout(() => setMessage(''), 1500);
            }
        } else {
            setMessage(t.incorrect);
            setPlayerStats(prev => ({ ...prev, totalQuestionsAnswered: prev.totalQuestionsAnswered + 1 }));
            setTimeout(() => {
                setMessage('');
                setBattleState(prev => ({ ...prev, currentProblem: generateProblem(currentMonster.type.problemType) }));
                setTimeLeft(currentMonster.isBoss ? 45 : 30);
            }, 1500);
        }
    };

    // Timer for battle
    useEffect(() => {
        if (gameState === 'battle' && timeLeft > 0) {
            const timer = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);
            return () => clearTimeout(timer);
        } else if (gameState === 'battle' && timeLeft === 0) {
            setMessage(t.timeUp);
            setTimeout(() => {
                if (currentMonster && battleState) {
                    setBattleState(prev => ({ ...prev, currentProblem: generateProblem(currentMonster.type.problemType) }));
                    setTimeLeft(currentMonster.isBoss ? 45 : 30);
                    setShowHint(false);
                }
                setMessage('');
            }, 2000);
        }
    }, [timeLeft, gameState, currentMonster, battleState, generateProblem, t.timeUp]);

    // Keyboard controls
    useEffect(() => {
        const handleKeyPress = (e) => {
            if (gameState !== 'maze') return;
            if (e.key === 'ArrowUp') movePlayer('up');
            if (e.key === 'ArrowDown') movePlayer('down');
            if (e.key === 'ArrowLeft') movePlayer('left');
            if (e.key === 'ArrowRight') movePlayer('right');
        };
        window.addEventListener('keydown', handleKeyPress);
        return () => window.removeEventListener('keydown', handleKeyPress);
    }, [movePlayer, gameState]);

    // Start game
    const startGameWithGrade = (grade) => {
        setSelectedGrade(grade);
        setCurrentLevel(1);
        setMazeSize(5);
        setTimeout(() => generateMaze(5), 100);
        setGameState('maze');
    };

    const nextLevel = () => {
        const newLevel = currentLevel + 1;
        const newSize = Math.min(5 + Math.floor(newLevel / 2), 9);
        setCurrentLevel(newLevel);
        setMazeSize(newSize);
        setTimeout(() => generateMaze(newSize), 100);
        setGameState('maze');
    };

    // Insect capture handlers
    const startCapture = (insectKey) => {
        setCurrentInsect(insectKey);
        setCaptureQuestion(generateProblem('addition'));
        setCaptureResult(null);
        setGameState('insectQuiz');
    };

    const checkCaptureAnswer = (answer) => {
        if (!captureQuestion) return;
        if (answer === captureQuestion.answer) {
            setCaptureResult('success');
            if (currentInsect && !capturedInsects.includes(currentInsect)) {
                setCapturedInsects(prev => [...prev, currentInsect]);
            }
        } else {
            setCaptureResult('fail');
        }
    };

    // UI rendering by gameState
    if (gameState === 'menu') {
        return (
            <div className="min-h-screen bg-gradient-to-br from-purple-900 to-pink-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h1 className="text-5xl font-bold text-center mb-6 text-purple-600">üéÆ {t.gameTitle} üéÆ</h1>
                    <div className="text-center mb-8">
                        <p className="text-2xl mb-4 text-purple-700">{t.becomeHero}</p>
                        <p className="text-2xl text-pink-700">{t.conquerDungeon}</p>
                    </div>
                    <div className="flex flex-col gap-4">
                        <button onClick={() => setGameState('gradeSelect')} className="bg-gradient-to-r from-green-500 to-blue-500 text-white text-2xl font-bold py-4 rounded-2xl hover:from-green-600 hover:to-blue-600 transform hover:scale-105 transition-all">
                            ‚öîÔ∏è {t.startGame} ‚öîÔ∏è
                        </button>
                        <button onClick={() => setGameState('map')} className="bg-gradient-to-r from-lime-500 to-green-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-lime-600 hover:to-green-600">
                            üó∫Ô∏è {t.insectMission}
                        </button>
                        <button onClick={() => setGameState('stats')} className="bg-gradient-to-r from-purple-500 to-pink-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-purple-600 hover:to-pink-600">
                            üèÜ {t.stats}
                        </button>
                        <button onClick={() => setGameState('dictionary')} className="bg-gradient-to-r from-orange-500 to-red-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-orange-600 hover:to-red-600">
                            üìñ {t.dictionary}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'gradeSelect') {
        return (
            <div className="min-h-screen bg-gradient-to-br from-purple-900 to-pink-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-3xl w-full">
                    <LanguageSelector />
                    <h2 className="text-4xl font-bold text-center mb-8 text-purple-600">üéì {t.selectGrade} üéì</h2>
                    <div className="grid md:grid-cols-2 gap-6">
                        <button onClick={() => startGameWithGrade(2)} className="bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl p-6 text-white hover:from-blue-600 hover:to-cyan-600 transform hover:scale-105 transition-all">
                            <div className="text-5xl mb-4">üìò</div>
                            <h3 className="text-2xl font-bold mb-3">{t.grade2Mode}</h3>
                            <p className="mb-2">{t.studyContent}</p>
                            <ul className="mt-2 text-left">
                                <li>‚úÖ {t.addition}</li>
                                <li>‚úÖ {t.subtraction}</li>
                                <li>‚úÖ {t.comparison}</li>
                            </ul>
                        </button>
                        <button onClick={() => startGameWithGrade(3)} className="bg-gradient-to-br from-purple-500 to-pink-500 rounded-2xl p-6 text-white hover:from-purple-600 hover:to-pink-600 transform hover:scale-105 transition-all">
                            <div className="text-5xl mb-4">üìï</div>
                            <h3 className="text-2xl font-bold mb-3">{t.grade3Mode}</h3>
                            <p className="mb-2">{t.studyContent}</p>
                            <ul className="mt-2 text-left">
                                <li>‚úÖ {t.multiplication}</li>
                                <li>‚úÖ {t.division}</li>
                            </ul>
                        </button>
                    </div>
                    <div className="mt-6 text-center">
                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>
                    </div>
                    <div className="mt-4 text-center text-gray-600"><p>üí° {t.hint}</p></div>
                </div>
            </div>
        );
    }

    if (gameState === 'map') {
        return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-3xl font-bold text-center mb-6 text-green-700">üó∫Ô∏è {t.selectArea} üó∫Ô∏è</h2>
                    <div className="flex flex-col gap-4">
                        {['urawa', 'omiya', 'iwatsuki'].map(area => (
                            <button key={area} onClick={() => { setSelectedArea(area); setGameState('area'); }} className="bg-gradient-to-r from-green-500 to-lime-500 text-white text-xl font-bold py-3 rounded-2xl hover:from-green-600 hover:to-lime-600">
                                {t[area]}
                            </button>
                        ))}
                    </div>
                    <div className="mt-6 text-center">
                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'area' && selectedArea) {
        const insectKey = areaInsects[selectedArea].insect;
        return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-3xl font-bold text-center mb-6 text-green-700">{t[selectedArea]}</h2>
                    <div className="text-center mb-6">
                        <p className="text-2xl">{t[insectKey]}</p>
                        <p className="mt-2">{t[`${insectKey}Fact`]}</p>
                    </div>
                    <div className="flex flex-col gap-4 items-center">
                        <button onClick={() => startCapture(insectKey)} className="bg-green-500 text-white px-6 py-3 rounded-xl hover:bg-green-600">{t.attemptCapture}</button>
                        <button onClick={() => setGameState('map')} className="bg-gray-500 text-white px-6 py-2 rounded-xl hover:bg-gray-600">{t.back}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'insectQuiz' && captureQuestion) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 to-lime-900 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-3xl font-bold text-center mb-6 text-green-700">{t.captureInsect}</h2>
                    <div className="text-center text-2xl mb-6">{captureQuestion.question}</div>
                    {captureResult ? (
                        <div className="text-center text-2xl mb-6">{captureResult === 'success' ? t.captureSuccess : t.captureFail}</div>
                    ) : (
                        <div className="grid grid-cols-2 gap-4 mb-6">
                            {captureQuestion.options.map((opt, idx) => (
                                <button key={idx} onClick={() => checkCaptureAnswer(opt)} className="bg-purple-500 text-white text-3xl font-bold py-4 rounded-2xl hover:scale-105 transition-all">{opt}</button>
                            ))}
                        </div>
                    )}
                    <div className="text-center">
                        <button onClick={() => setGameState('map')} className="bg-gray-500 text-white px-8 py-2 rounded-xl hover:bg-gray-600">{captureResult ? t.selectArea : t.back}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'maze') {
        return (
            <div className="min-h-screen bg-gradient-to-b from-indigo-950 to-slate-950 p-4">
                <div className="max-w-4xl mx-auto">
                    <div className="bg-purple-900/80 rounded-2xl p-4 mb-4">
                        <div className="flex justify-between items-center flex-wrap gap-2">
                            <div className="text-2xl font-bold text-white">{t.level} {currentLevel}</div>
                            <div className="text-xl text-yellow-400">‚öîÔ∏è {t.defeated}: {defeatedMonsters.length}/{monsterPositions.length}</div>
                            <button onClick={() => setGameState('menu')} className="bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600">{t.menu}</button>
                        </div>
                        {requiredBosses.length > 0 && (
                            <div className="mt-2 text-center">
                                {requiredBosses.every(id => defeatedMonsters.includes(id)) ? (
                                    <span className="text-green-400 font-bold text-lg animate-pulse">‚ú® {t.defeatedBoss} ‚ú®</span>
                                ) : (
                                    <span className="text-orange-400 font-bold text-lg animate-pulse">‚ö†Ô∏è {t.needDefeatBoss} ‚ö†Ô∏è</span>
                                )}
                            </div>
                        )}
                    </div>

                    {message && (
                        <div className="bg-yellow-500 text-white text-center text-2xl font-bold p-3 rounded-xl mb-4 animate-bounce">{message}</div>
                    )}

                    <div className="bg-slate-900 rounded-3xl p-8">
                        <h3 className="text-2xl font-bold text-center mb-4 text-white">‚öîÔ∏è {t.dungeonExploring} ‚öîÔ∏è</h3>

                        <div className="grid gap-1 mx-auto" style={{ gridTemplateColumns: `repeat(${mazeSize}, minmax(0, 1fr))`, maxWidth: `${mazeSize * 60}px` }}>
                            {maze.map((row, y) => row.map((cell, x) => {
                                const isPlayer = playerPosition.x === x && playerPosition.y === y;
                                const monster = monsterPositions.find(m => m.x === x && m.y === y && !defeatedMonsters.includes(m.id));
                                const isGoal = x === mazeSize - 1 && y === mazeSize - 1;
                                const isGate = cell === 3;
                                const isBossMonster = monster && monster.isBoss;

                                return (
                                    <div key={`${x}-${y}`} className={`aspect-square flex items-center justify-center rounded text-3xl ${cell === 1 ? 'bg-gray-800' : 'bg-teal-900/40'} ${isGoal && !isPlayer ? 'bg-gradient-to-br from-yellow-500 to-orange-500' : ''} ${isGate ? 'bg-gradient-to-br from-red-900 to-orange-800' : ''}`}>
                                        {isPlayer && <span className="animate-hero">ü¶∏</span>}
                                        {monster && <span className={isBossMonster ? "animate-boss" : "animate-monster"}>{monster.type.emoji}</span>}
                                        {isGoal && !isPlayer && <span className="animate-goal">üèÅ</span>}
                                        {isGate && !isPlayer && <span className="text-2xl">üîí</span>}
                                    </div>
                                );
                            }))}
                        </div>

                        <div className="mt-6 flex justify-center gap-2 text-sm">
                            <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white"><div className="w-4 h-4 bg-blue-500 rounded"></div><span>{t.you}</span></div>
                            <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white"><div className="w-4 h-4 bg-red-500 rounded"></div><span>{t.monster}</span></div>
                            <div className="flex items-center gap-1 bg-black/40 px-3 py-1 rounded-full text-white"><div className="w-4 h-4 bg-purple-500 rounded"></div><span>{t.boss}</span></div>
                        </div>

                        <div className="mt-6 flex flex-col items-center">
                            <button onClick={() => movePlayer('up')} className="bg-blue-600 text-white p-3 rounded-xl mb-2 hover:bg-blue-700">‚¨ÜÔ∏è</button>
                            <div className="flex gap-2">
                                <button onClick={() => movePlayer('left')} className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700">‚¨ÖÔ∏è</button>
                                <button onClick={() => movePlayer('down')} className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700">‚¨áÔ∏è</button>
                                <button onClick={() => movePlayer('right')} className="bg-blue-600 text-white p-3 rounded-xl hover:bg-blue-700">‚û°Ô∏è</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'battle' && currentMonster && battleState) {
        return (
            <div className={`min-h-screen ${currentMonster.isBoss ? 'bg-gradient-to-b from-purple-600 to-red-600' : 'bg-gradient-to-b from-red-400 to-orange-400'} flex items-center justify-center p-4`}>
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <div className="text-center mb-6">
                        <div className={`${currentMonster.isBoss ? 'text-8xl' : 'text-6xl'} mb-4`}>{currentMonster.type.emoji}</div>
                        <h2 className="text-3xl font-bold text-purple-600">
                            {currentMonster.isBoss && `üíÄ ${t.bossBattle} üíÄ`}
                            {!currentMonster.isBoss && `${currentMonster.type.name}${t.appeared}`}
                            {currentMonster.isBoss && <div className="text-2xl mt-2">{currentMonster.type.name}</div>}
                        </h2>
                        <p className="text-xl mt-2">{currentMonster.type.description}</p>
                    </div>

                    <div className="flex justify-center gap-2 mb-6">
                        {[...Array(battleState.maxHealth)].map((_, i) => (
                            <span key={i} className={`heart ${i < battleState.monsterHealth ? 'filled' : 'empty'}`}>‚ù§Ô∏è</span>
                        ))}
                    </div>

                    <div className={`text-center text-3xl font-bold mb-6 ${timeLeft <= 10 ? 'text-red-600 animate-pulse' : 'text-blue-600'}`}>{t.timeLeft}: {timeLeft}{t.seconds}</div>

                    <div className="bg-blue-100 rounded-2xl p-6 mb-6">
                        <div className="text-4xl font-bold text-center text-blue-800">{battleState.currentProblem.question}</div>
                    </div>

                    {message && <div className={`text-center text-2xl font-bold mb-4 ${message.includes(t.correct) ? 'text-green-600' : 'text-orange-600'}`}>{message}</div>}

                    {battleState.currentProblem.hint && (
                        <div className="text-center mb-4">
                            <button onClick={() => setShowHint(!showHint)} className="bg-yellow-300 text-yellow-800 font-bold px-4 py-2 rounded-lg hover:bg-yellow-400">{showHint ? t.hideHint : t.viewHint}</button>
                        </div>
                    )}

                    {showHint && battleState.currentProblem.hint && (
                        <div className="text-center text-xl text-yellow-800 mb-4">{battleState.currentProblem.hint}</div>
                    )}

                    <div className="grid grid-cols-2 gap-4">
                        {battleState.currentProblem.options.map((option, index) => (
                            <button key={index} onClick={() => checkAnswer(option)} className={`${currentMonster.isBoss ? 'bg-gradient-to-r from-purple-600 to-red-600' : 'bg-gradient-to-r from-purple-500 to-pink-500'} text-white text-3xl font-bold py-6 rounded-2xl hover:scale-105 transition-all`} disabled={message !== ''}>
                                {option}
                            </button>
                        ))}
                    </div>

                    {currentMonster.isBoss && <div className="mt-4 text-center text-red-600 font-bold animate-pulse">‚ö†Ô∏è {t.bossWarning} ‚ö†Ô∏è</div>}
                </div>
            </div>
        );
    }

    if (gameState === 'victory') {
        return (
            <div className="min-h-screen bg-gradient-to-b from-yellow-400 to-orange-400 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full text-center">
                    <div className="text-6xl mb-4">üéâüèÜüéâ</div>
                    <h1 className="text-5xl font-bold text-purple-600 mb-6">{t.level} {currentLevel} {t.clearMessage}</h1>
                    <div className="bg-blue-100 rounded-2xl p-6 mb-6">
                        <p className="text-2xl mb-2">{t.defeated}: {defeatedMonsters.length}{t.body}</p>
                        <p className="text-2xl">{t.accuracy}: {playerStats.totalQuestionsAnswered > 0 ? Math.round((playerStats.correctAnswers / playerStats.totalQuestionsAnswered) * 100) : 0}%</p>
                    </div>

                    {playerStats.badges.length > 0 && (
                        <div className="mb-6">
                            <h3 className="text-2xl font-bold mb-3">{t.badges}</h3>
                            <div className="flex justify-center gap-3">
                                {playerStats.badges.includes('first_clear') && <div className="text-center"><div className="text-5xl">‚≠ê</div><p className="text-sm mt-1">{t.firstClear}</p></div>}
                                {playerStats.badges.includes('perfect_clear') && <div className="text-center"><div className="text-5xl">üèÜ</div><p className="text-sm mt-1">{t.perfectClear}</p></div>}
                                {playerStats.badges.includes('multiplication_master') && <div className="text-center"><div className="text-5xl">üåü</div><p className="text-sm mt-1">{t.multiplicationMaster}</p></div>}
                            </div>
                        </div>
                    )}

                    <div className="flex flex-col gap-4">
                        <button onClick={nextLevel} className="bg-gradient-to-r from-green-500 to-blue-500 text-white text-3xl font-bold py-6 rounded-2xl hover:from-green-600 hover:to-blue-600">{t.nextLevel}</button>
                        <button onClick={() => setGameState('menu')} className="bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600">{t.menu}</button>
                    </div>
                </div>
            </div>
        );
    }

    if (gameState === 'stats') {
        return (
            <div className="min-h-screen bg-gradient-to-b from-purple-400 to-blue-400 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">üèÜ {t.yourStats}</h2>
                    <div className="space-y-4">
                        <div className="bg-blue-100 rounded-xl p-4"><p className="text-2xl">üéØ {t.totalDefeated}: {playerStats.totalMonstersDefeated}{t.body}</p></div>
                        <div className="bg-green-100 rounded-xl p-4"><p className="text-2xl">üìù {t.totalQuestions}: {playerStats.totalQuestionsAnswered}{t.question}</p></div>
                        <div className="bg-yellow-100 rounded-xl p-4"><p className="text-2xl">‚úÖ {t.correctAnswers}: {playerStats.correctAnswers}{t.question}</p></div>
                        <div className="bg-purple-100 rounded-xl p-4"><p className="text-2xl">üìä {t.accuracy}: {playerStats.totalQuestionsAnswered > 0 ? Math.round((playerStats.correctAnswers / playerStats.totalQuestionsAnswered) * 100) : 0}%</p></div>
                    </div>

                    {playerStats.badges.length > 0 && (
                        <div className="mt-6">
                            <h3 className="text-2xl font-bold mb-3 text-center">{t.badges}</h3>
                            <div className="flex justify-center gap-4 flex-wrap">
                                {playerStats.badges.includes('first_clear') && <div className="text-center"><div className="text-6xl">‚≠ê</div><p className="text-sm mt-1">{t.firstClear}</p></div>}
                                {playerStats.badges.includes('perfect_clear') && <div className="text-center"><div className="text-6xl">üèÜ</div><p className="text-sm mt-1">{t.perfectClear}</p></div>}
                                {playerStats.badges.includes('multiplication_master') && <div className="text-center"><div className="text-6xl">üåü</div><p className="text-sm mt-1">{t.multiplicationMaster}</p></div>}
                            </div>
                        </div>
                    )}

                    <button onClick={() => setGameState('menu')} className="mt-6 w-full bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600">{t.back}</button>
                </div>
            </div>
        );
    }

    if (gameState === 'dictionary') {
        const monsterTypes = getMonsterTypes();
        return (
            <div className="min-h-screen bg-gradient-to-b from-green-400 to-blue-400 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                    <LanguageSelector />
                    <h2 className="text-4xl font-bold text-center mb-6 text-purple-600">üìñ {t.dictionary}</h2>

                    <div className="space-y-4 max-h-96 overflow-y-auto">
                        {monsterTypes.map(monster => {
                            const isUnlocked = playerStats.unlockedMonsters.includes(monster.id);
                            return (
                                <div key={monster.id} className={`rounded-xl p-4 ${isUnlocked ? monster.isBoss ? 'bg-gradient-to-r from-purple-200 to-red-200 border-2 border-purple-400' : 'bg-gradient-to-r from-purple-100 to-pink-100' : 'bg-gray-100'}`}>
                                    <div className="flex items-center gap-4">
                                        <div className={`${monster.isBoss ? 'text-6xl' : 'text-5xl'}`}>{isUnlocked ? monster.emoji : '‚ùì'}</div>
                                        <div className="flex-1">
                                            <h3 className="text-2xl font-bold flex items-center gap-2">{isUnlocked ? monster.name : 'ÔºüÔºüÔºü'}{isUnlocked && monster.isBoss && <span className="text-purple-600">üëë {t.boss}</span>}</h3>
                                            <p className="text-lg text-gray-600">{isUnlocked ? monster.description : t.notFound}</p>
                                            {isUnlocked && monster.isBoss && <p className="text-sm text-purple-600 mt-1">{t.hp}: {monster.health} ‚ù§Ô∏è</p>}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    <div className="mt-6 text-center text-gray-600"><p className="text-xl font-bold">{playerStats.unlockedMonsters.length} / {getMonsterTypes().length} {t.found}</p></div>

                    <button onClick={() => setGameState('menu')} className="mt-6 w-full bg-gray-500 text-white text-2xl font-bold py-4 rounded-2xl hover:bg-gray-600">{t.back}</button>
                </div>
            </div>
        );
    }

    return null;
};

// Render
ReactDOM.render(<MathMazeGame />, document.getElementById('root'));
</script>
</body>
</html>
